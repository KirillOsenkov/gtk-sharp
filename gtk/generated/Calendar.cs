// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gtk {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	[Calendar]
	public class Calendar : Gtk.Widget {

		[Obsolete]
		protected Calendar(GLib.GType gtype) : base(gtype) {}
		public Calendar(IntPtr raw) : base(raw) {}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_calendar_new();

		public Calendar () : base (IntPtr.Zero)
		{
			if (GetType () != typeof (Calendar)) {
				Gtk.Application.AssertMainThread();
				CreateNativeObject (Array.Empty<IntPtr> (), Array.Empty<GLib.Value> (), 0);
				return;
			}
			owned = true;
			Raw = gtk_calendar_new();
		}

		[GLib.Property ("year")]
		public int Year {
			get {
				using (GLib.Value val = GetProperty ("year")) {
					int ret = (int) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("year", val);
				}
			}
		}

		[GLib.Property ("month")]
		public int Month {
			get {
				using (GLib.Value val = GetProperty ("month")) {
					int ret = (int) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("month", val);
				}
			}
		}

		[GLib.Property ("day")]
		public int Day {
			get {
				using (GLib.Value val = GetProperty ("day")) {
					int ret = (int) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("day", val);
				}
			}
		}

		[GLib.Property ("show-heading")]
		public bool ShowHeading {
			get {
				using (GLib.Value val = GetProperty ("show-heading")) {
					bool ret = (bool) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("show-heading", val);
				}
			}
		}

		[GLib.Property ("show-day-names")]
		public bool ShowDayNames {
			get {
				using (GLib.Value val = GetProperty ("show-day-names")) {
					bool ret = (bool) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("show-day-names", val);
				}
			}
		}

		[GLib.Property ("no-month-change")]
		public bool NoMonthChange {
			get {
				using (GLib.Value val = GetProperty ("no-month-change")) {
					bool ret = (bool) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("no-month-change", val);
				}
			}
		}

		[GLib.Property ("show-week-numbers")]
		public bool ShowWeekNumbers {
			get {
				using (GLib.Value val = GetProperty ("show-week-numbers")) {
					bool ret = (bool) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("show-week-numbers", val);
				}
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void MonthChangedVMDelegate (IntPtr calendar);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_calendar_override_month_changed (IntPtr gtype, MonthChangedVMDelegate cb);

		static MonthChangedVMDelegate MonthChangedVMCallback;

		static void monthchanged_cb (IntPtr calendar)
		{
			try {
				Calendar calendar_managed = GLib.Object.GetObject (calendar, false) as Calendar;
				calendar_managed.OnMonthChanged ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideMonthChanged (GLib.GType gtype)
		{
			if (MonthChangedVMCallback == null)
				MonthChangedVMCallback = new MonthChangedVMDelegate (monthchanged_cb);
			gtksharp_calendar_override_month_changed (gtype.Val, MonthChangedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_calendar_base_month_changed (IntPtr calendar);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Calendar), ConnectionMethod="OverrideMonthChanged")]
		protected virtual void OnMonthChanged ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_calendar_base_month_changed (Handle);
		}

		[GLib.Signal("month_changed")]
		public event System.EventHandler MonthChanged {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "month_changed");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "month_changed");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DaySelectedVMDelegate (IntPtr calendar);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_calendar_override_day_selected (IntPtr gtype, DaySelectedVMDelegate cb);

		static DaySelectedVMDelegate DaySelectedVMCallback;

		static void dayselected_cb (IntPtr calendar)
		{
			try {
				Calendar calendar_managed = GLib.Object.GetObject (calendar, false) as Calendar;
				calendar_managed.OnDaySelected ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideDaySelected (GLib.GType gtype)
		{
			if (DaySelectedVMCallback == null)
				DaySelectedVMCallback = new DaySelectedVMDelegate (dayselected_cb);
			gtksharp_calendar_override_day_selected (gtype.Val, DaySelectedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_calendar_base_day_selected (IntPtr calendar);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Calendar), ConnectionMethod="OverrideDaySelected")]
		protected virtual void OnDaySelected ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_calendar_base_day_selected (Handle);
		}

		[GLib.Signal("day_selected")]
		public event System.EventHandler DaySelected {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "day_selected");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "day_selected");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DaySelectedDoubleClickVMDelegate (IntPtr calendar);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_calendar_override_day_selected_double_click (IntPtr gtype, DaySelectedDoubleClickVMDelegate cb);

		static DaySelectedDoubleClickVMDelegate DaySelectedDoubleClickVMCallback;

		static void dayselecteddoubleclick_cb (IntPtr calendar)
		{
			try {
				Calendar calendar_managed = GLib.Object.GetObject (calendar, false) as Calendar;
				calendar_managed.OnDaySelectedDoubleClick ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideDaySelectedDoubleClick (GLib.GType gtype)
		{
			if (DaySelectedDoubleClickVMCallback == null)
				DaySelectedDoubleClickVMCallback = new DaySelectedDoubleClickVMDelegate (dayselecteddoubleclick_cb);
			gtksharp_calendar_override_day_selected_double_click (gtype.Val, DaySelectedDoubleClickVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_calendar_base_day_selected_double_click (IntPtr calendar);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Calendar), ConnectionMethod="OverrideDaySelectedDoubleClick")]
		protected virtual void OnDaySelectedDoubleClick ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_calendar_base_day_selected_double_click (Handle);
		}

		[GLib.Signal("day_selected_double_click")]
		public event System.EventHandler DaySelectedDoubleClick {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "day_selected_double_click");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "day_selected_double_click");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void PrevMonthVMDelegate (IntPtr calendar);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_calendar_override_prev_month (IntPtr gtype, PrevMonthVMDelegate cb);

		static PrevMonthVMDelegate PrevMonthVMCallback;

		static void prevmonth_cb (IntPtr calendar)
		{
			try {
				Calendar calendar_managed = GLib.Object.GetObject (calendar, false) as Calendar;
				calendar_managed.OnPrevMonth ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverridePrevMonth (GLib.GType gtype)
		{
			if (PrevMonthVMCallback == null)
				PrevMonthVMCallback = new PrevMonthVMDelegate (prevmonth_cb);
			gtksharp_calendar_override_prev_month (gtype.Val, PrevMonthVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_calendar_base_prev_month (IntPtr calendar);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Calendar), ConnectionMethod="OverridePrevMonth")]
		protected virtual void OnPrevMonth ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_calendar_base_prev_month (Handle);
		}

		[GLib.Signal("prev_month")]
		public event System.EventHandler PrevMonth {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "prev_month");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "prev_month");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void NextMonthVMDelegate (IntPtr calendar);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_calendar_override_next_month (IntPtr gtype, NextMonthVMDelegate cb);

		static NextMonthVMDelegate NextMonthVMCallback;

		static void nextmonth_cb (IntPtr calendar)
		{
			try {
				Calendar calendar_managed = GLib.Object.GetObject (calendar, false) as Calendar;
				calendar_managed.OnNextMonth ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideNextMonth (GLib.GType gtype)
		{
			if (NextMonthVMCallback == null)
				NextMonthVMCallback = new NextMonthVMDelegate (nextmonth_cb);
			gtksharp_calendar_override_next_month (gtype.Val, NextMonthVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_calendar_base_next_month (IntPtr calendar);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Calendar), ConnectionMethod="OverrideNextMonth")]
		protected virtual void OnNextMonth ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_calendar_base_next_month (Handle);
		}

		[GLib.Signal("next_month")]
		public event System.EventHandler NextMonth {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "next_month");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "next_month");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void PrevYearVMDelegate (IntPtr calendar);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_calendar_override_prev_year (IntPtr gtype, PrevYearVMDelegate cb);

		static PrevYearVMDelegate PrevYearVMCallback;

		static void prevyear_cb (IntPtr calendar)
		{
			try {
				Calendar calendar_managed = GLib.Object.GetObject (calendar, false) as Calendar;
				calendar_managed.OnPrevYear ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverridePrevYear (GLib.GType gtype)
		{
			if (PrevYearVMCallback == null)
				PrevYearVMCallback = new PrevYearVMDelegate (prevyear_cb);
			gtksharp_calendar_override_prev_year (gtype.Val, PrevYearVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_calendar_base_prev_year (IntPtr calendar);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Calendar), ConnectionMethod="OverridePrevYear")]
		protected virtual void OnPrevYear ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_calendar_base_prev_year (Handle);
		}

		[GLib.Signal("prev_year")]
		public event System.EventHandler PrevYear {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "prev_year");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "prev_year");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void NextYearVMDelegate (IntPtr calendar);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_calendar_override_next_year (IntPtr gtype, NextYearVMDelegate cb);

		static NextYearVMDelegate NextYearVMCallback;

		static void nextyear_cb (IntPtr calendar)
		{
			try {
				Calendar calendar_managed = GLib.Object.GetObject (calendar, false) as Calendar;
				calendar_managed.OnNextYear ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideNextYear (GLib.GType gtype)
		{
			if (NextYearVMCallback == null)
				NextYearVMCallback = new NextYearVMDelegate (nextyear_cb);
			gtksharp_calendar_override_next_year (gtype.Val, NextYearVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_calendar_base_next_year (IntPtr calendar);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Calendar), ConnectionMethod="OverrideNextYear")]
		protected virtual void OnNextYear ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_calendar_base_next_year (Handle);
		}

		[GLib.Signal("next_year")]
		public event System.EventHandler NextYear {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "next_year");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "next_year");
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_calendar_clear_marks(IntPtr raw);

		public void ClearMarks() {
			gtk_calendar_clear_marks(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_calendar_freeze(IntPtr raw);

		[Obsolete]
		public void Freeze() {
			gtk_calendar_freeze(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_calendar_get_date(IntPtr raw, out uint year, out uint month, out uint day);

		public void GetDate(out uint year, out uint month, out uint day) {
			Gtk.Application.AssertMainThread();
			gtk_calendar_get_date(Handle, out year, out month, out day);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_calendar_get_display_options(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_calendar_display_options(IntPtr raw, int flags);

		public Gtk.CalendarDisplayOptions DisplayOptions { 
			get {
				int raw_ret = gtk_calendar_get_display_options(Handle);
				Gtk.CalendarDisplayOptions ret = (Gtk.CalendarDisplayOptions) raw_ret;
				return ret;
			}
			set {
				Gtk.Application.AssertMainThread();
				gtk_calendar_display_options(Handle, (int) value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_calendar_get_type();

		static GLib.GType _gtype = new GLib.GType (gtk_calendar_get_type());
		public static new GLib.GType GType { 
			get {
								return _gtype;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_calendar_mark_day(IntPtr raw, uint day);

		public bool MarkDay(uint day) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_calendar_mark_day(Handle, day);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_calendar_select_day(IntPtr raw, uint day);

		public void SelectDay(uint day) {
			Gtk.Application.AssertMainThread();
			gtk_calendar_select_day(Handle, day);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_calendar_select_month(IntPtr raw, uint month, uint year);

		public bool SelectMonth(uint month, uint year) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_calendar_select_month(Handle, month, year);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_calendar_thaw(IntPtr raw);

		[Obsolete]
		public void Thaw() {
			gtk_calendar_thaw(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_calendar_unmark_day(IntPtr raw, uint day);

		public bool UnmarkDay(uint day) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_calendar_unmark_day(Handle, day);
			bool ret = raw_ret;
			return ret;
		}

#endregion
#region Customized extensions
#line 1 "Calendar.custom"
// Gtk.Calendar.Custom - Gtk Calendar class customizations
//
// Author:
//	 Gonzalo Paniagua Javier (gonzalo@ximian.com)
//
// Copyright (c) 2003 Ximian, Inc. (http://www.ximian.com)
//
// This code is inserted after the automatically generated code.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of version 2 of the Lesser GNU General 
// Public License as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this program; if not, write to the
// Free Software Foundation, Inc., 59 Temple Place - Suite 330,
// Boston, MA 02111-1307, USA.


public DateTime GetDate ()
{
	uint year, month, day;
	GetDate (out year, out month, out day);
	DateTime result;
	try {
		result = new DateTime ((int) year, (int) month + 1, (int) day);
	} catch (ArgumentOutOfRangeException) {
		// Kluge to workaround GtkCalendar being in an invalid state
		// when raising month_changed signals, like in bug #78524.
		result = new DateTime ((int) year, (int) month + 1, DateTime.DaysInMonth ((int) year, (int) month + 1));
	}
	return result;
}


// This defines a Date property for Calendar
// Note that the setter causes CalendarChange events to be fired
public DateTime Date

{
        get {
                return this.GetDate();
        }
        set {
                uint month= (uint) value.Month-1;
                uint year= (uint) value.Year;
                uint day = (uint) value.Day;
             
                SelectMonth(month,year);
                SelectDay(day);
        }        
}

#endregion
	}

	internal class CalendarAttribute : GLib.GTypeTypeAttribute {
		[DllImport ("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_calendar_get_type ();

		private static GLib.GType _gtype = new GLib.GType (gtk_calendar_get_type ());
		public static GLib.GType GType { get { return _gtype; } }
		public override GLib.GType Type { get { return _gtype; } }

	}
}
