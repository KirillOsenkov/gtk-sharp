// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gtk {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	[StatusIcon]
	public class StatusIcon : GLib.Object {

		[Obsolete]
		protected StatusIcon(GLib.GType gtype) : base(gtype) {}
		public StatusIcon(IntPtr raw) : base(raw) {}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_status_icon_new();

		public StatusIcon () : base (IntPtr.Zero)
		{
			if (GetType () != typeof (StatusIcon)) {
				Gtk.Application.AssertMainThread();
				CreateNativeObject (Array.Empty<IntPtr> (), Array.Empty<GLib.Value> (), 0);
				return;
			}
			owned = true;
			Raw = gtk_status_icon_new();
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_status_icon_new_from_file(IntPtr filename);

		public StatusIcon (string filename) : base (IntPtr.Zero)
		{
			if (GetType () != typeof (StatusIcon)) {
				Gtk.Application.AssertMainThread();
				throw new InvalidOperationException ("Can't override this constructor.");
			}
			Gtk.Application.AssertMainThread();
			IntPtr native_filename = GLib.Marshaller.StringToPtrGStrdup (filename);
			owned = true;
			Raw = gtk_status_icon_new_from_file(native_filename);
			GLib.Marshaller.Free (native_filename);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_status_icon_new_from_icon_name(IntPtr icon_name);

		public static StatusIcon NewFromIconName(string icon_name)
		{
			Gtk.Application.AssertMainThread();
			IntPtr native_icon_name = GLib.Marshaller.StringToPtrGStrdup (icon_name);
			StatusIcon result = new StatusIcon (gtk_status_icon_new_from_icon_name(native_icon_name));
			GLib.Marshaller.Free (native_icon_name);
			return result;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_status_icon_new_from_pixbuf(IntPtr pixbuf);

		public StatusIcon (Gdk.Pixbuf pixbuf) : base (IntPtr.Zero)
		{
			if (GetType () != typeof (StatusIcon)) {
				Gtk.Application.AssertMainThread();
				unsafe {
					var vals = stackalloc GLib.Value[1];
					var names = stackalloc IntPtr[1];
					var param_count = 0;
					if (pixbuf != null) {
						names[param_count] = GLib.Marshaller.StringToPtrGStrdup ("pixbuf");
						vals[param_count++] = new GLib.Value (pixbuf);
					}
					CreateNativeObject (names, vals, param_count);
				}
				return;
			}
			Gtk.Application.AssertMainThread();
			owned = true;
			Raw = gtk_status_icon_new_from_pixbuf(pixbuf == null ? IntPtr.Zero : pixbuf.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_status_icon_new_from_stock(IntPtr stock_id);

		public static StatusIcon NewFromStock(string stock_id)
		{
			Gtk.Application.AssertMainThread();
			IntPtr native_stock_id = GLib.Marshaller.StringToPtrGStrdup (stock_id);
			StatusIcon result = new StatusIcon (gtk_status_icon_new_from_stock(native_stock_id));
			GLib.Marshaller.Free (native_stock_id);
			return result;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_status_icon_get_pixbuf(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_status_icon_set_from_pixbuf(IntPtr raw, IntPtr pixbuf);

		[GLib.Property ("pixbuf")]
		public Gdk.Pixbuf Pixbuf {
			get  {
				IntPtr raw_ret = gtk_status_icon_get_pixbuf(Handle);
				Gdk.Pixbuf ret = GLib.Object.GetObject(raw_ret) as Gdk.Pixbuf;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_status_icon_set_from_pixbuf(Handle, value == null ? IntPtr.Zero : value.Handle);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_status_icon_set_from_file(IntPtr raw, IntPtr filename);

		[GLib.Property ("file")]
		public string File {
			set  {
				Gtk.Application.AssertMainThread();
				IntPtr native_value = GLib.Marshaller.StringToPtrGStrdup (value);
				gtk_status_icon_set_from_file(Handle, native_value);
				GLib.Marshaller.Free (native_value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_status_icon_get_stock(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_status_icon_set_from_stock(IntPtr raw, IntPtr stock_id);

		[GLib.Property ("stock")]
		public string Stock {
			get  {
				IntPtr raw_ret = gtk_status_icon_get_stock(Handle);
				string ret = GLib.Marshaller.Utf8PtrToString (raw_ret);
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				IntPtr native_value = GLib.Marshaller.StringToPtrGStrdup (value);
				gtk_status_icon_set_from_stock(Handle, native_value);
				GLib.Marshaller.Free (native_value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_status_icon_get_icon_name(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_status_icon_set_from_icon_name(IntPtr raw, IntPtr icon_name);

		[GLib.Property ("icon-name")]
		public string IconName {
			get  {
				IntPtr raw_ret = gtk_status_icon_get_icon_name(Handle);
				string ret = GLib.Marshaller.Utf8PtrToString (raw_ret);
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				IntPtr native_value = GLib.Marshaller.StringToPtrGStrdup (value);
				gtk_status_icon_set_from_icon_name(Handle, native_value);
				GLib.Marshaller.Free (native_value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_status_icon_get_storage_type(IntPtr raw);

		[GLib.Property ("storage-type")]
		public Gtk.ImageType StorageType {
			get  {
				int raw_ret = gtk_status_icon_get_storage_type(Handle);
				Gtk.ImageType ret = (Gtk.ImageType) raw_ret;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_status_icon_get_size(IntPtr raw);

		[GLib.Property ("size")]
		public int Size {
			get  {
				int raw_ret = gtk_status_icon_get_size(Handle);
				int ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_status_icon_get_screen(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_status_icon_set_screen(IntPtr raw, IntPtr screen);

		[GLib.Property ("screen")]
		public Gdk.Screen Screen {
			get  {
				IntPtr raw_ret = gtk_status_icon_get_screen(Handle);
				Gdk.Screen ret = GLib.Object.GetObject(raw_ret) as Gdk.Screen;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_status_icon_set_screen(Handle, value == null ? IntPtr.Zero : value.Handle);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_status_icon_get_blinking(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_status_icon_set_blinking(IntPtr raw, bool blinking);

		[GLib.Property ("blinking")]
		public bool Blinking {
			get  {
				bool raw_ret = gtk_status_icon_get_blinking(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_status_icon_set_blinking(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_status_icon_get_visible(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_status_icon_set_visible(IntPtr raw, bool visible);

		[GLib.Property ("visible")]
		public bool Visible {
			get  {
				bool raw_ret = gtk_status_icon_get_visible(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_status_icon_set_visible(Handle, value);
			}
		}

		[GLib.Property ("embedded")]
		public bool Embedded {
			get {
				using (GLib.Value val = GetProperty ("embedded")) {
					bool ret = (bool) val;
					return ret;
				}
			}
		}

		[GLib.Property ("orientation")]
		public Gtk.Orientation Orientation {
			get {
				using (GLib.Value val = GetProperty ("orientation")) {
					Gtk.Orientation ret = (Gtk.Orientation) (Enum) val;
					return ret;
				}
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ActivateVMDelegate (IntPtr status_icon);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_statusicon_override_activate (IntPtr gtype, ActivateVMDelegate cb);

		static ActivateVMDelegate ActivateVMCallback;

		static void activate_cb (IntPtr status_icon)
		{
			try {
				StatusIcon status_icon_managed = GLib.Object.GetObject (status_icon, false) as StatusIcon;
				status_icon_managed.OnActivate ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideActivate (GLib.GType gtype)
		{
			if (ActivateVMCallback == null)
				ActivateVMCallback = new ActivateVMDelegate (activate_cb);
			gtksharp_statusicon_override_activate (gtype.Val, ActivateVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_statusicon_base_activate (IntPtr status_icon);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.StatusIcon), ConnectionMethod="OverrideActivate")]
		protected virtual void OnActivate ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_statusicon_base_activate (Handle);
		}

		[GLib.Signal("activate")]
		public event System.EventHandler Activate {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "activate");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "activate");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void PopupMenuVMDelegate (IntPtr status_icon, uint button, uint activate_time);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_statusicon_override_popup_menu (IntPtr gtype, PopupMenuVMDelegate cb);

		static PopupMenuVMDelegate PopupMenuVMCallback;

		static void popupmenu_cb (IntPtr status_icon, uint button, uint activate_time)
		{
			try {
				StatusIcon status_icon_managed = GLib.Object.GetObject (status_icon, false) as StatusIcon;
				status_icon_managed.OnPopupMenu (button, activate_time);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverridePopupMenu (GLib.GType gtype)
		{
			if (PopupMenuVMCallback == null)
				PopupMenuVMCallback = new PopupMenuVMDelegate (popupmenu_cb);
			gtksharp_statusicon_override_popup_menu (gtype.Val, PopupMenuVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_statusicon_base_popup_menu (IntPtr status_icon, uint button, uint activate_time);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.StatusIcon), ConnectionMethod="OverridePopupMenu")]
		protected virtual void OnPopupMenu (uint button, uint activate_time)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_statusicon_base_popup_menu (Handle, button, activate_time);
		}

		[GLib.Signal("popup_menu")]
		public event Gtk.PopupMenuHandler PopupMenu {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "popup_menu", typeof (Gtk.PopupMenuArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "popup_menu", typeof (Gtk.PopupMenuArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool SizeChangedVMDelegate (IntPtr status_icon, int size);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_statusicon_override_size_changed (IntPtr gtype, SizeChangedVMDelegate cb);

		static SizeChangedVMDelegate SizeChangedVMCallback;

		static bool sizechanged_cb (IntPtr status_icon, int size)
		{
			try {
				StatusIcon status_icon_managed = GLib.Object.GetObject (status_icon, false) as StatusIcon;
				return status_icon_managed.OnSizeChanged (size);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideSizeChanged (GLib.GType gtype)
		{
			if (SizeChangedVMCallback == null)
				SizeChangedVMCallback = new SizeChangedVMDelegate (sizechanged_cb);
			gtksharp_statusicon_override_size_changed (gtype.Val, SizeChangedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_statusicon_base_size_changed (IntPtr status_icon, int size);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.StatusIcon), ConnectionMethod="OverrideSizeChanged")]
		protected virtual bool OnSizeChanged (int size)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_statusicon_base_size_changed (Handle, size);
			return __ret;
		}

		[GLib.Signal("size_changed")]
		public event Gtk.SizeChangedHandler SizeChanged {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "size_changed", typeof (Gtk.SizeChangedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "size_changed", typeof (Gtk.SizeChangedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_status_icon_get_type();

		static GLib.GType _gtype = new GLib.GType (gtk_status_icon_get_type());
		public static new GLib.GType GType { 
			get {
								return _gtype;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_status_icon_is_embedded(IntPtr raw);

		public bool IsEmbedded { 
			get {
				bool raw_ret = gtk_status_icon_is_embedded(Handle);
				bool ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_status_icon_position_menu(IntPtr menu, out int x, out int y, out bool push_in, IntPtr user_data);

		public static void PositionMenu(Gtk.Menu menu, out int x, out int y, out bool push_in, IntPtr user_data) {
			Gtk.Application.AssertMainThread();
			gtk_status_icon_position_menu(menu == null ? IntPtr.Zero : menu.Handle, out x, out y, out push_in, user_data);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_status_icon_set_tooltip(IntPtr raw, IntPtr tooltip_text);

		public string Tooltip { 
			set {
				Gtk.Application.AssertMainThread();
				IntPtr native_value = GLib.Marshaller.StringToPtrGStrdup (value);
				gtk_status_icon_set_tooltip(Handle, native_value);
				GLib.Marshaller.Free (native_value);
			}
		}

#endregion
#region Customized extensions
#line 1 "StatusIcon.custom"
// StatusIcon.custom - customizations to Gtk.StatusIcon
//
// Authors: Mike Kestner  <mkestner@novell.com>
// Authors: Stephane Delcroix  <sdelcroix@novell.com>
//
// Copyright (c) 2007-2008 Novell, Inc.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of version 2 of the Lesser GNU General 
// Public License as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this program; if not, write to the
// Free Software Foundation, Inc., 59 Temple Place - Suite 330,
// Boston, MA 02111-1307, USA.

		[Obsolete ("Replaced by (out Screen, out Rectangle, out Orientation) overload")]
		public bool GetGeometry (Gdk.Screen screen, Gdk.Rectangle area, out Orientation orientation) 
		{
			Gdk.Screen junk;
			return GetGeometry (out junk, out area, out orientation);
		}

		[DllImport("gtksharpglue-2", CallingConvention=CallingConvention.Cdecl)]
		static extern void gtksharp_gtk_status_icon_present_menu (IntPtr raw, IntPtr menu, uint button, uint activate_time);

		public void PresentMenu (Menu menu, uint button, uint activate_time) 
		{
			gtksharp_gtk_status_icon_present_menu (Handle, menu == null ? IntPtr.Zero : menu.Handle, button, activate_time);
		}

		[Obsolete ("use the File property instead")]
		public string FromFile { 
			set {
				IntPtr native_value = GLib.Marshaller.StringToPtrGStrdup (value);
				gtk_status_icon_set_from_file(Handle, native_value);
				GLib.Marshaller.Free (native_value);
			}
		}

		[Obsolete ("use the IconName property instead")]
		public string FromIconName { 
			set {
				IntPtr native_value = GLib.Marshaller.StringToPtrGStrdup (value);
				gtk_status_icon_set_from_icon_name(Handle, native_value);
				GLib.Marshaller.Free (native_value);
			}
		}

		[Obsolete ("use the Pixbuf property instead")]
		public Gdk.Pixbuf FromPixbuf { 
			set {
				gtk_status_icon_set_from_pixbuf(Handle, value == null ? IntPtr.Zero : value.Handle);
			}
		}

		[Obsolete ("use the Stock property instead")]
		public string FromStock { 
			set {
				IntPtr native_value = GLib.Marshaller.StringToPtrGStrdup (value);
				gtk_status_icon_set_from_stock(Handle, native_value);
				GLib.Marshaller.Free (native_value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_status_icon_get_geometry(IntPtr raw, out IntPtr screen, IntPtr area, out int orientation);

		public bool GetGeometry(out Gdk.Screen screen, out Gdk.Rectangle area, out Gtk.Orientation orientation)
		{
			IntPtr native_screen;
			IntPtr native_area = Marshal.AllocHGlobal (Marshal.SizeOf (typeof (Gdk.Rectangle)));
			int native_orientation;
			bool ret = gtk_status_icon_get_geometry(Handle, out native_screen, native_area, out native_orientation);
			if (ret) {
				screen = GLib.Object.GetObject(native_screen) as Gdk.Screen;
				area = Gdk.Rectangle.New (native_area);
				orientation = (Gtk.Orientation) native_orientation;
			} else {
				screen = null;
				area = Gdk.Rectangle.Zero;
				orientation = Gtk.Orientation.Horizontal;
			}
			Marshal.FreeHGlobal (native_area);
			return ret;
		}


#endregion
	}

	internal class StatusIconAttribute : GLib.GTypeTypeAttribute {
		[DllImport ("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_status_icon_get_type ();

		private static GLib.GType _gtype = new GLib.GType (gtk_status_icon_get_type ());
		public static GLib.GType GType { get { return _gtype; } }
		public override GLib.GType Type { get { return _gtype; } }

	}
}
