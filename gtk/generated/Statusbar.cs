// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gtk {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	[Statusbar]
	public class Statusbar : Gtk.HBox {

		[Obsolete]
		protected Statusbar(GLib.GType gtype) : base(gtype) {}
		public Statusbar(IntPtr raw) : base(raw) {}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_statusbar_new();

		public Statusbar () : base (IntPtr.Zero)
		{
			if (GetType () != typeof (Statusbar)) {
				Gtk.Application.AssertMainThread();
				CreateNativeObject (Array.Empty<IntPtr> (), Array.Empty<GLib.Value> (), 0);
				return;
			}
			owned = true;
			Raw = gtk_statusbar_new();
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_statusbar_get_has_resize_grip(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_statusbar_set_has_resize_grip(IntPtr raw, bool setting);

		[GLib.Property ("has-resize-grip")]
		public bool HasResizeGrip {
			get  {
				bool raw_ret = gtk_statusbar_get_has_resize_grip(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_statusbar_set_has_resize_grip(Handle, value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void TextPushedVMDelegate (IntPtr statusbar, uint context_id, IntPtr text);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_statusbar_override_text_pushed (IntPtr gtype, TextPushedVMDelegate cb);

		static TextPushedVMDelegate TextPushedVMCallback;

		static void textpushed_cb (IntPtr statusbar, uint context_id, IntPtr text)
		{
			try {
				Statusbar statusbar_managed = GLib.Object.GetObject (statusbar, false) as Statusbar;
				statusbar_managed.OnTextPushed (context_id, GLib.Marshaller.Utf8PtrToString (text));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideTextPushed (GLib.GType gtype)
		{
			if (TextPushedVMCallback == null)
				TextPushedVMCallback = new TextPushedVMDelegate (textpushed_cb);
			gtksharp_statusbar_override_text_pushed (gtype.Val, TextPushedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_statusbar_base_text_pushed (IntPtr statusbar, uint context_id, IntPtr text);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Statusbar), ConnectionMethod="OverrideTextPushed")]
		protected virtual void OnTextPushed (uint context_id, string text)
		{
			Gtk.Application.AssertMainThread();
			IntPtr native_text = GLib.Marshaller.StringToPtrGStrdup (text);
			gtksharp_statusbar_base_text_pushed (Handle, context_id, native_text);
			GLib.Marshaller.Free (native_text);
		}

		[GLib.Signal("text_pushed")]
		public event Gtk.TextPushedHandler TextPushed {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "text_pushed", typeof (Gtk.TextPushedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "text_pushed", typeof (Gtk.TextPushedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void TextPoppedVMDelegate (IntPtr statusbar, uint context_id, IntPtr text);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_statusbar_override_text_popped (IntPtr gtype, TextPoppedVMDelegate cb);

		static TextPoppedVMDelegate TextPoppedVMCallback;

		static void textpopped_cb (IntPtr statusbar, uint context_id, IntPtr text)
		{
			try {
				Statusbar statusbar_managed = GLib.Object.GetObject (statusbar, false) as Statusbar;
				statusbar_managed.OnTextPopped (context_id, GLib.Marshaller.Utf8PtrToString (text));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideTextPopped (GLib.GType gtype)
		{
			if (TextPoppedVMCallback == null)
				TextPoppedVMCallback = new TextPoppedVMDelegate (textpopped_cb);
			gtksharp_statusbar_override_text_popped (gtype.Val, TextPoppedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_statusbar_base_text_popped (IntPtr statusbar, uint context_id, IntPtr text);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Statusbar), ConnectionMethod="OverrideTextPopped")]
		protected virtual void OnTextPopped (uint context_id, string text)
		{
			Gtk.Application.AssertMainThread();
			IntPtr native_text = GLib.Marshaller.StringToPtrGStrdup (text);
			gtksharp_statusbar_base_text_popped (Handle, context_id, native_text);
			GLib.Marshaller.Free (native_text);
		}

		[GLib.Signal("text_popped")]
		public event Gtk.TextPoppedHandler TextPopped {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "text_popped", typeof (Gtk.TextPoppedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "text_popped", typeof (Gtk.TextPoppedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern uint gtk_statusbar_get_context_id(IntPtr raw, IntPtr context_description);

		public uint GetContextId(string context_description) {
			Gtk.Application.AssertMainThread();
			IntPtr native_context_description = GLib.Marshaller.StringToPtrGStrdup (context_description);
			uint raw_ret = gtk_statusbar_get_context_id(Handle, native_context_description);
			uint ret = raw_ret;
			GLib.Marshaller.Free (native_context_description);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_statusbar_get_type();

		static GLib.GType _gtype = new GLib.GType (gtk_statusbar_get_type());
		public static new GLib.GType GType { 
			get {
								return _gtype;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_statusbar_pop(IntPtr raw, uint context_id);

		public void Pop(uint context_id) {
			Gtk.Application.AssertMainThread();
			gtk_statusbar_pop(Handle, context_id);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern uint gtk_statusbar_push(IntPtr raw, uint context_id, IntPtr text);

		public uint Push(uint context_id, string text) {
			Gtk.Application.AssertMainThread();
			IntPtr native_text = GLib.Marshaller.StringToPtrGStrdup (text);
			uint raw_ret = gtk_statusbar_push(Handle, context_id, native_text);
			uint ret = raw_ret;
			GLib.Marshaller.Free (native_text);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_statusbar_remove(IntPtr raw, uint context_id, uint message_id);

		public void Remove(uint context_id, uint message_id) {
			Gtk.Application.AssertMainThread();
			gtk_statusbar_remove(Handle, context_id, message_id);
		}

#endregion
	}

	internal class StatusbarAttribute : GLib.GTypeTypeAttribute {
		[DllImport ("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_statusbar_get_type ();

		private static GLib.GType _gtype = new GLib.GType (gtk_statusbar_get_type ());
		public static GLib.GType GType { get { return _gtype; } }
		public override GLib.GType Type { get { return _gtype; } }

	}
}
