// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gtk {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	[Menu]
	public class Menu : Gtk.MenuShell {

		[Obsolete]
		protected Menu(GLib.GType gtype) : base(gtype) {}
		public Menu(IntPtr raw) : base(raw) {}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_menu_new();

		public Menu () : base (IntPtr.Zero)
		{
			if (GetType () != typeof (Menu)) {
				Gtk.Application.AssertMainThread();
				CreateNativeObject (Array.Empty<IntPtr> (), Array.Empty<GLib.Value> (), 0);
				return;
			}
			owned = true;
			Raw = gtk_menu_new();
		}

		[GLib.Property ("tearoff-title")]
		public string TearoffTitle {
			get {
				using (GLib.Value val = GetProperty ("tearoff-title")) {
					string ret = (string) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("tearoff-title", val);
				}
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_menu_get_tearoff_state(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_menu_set_tearoff_state(IntPtr raw, bool torn_off);

		[GLib.Property ("tearoff-state")]
		public bool TearoffState {
			get  {
				bool raw_ret = gtk_menu_get_tearoff_state(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_menu_set_tearoff_state(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_menu_get_accel_group(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_menu_set_accel_group(IntPtr raw, IntPtr accel_group);

		public Gtk.AccelGroup AccelGroup {
			get  {
				IntPtr raw_ret = gtk_menu_get_accel_group(Handle);
				Gtk.AccelGroup ret = GLib.Object.GetObject(raw_ret) as Gtk.AccelGroup;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_menu_set_accel_group(Handle, value == null ? IntPtr.Zero : value.Handle);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_menu_set_accel_path(IntPtr raw, IntPtr accel_path);

		public string AccelPath {
			set  {
				Gtk.Application.AssertMainThread();
				IntPtr native_value = GLib.Marshaller.StringToPtrGStrdup (value);
				gtk_menu_set_accel_path(Handle, native_value);
				GLib.Marshaller.Free (native_value);
			}
		}

		public class MenuChild : Gtk.Container.ContainerChild {
			protected internal MenuChild (Gtk.Container parent, Gtk.Widget child) : base (parent, child) {}

			[Gtk.ChildProperty ("left-attach")]
			public int LeftAttach {
				get {
					using (GLib.Value val = parent.ChildGetProperty (child, "left-attach")) {
						int ret = (int) val;
						return ret;
					}
				}
				set {
					using (GLib.Value val = new GLib.Value(value)) {
						parent.ChildSetProperty(child, "left-attach", val);
					}
				}
			}

			[Gtk.ChildProperty ("right-attach")]
			public int RightAttach {
				get {
					using (GLib.Value val = parent.ChildGetProperty (child, "right-attach")) {
						int ret = (int) val;
						return ret;
					}
				}
				set {
					using (GLib.Value val = new GLib.Value(value)) {
						parent.ChildSetProperty(child, "right-attach", val);
					}
				}
			}

			[Gtk.ChildProperty ("top-attach")]
			public int TopAttach {
				get {
					using (GLib.Value val = parent.ChildGetProperty (child, "top-attach")) {
						int ret = (int) val;
						return ret;
					}
				}
				set {
					using (GLib.Value val = new GLib.Value(value)) {
						parent.ChildSetProperty(child, "top-attach", val);
					}
				}
			}

			[Gtk.ChildProperty ("bottom-attach")]
			public int BottomAttach {
				get {
					using (GLib.Value val = parent.ChildGetProperty (child, "bottom-attach")) {
						int ret = (int) val;
						return ret;
					}
				}
				set {
					using (GLib.Value val = new GLib.Value(value)) {
						parent.ChildSetProperty(child, "bottom-attach", val);
					}
				}
			}

		}

		public override Gtk.Container.ContainerChild this [Gtk.Widget child] {
			get {
				return new MenuChild (this, child);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ScrollMovedVMDelegate (IntPtr inst, int p0);

		static ScrollMovedVMDelegate ScrollMovedVMCallback;

		static void scrollmoved_cb (IntPtr inst, int p0)
		{
			try {
				Menu inst_managed = GLib.Object.GetObject (inst, false) as Menu;
				inst_managed.OnScrollMoved ((Gtk.ScrollType) p0);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideScrollMoved (GLib.GType gtype)
		{
			if (ScrollMovedVMCallback == null)
				ScrollMovedVMCallback = new ScrollMovedVMDelegate (scrollmoved_cb);
			OverrideVirtualMethod (gtype, "move_scroll", ScrollMovedVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Menu), ConnectionMethod="OverrideScrollMoved")]
		protected virtual void OnScrollMoved (Gtk.ScrollType p0)
		{
			GLib.Value ret = GLib.Value.Empty;
			unsafe {
				GLib.Value* inst_and_params = stackalloc GLib.Value [2];
				using (inst_and_params[0] = new GLib.Value (this)) {
					using (inst_and_params [1] = new GLib.Value (p0)) {
						g_signal_chain_from_overridden (inst_and_params, ref ret);
					}
				}
			}
		}

		[GLib.Signal("move_scroll")]
		public event Gtk.ScrollMovedHandler ScrollMoved {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "move_scroll", typeof (Gtk.ScrollMovedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "move_scroll", typeof (Gtk.ScrollMovedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_menu_attach(IntPtr raw, IntPtr child, uint left_attach, uint right_attach, uint top_attach, uint bottom_attach);

		public void Attach(Gtk.Widget child, uint left_attach, uint right_attach, uint top_attach, uint bottom_attach) {
			Gtk.Application.AssertMainThread();
			gtk_menu_attach(Handle, child == null ? IntPtr.Zero : child.Handle, left_attach, right_attach, top_attach, bottom_attach);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_menu_attach_to_widget(IntPtr raw, IntPtr attach_widget, GtkSharp.MenuDetachFuncNative detacher);

		public void AttachToWidget(Gtk.Widget attach_widget, Gtk.MenuDetachFunc detacher) {
			Gtk.Application.AssertMainThread();
			GtkSharp.MenuDetachFuncWrapper detacher_wrapper = new GtkSharp.MenuDetachFuncWrapper (detacher);
detacher_wrapper.PersistUntilCalled ();
			gtk_menu_attach_to_widget(Handle, attach_widget == null ? IntPtr.Zero : attach_widget.Handle, detacher_wrapper.NativeDelegate);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_menu_detach(IntPtr raw);

		public void Detach() {
			gtk_menu_detach(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_menu_get_active(IntPtr raw);

		public Gtk.Widget Active { 
			get {
				IntPtr raw_ret = gtk_menu_get_active(Handle);
				Gtk.Widget ret = GLib.Object.GetObject(raw_ret) as Gtk.Widget;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_menu_get_attach_widget(IntPtr raw);

		public Gtk.Widget AttachWidget { 
			get {
				IntPtr raw_ret = gtk_menu_get_attach_widget(Handle);
				Gtk.Widget ret = GLib.Object.GetObject(raw_ret) as Gtk.Widget;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_menu_get_for_attach_widget(IntPtr widget);

		public static GLib.List GetForAttachWidget(Gtk.Widget widget) {
			Gtk.Application.AssertMainThread();
			IntPtr raw_ret = gtk_menu_get_for_attach_widget(widget == null ? IntPtr.Zero : widget.Handle);
			GLib.List ret = new GLib.List(raw_ret);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_menu_get_title(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_menu_set_title(IntPtr raw, IntPtr title);

		public string Title { 
			get {
				IntPtr raw_ret = gtk_menu_get_title(Handle);
				string ret = GLib.Marshaller.Utf8PtrToString (raw_ret);
				return ret;
			}
			set {
				Gtk.Application.AssertMainThread();
				IntPtr native_value = GLib.Marshaller.StringToPtrGStrdup (value);
				gtk_menu_set_title(Handle, native_value);
				GLib.Marshaller.Free (native_value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_menu_get_type();

		static GLib.GType _gtype = new GLib.GType (gtk_menu_get_type());
		public static new GLib.GType GType { 
			get {
								return _gtype;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_menu_popdown(IntPtr raw);

		public void Popdown() {
			gtk_menu_popdown(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_menu_popup(IntPtr raw, IntPtr parent_menu_shell, IntPtr parent_menu_item, GtkSharp.MenuPositionFuncNative func, IntPtr data, uint button, uint activate_time);

		public void Popup(Gtk.Widget parent_menu_shell, Gtk.Widget parent_menu_item, Gtk.MenuPositionFunc func, uint button, uint activate_time) {
			Gtk.Application.AssertMainThread();
			IntPtr gch = IntPtr.Zero;
			if (func != null) {
				gch = (IntPtr)GCHandle.Alloc (func);
			}
			gtk_menu_popup(Handle, parent_menu_shell == null ? IntPtr.Zero : parent_menu_shell.Handle, parent_menu_item == null ? IntPtr.Zero : parent_menu_item.Handle, (func == null) ? null : GtkSharp.MenuPositionFuncWrapper.NativeDelegate, (IntPtr)gch, button, activate_time);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_menu_reorder_child(IntPtr raw, IntPtr child, int position);

		public void ReorderChild(Gtk.Widget child, int position) {
			Gtk.Application.AssertMainThread();
			gtk_menu_reorder_child(Handle, child == null ? IntPtr.Zero : child.Handle, position);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_menu_reposition(IntPtr raw);

		public void Reposition() {
			gtk_menu_reposition(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_menu_set_active(IntPtr raw, uint index_);

		public void SetActive(uint index_) {
			Gtk.Application.AssertMainThread();
			gtk_menu_set_active(Handle, index_);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_menu_set_monitor(IntPtr raw, int monitor_num);

		public int Monitor { 
			set {
				Gtk.Application.AssertMainThread();
				gtk_menu_set_monitor(Handle, value);
			}
		}

#endregion
#region Customized extensions
#line 1 "Menu.custom"
// Gtk.Menu.custom - Gtk Menu class customizations
//
// Author: John Luke <john.luke@gmail.com> 
//
// Copyright (C) 2004 John Luke
//
// This code is inserted after the automatically generated code.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of version 2 of the Lesser GNU General 
// Public License as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this program; if not, write to the
// Free Software Foundation, Inc., 59 Temple Place - Suite 330,
// Boston, MA 02111-1307, USA.

	[Obsolete("Replaced by overload without IntPtr argument")]
	public void Popup (Gtk.Widget parent_menu_shell, Gtk.Widget parent_menu_item, Gtk.MenuPositionFunc func, IntPtr data, uint button, uint activate_time) {
		Popup (parent_menu_shell, parent_menu_item, func, button, activate_time);
	}

	public void Popup ()
	{
		Popup (null, null, null, 3, Global.CurrentEventTime);
	}

	[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
	static extern void gtk_menu_set_screen (IntPtr raw, IntPtr screen);

	public new Gdk.Screen Screen {
		get {
			return base.Screen;
		}
		set {
			gtk_menu_set_screen (Handle, value.Handle);
		}
	}


#endregion
	}

	internal class MenuAttribute : GLib.GTypeTypeAttribute {
		[DllImport ("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_menu_get_type ();

		private static GLib.GType _gtype = new GLib.GType (gtk_menu_get_type ());
		public static GLib.GType GType { get { return _gtype; } }
		public override GLib.GType Type { get { return _gtype; } }

	}
}
