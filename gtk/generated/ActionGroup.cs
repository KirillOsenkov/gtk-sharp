// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gtk {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	[ActionGroup]
	public class ActionGroup : GLib.Object {

		[Obsolete]
		protected ActionGroup(GLib.GType gtype) : base(gtype) {}
		public ActionGroup(IntPtr raw) : base(raw) {}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_action_group_new(IntPtr name);

		public ActionGroup (string name) : base (IntPtr.Zero)
		{
			if (GetType () != typeof (ActionGroup)) {
				Gtk.Application.AssertMainThread();
				unsafe {
					var vals = stackalloc GLib.Value[1];
					var names = stackalloc IntPtr[1];
					names[0] = GLib.Marshaller.StringToPtrGStrdup ("name");
					vals[0] = new GLib.Value (name);
					CreateNativeObject (names, vals, 1);
				}
				return;
			}
			Gtk.Application.AssertMainThread();
			IntPtr native_name = GLib.Marshaller.StringToPtrGStrdup (name);
			owned = true;
			Raw = gtk_action_group_new(native_name);
			GLib.Marshaller.Free (native_name);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_action_group_get_name(IntPtr raw);

		[GLib.Property ("name")]
		public string Name {
			get  {
				IntPtr raw_ret = gtk_action_group_get_name(Handle);
				string ret = GLib.Marshaller.Utf8PtrToString (raw_ret);
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_action_group_get_sensitive(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_action_group_set_sensitive(IntPtr raw, bool sensitive);

		[GLib.Property ("sensitive")]
		public bool Sensitive {
			get  {
				bool raw_ret = gtk_action_group_get_sensitive(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_action_group_set_sensitive(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_action_group_get_visible(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_action_group_set_visible(IntPtr raw, bool visible);

		[GLib.Property ("visible")]
		public bool Visible {
			get  {
				bool raw_ret = gtk_action_group_get_visible(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_action_group_set_visible(Handle, value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ConnectProxyVMDelegate (IntPtr action_group, IntPtr action, IntPtr proxy);

		static ConnectProxyVMDelegate ConnectProxyVMCallback;

		static void connectproxy_cb (IntPtr action_group, IntPtr action, IntPtr proxy)
		{
			try {
				ActionGroup action_group_managed = GLib.Object.GetObject (action_group, false) as ActionGroup;
				action_group_managed.OnConnectProxy (GLib.Object.GetObject(action) as Gtk.Action, GLib.Object.GetObject(proxy) as Gtk.Widget);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideConnectProxy (GLib.GType gtype)
		{
			if (ConnectProxyVMCallback == null)
				ConnectProxyVMCallback = new ConnectProxyVMDelegate (connectproxy_cb);
			OverrideVirtualMethod (gtype, "connect_proxy", ConnectProxyVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.ActionGroup), ConnectionMethod="OverrideConnectProxy")]
		protected virtual void OnConnectProxy (Gtk.Action action, Gtk.Widget proxy)
		{
			GLib.Value ret = GLib.Value.Empty;
			unsafe {
				GLib.Value* inst_and_params = stackalloc GLib.Value [3];
				using (inst_and_params[0] = new GLib.Value (this)) {
					using (inst_and_params [1] = new GLib.Value (action)) {
						using (inst_and_params [2] = new GLib.Value (proxy)) {
							g_signal_chain_from_overridden (inst_and_params, ref ret);
						}
					}
				}
			}
		}

		[GLib.Signal("connect_proxy")]
		public event Gtk.ConnectProxyHandler ConnectProxy {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "connect_proxy", typeof (Gtk.ConnectProxyArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "connect_proxy", typeof (Gtk.ConnectProxyArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DisconnectProxyVMDelegate (IntPtr action_group, IntPtr action, IntPtr proxy);

		static DisconnectProxyVMDelegate DisconnectProxyVMCallback;

		static void disconnectproxy_cb (IntPtr action_group, IntPtr action, IntPtr proxy)
		{
			try {
				ActionGroup action_group_managed = GLib.Object.GetObject (action_group, false) as ActionGroup;
				action_group_managed.OnDisconnectProxy (GLib.Object.GetObject(action) as Gtk.Action, GLib.Object.GetObject(proxy) as Gtk.Widget);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideDisconnectProxy (GLib.GType gtype)
		{
			if (DisconnectProxyVMCallback == null)
				DisconnectProxyVMCallback = new DisconnectProxyVMDelegate (disconnectproxy_cb);
			OverrideVirtualMethod (gtype, "disconnect_proxy", DisconnectProxyVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.ActionGroup), ConnectionMethod="OverrideDisconnectProxy")]
		protected virtual void OnDisconnectProxy (Gtk.Action action, Gtk.Widget proxy)
		{
			GLib.Value ret = GLib.Value.Empty;
			unsafe {
				GLib.Value* inst_and_params = stackalloc GLib.Value [3];
				using (inst_and_params[0] = new GLib.Value (this)) {
					using (inst_and_params [1] = new GLib.Value (action)) {
						using (inst_and_params [2] = new GLib.Value (proxy)) {
							g_signal_chain_from_overridden (inst_and_params, ref ret);
						}
					}
				}
			}
		}

		[GLib.Signal("disconnect_proxy")]
		public event Gtk.DisconnectProxyHandler DisconnectProxy {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "disconnect_proxy", typeof (Gtk.DisconnectProxyArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "disconnect_proxy", typeof (Gtk.DisconnectProxyArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void PreActivateVMDelegate (IntPtr action_group, IntPtr action);

		static PreActivateVMDelegate PreActivateVMCallback;

		static void preactivate_cb (IntPtr action_group, IntPtr action)
		{
			try {
				ActionGroup action_group_managed = GLib.Object.GetObject (action_group, false) as ActionGroup;
				action_group_managed.OnPreActivate (GLib.Object.GetObject(action) as Gtk.Action);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverridePreActivate (GLib.GType gtype)
		{
			if (PreActivateVMCallback == null)
				PreActivateVMCallback = new PreActivateVMDelegate (preactivate_cb);
			OverrideVirtualMethod (gtype, "pre_activate", PreActivateVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.ActionGroup), ConnectionMethod="OverridePreActivate")]
		protected virtual void OnPreActivate (Gtk.Action action)
		{
			GLib.Value ret = GLib.Value.Empty;
			unsafe {
				GLib.Value* inst_and_params = stackalloc GLib.Value [2];
				using (inst_and_params[0] = new GLib.Value (this)) {
					using (inst_and_params [1] = new GLib.Value (action)) {
						g_signal_chain_from_overridden (inst_and_params, ref ret);
					}
				}
			}
		}

		[GLib.Signal("pre_activate")]
		public event Gtk.PreActivateHandler PreActivate {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "pre_activate", typeof (Gtk.PreActivateArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "pre_activate", typeof (Gtk.PreActivateArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void PostActivateVMDelegate (IntPtr action_group, IntPtr action);

		static PostActivateVMDelegate PostActivateVMCallback;

		static void postactivate_cb (IntPtr action_group, IntPtr action)
		{
			try {
				ActionGroup action_group_managed = GLib.Object.GetObject (action_group, false) as ActionGroup;
				action_group_managed.OnPostActivate (GLib.Object.GetObject(action) as Gtk.Action);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverridePostActivate (GLib.GType gtype)
		{
			if (PostActivateVMCallback == null)
				PostActivateVMCallback = new PostActivateVMDelegate (postactivate_cb);
			OverrideVirtualMethod (gtype, "post_activate", PostActivateVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.ActionGroup), ConnectionMethod="OverridePostActivate")]
		protected virtual void OnPostActivate (Gtk.Action action)
		{
			GLib.Value ret = GLib.Value.Empty;
			unsafe {
				GLib.Value* inst_and_params = stackalloc GLib.Value [2];
				using (inst_and_params[0] = new GLib.Value (this)) {
					using (inst_and_params [1] = new GLib.Value (action)) {
						g_signal_chain_from_overridden (inst_and_params, ref ret);
					}
				}
			}
		}

		[GLib.Signal("post_activate")]
		public event Gtk.PostActivateHandler PostActivate {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "post_activate", typeof (Gtk.PostActivateArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "post_activate", typeof (Gtk.PostActivateArgs));
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_action_group_add_action(IntPtr raw, IntPtr action);

		public void Add(Gtk.Action action) {
			Gtk.Application.AssertMainThread();
			gtk_action_group_add_action(Handle, action == null ? IntPtr.Zero : action.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_action_group_add_action_with_accel(IntPtr raw, IntPtr action, IntPtr accelerator);

		public void Add(Gtk.Action action, string accelerator) {
			Gtk.Application.AssertMainThread();
			IntPtr native_accelerator = GLib.Marshaller.StringToPtrGStrdup (accelerator);
			gtk_action_group_add_action_with_accel(Handle, action == null ? IntPtr.Zero : action.Handle, native_accelerator);
			GLib.Marshaller.Free (native_accelerator);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_action_group_get_action(IntPtr raw, IntPtr action_name);

		public Gtk.Action GetAction(string action_name) {
			Gtk.Application.AssertMainThread();
			IntPtr native_action_name = GLib.Marshaller.StringToPtrGStrdup (action_name);
			IntPtr raw_ret = gtk_action_group_get_action(Handle, native_action_name);
			Gtk.Action ret = GLib.Object.GetObject(raw_ret) as Gtk.Action;
			GLib.Marshaller.Free (native_action_name);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_action_group_get_type();

		static GLib.GType _gtype = new GLib.GType (gtk_action_group_get_type());
		public static new GLib.GType GType { 
			get {
								return _gtype;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_action_group_remove_action(IntPtr raw, IntPtr action);

		public void Remove(Gtk.Action action) {
			Gtk.Application.AssertMainThread();
			gtk_action_group_remove_action(Handle, action == null ? IntPtr.Zero : action.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_action_group_set_translate_func(IntPtr raw, GtkSharp.TranslateFuncNative func, IntPtr data, GLib.DestroyNotify notify);

		public Gtk.TranslateFunc TranslateFunc { 
			set {
				Gtk.Application.AssertMainThread();
				IntPtr data;
				GLib.DestroyNotify notify;
				if (value == null) {
					data = IntPtr.Zero;
					notify = null;
				} else {
					data = (IntPtr) GCHandle.Alloc (value);
					notify = GLib.DestroyHelper.NotifyHandler;
				}
				gtk_action_group_set_translate_func(Handle, (value == null) ? null : GtkSharp.TranslateFuncWrapper.NativeDelegate, data, notify);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_action_group_set_translation_domain(IntPtr raw, IntPtr domain);

		public string TranslationDomain { 
			set {
				Gtk.Application.AssertMainThread();
				IntPtr native_value = GLib.Marshaller.StringToPtrGStrdup (value);
				gtk_action_group_set_translation_domain(Handle, native_value);
				GLib.Marshaller.Free (native_value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_action_group_translate_string(IntPtr raw, IntPtr str1ng);

		public string TranslateString(string str1ng) {
			Gtk.Application.AssertMainThread();
			IntPtr native_str1ng = GLib.Marshaller.StringToPtrGStrdup (str1ng);
			IntPtr raw_ret = gtk_action_group_translate_string(Handle, native_str1ng);
			string ret = GLib.Marshaller.Utf8PtrToString (raw_ret);
			GLib.Marshaller.Free (native_str1ng);
			return ret;
		}

#endregion
#region Customized extensions
#line 1 "ActionGroup.custom"
// ActionGroup.custom - Syntactic C# sugar for easily defining Actions.
//
// Authors:  Jeroen Zwartepoorte  <jeroen@xs4all.nl>
//
// Copyright (c) 2004 Jeroen Zwartepoorte
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of version 2 of the Lesser GNU General 
// Public License as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this program; if not, write to the
// Free Software Foundation, Inc., 59 Temple Place - Suite 330,
// Boston, MA 02111-1307, USA.

		public Action this[string name] {
			get {
				return GetAction (name);
			}
		}

		public void Add (ActionEntry[] entries)
		{
			foreach (ActionEntry entry in entries) {
				Action action = new Action (entry.name, entry.label, entry.tooltip, entry.stock_id);
				if (entry.activated != null)
					action.Activated += entry.activated;
				if (entry.accelerator == null)
					Add (action);
				else
					Add (action, entry.accelerator);
			}
		}

		public void Add (ToggleActionEntry[] entries)
		{
			foreach (ToggleActionEntry entry in entries) {
				ToggleAction action = new ToggleAction (entry.name, entry.label, entry.tooltip, entry.stock_id);
				action.Active = entry.active;
				if (entry.activated != null)
					action.Activated += entry.activated;
				if (entry.accelerator == null)
					Add (action);
				else
					Add (action, entry.accelerator);
			}
		}

		public void Add (RadioActionEntry[] entries, int value, ChangedHandler changed)
		{
			GLib.SList group = new GLib.SList (typeof (RadioAction));
			RadioAction[] actions = new RadioAction[entries.Length];
			for (int i = 0; i < entries.Length; i++) {
				actions[i] = new RadioAction (entries[i].name, entries[i].label,
							      entries[i].tooltip, entries[i].stock_id, entries[i].value);
				actions[i].Group = group;
				group = actions[i].Group;
				actions[i].Active = value == entries[i].value;
				if (entries[i].accelerator == null)
					Add (actions[i]);
				else
					Add (actions[i], entries[i].accelerator);
			}

			// Add the ChangedHandler when we're done adding all the actions.
			// Otherwise, setting the Active property will trigger a premature event.
			if (changed != null)
				actions[0].Changed += changed;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
		static extern IntPtr gtk_action_group_list_actions (IntPtr raw);

		public Gtk.Action[] ListActions() {
			IntPtr raw_ret = gtk_action_group_list_actions (Handle);
			return GLib.Marshaller.ListPtrToArray<Gtk.Action> (raw_ret, typeof (GLib.List), true, false);
		}

#endregion
	}

	internal class ActionGroupAttribute : GLib.GTypeTypeAttribute {
		[DllImport ("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_action_group_get_type ();

		private static GLib.GType _gtype = new GLib.GType (gtk_action_group_get_type ());
		public static GLib.GType GType { get { return _gtype; } }
		public override GLib.GType Type { get { return _gtype; } }

	}
}
