// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gtk {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	[ColorSelection]
	public class ColorSelection : Gtk.VBox {

		[Obsolete]
		protected ColorSelection(GLib.GType gtype) : base(gtype) {}
		public ColorSelection(IntPtr raw) : base(raw) {}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_color_selection_new();

		public ColorSelection () : base (IntPtr.Zero)
		{
			if (GetType () != typeof (ColorSelection)) {
				Gtk.Application.AssertMainThread();
				CreateNativeObject (Array.Empty<IntPtr> (), Array.Empty<GLib.Value> (), 0);
				return;
			}
			owned = true;
			Raw = gtk_color_selection_new();
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_color_selection_get_has_opacity_control(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_color_selection_set_has_opacity_control(IntPtr raw, bool has_opacity);

		[GLib.Property ("has-opacity-control")]
		public bool HasOpacityControl {
			get  {
				bool raw_ret = gtk_color_selection_get_has_opacity_control(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_color_selection_set_has_opacity_control(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_color_selection_get_has_palette(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_color_selection_set_has_palette(IntPtr raw, bool has_palette);

		[GLib.Property ("has-palette")]
		public bool HasPalette {
			get  {
				bool raw_ret = gtk_color_selection_get_has_palette(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_color_selection_set_has_palette(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_color_selection_get_current_color(IntPtr raw, ref Gdk.Color color);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_color_selection_set_current_color(IntPtr raw, ref Gdk.Color value);

		[GLib.Property ("current-color")]
		public Gdk.Color CurrentColor {
			get  {
				Gdk.Color color;
				Gtk.Application.AssertMainThread();
				color = new Gdk.Color();
				gtk_color_selection_get_current_color(Handle, ref color);
				return color;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_color_selection_set_current_color(Handle, ref value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern ushort gtk_color_selection_get_current_alpha(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_color_selection_set_current_alpha(IntPtr raw, ushort alpha);

		[GLib.Property ("current-alpha")]
		public ushort CurrentAlpha {
			get  {
				ushort raw_ret = gtk_color_selection_get_current_alpha(Handle);
				ushort ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_color_selection_set_current_alpha(Handle, value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ColorChangedVMDelegate (IntPtr color_selection);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_colorselection_override_color_changed (IntPtr gtype, ColorChangedVMDelegate cb);

		static ColorChangedVMDelegate ColorChangedVMCallback;

		static void colorchanged_cb (IntPtr color_selection)
		{
			try {
				ColorSelection color_selection_managed = GLib.Object.GetObject (color_selection, false) as ColorSelection;
				color_selection_managed.OnColorChanged ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideColorChanged (GLib.GType gtype)
		{
			if (ColorChangedVMCallback == null)
				ColorChangedVMCallback = new ColorChangedVMDelegate (colorchanged_cb);
			gtksharp_colorselection_override_color_changed (gtype.Val, ColorChangedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_colorselection_base_color_changed (IntPtr color_selection);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.ColorSelection), ConnectionMethod="OverrideColorChanged")]
		protected virtual void OnColorChanged ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_colorselection_base_color_changed (Handle);
		}

		[GLib.Signal("color_changed")]
		public event System.EventHandler ColorChanged {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "color_changed");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "color_changed");
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern ushort gtk_color_selection_get_previous_alpha(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_color_selection_set_previous_alpha(IntPtr raw, ushort alpha);

		public ushort PreviousAlpha { 
			get {
				ushort raw_ret = gtk_color_selection_get_previous_alpha(Handle);
				ushort ret = raw_ret;
				return ret;
			}
			set {
				Gtk.Application.AssertMainThread();
				gtk_color_selection_set_previous_alpha(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_color_selection_get_type();

		static GLib.GType _gtype = new GLib.GType (gtk_color_selection_get_type());
		public static new GLib.GType GType { 
			get {
								return _gtype;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_color_selection_is_adjusting(IntPtr raw);

		public bool IsAdjusting { 
			get {
				bool raw_ret = gtk_color_selection_is_adjusting(Handle);
				bool ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_color_selection_set_update_policy(IntPtr raw, int policy);

		[Obsolete]
		public Gtk.UpdateType UpdatePolicy { 
			set {
				Gtk.Application.AssertMainThread();
				gtk_color_selection_set_update_policy(Handle, (int) value);
			}
		}

#endregion
#region Customized extensions
#line 1 "ColorSelection.custom"
// Gtk.ColorSelection.custom - customizations and corrections for ColorSelection
// Author: Lee Mallabone <gnome@fonicmonkey.net>
// Author: Justin Malcolm
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of version 2 of the Lesser GNU General 
// Public License as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this program; if not, write to the
// Free Software Foundation, Inc., 59 Temple Place - Suite 330,
// Boston, MA 02111-1307, USA.


		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
		static extern IntPtr gtk_color_selection_palette_to_string(Gdk.Color[] colors, int n_colors);

		/// <summary> PaletteToString Method </summary>
		public static string PaletteToString(Gdk.Color[] colors) {
			int n_colors = colors.Length;
			IntPtr raw_ret = gtk_color_selection_palette_to_string(colors, n_colors);
			string ret = GLib.Marshaller.PtrToStringGFree (raw_ret);
			return ret;
		}
		
		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
		static extern bool gtk_color_selection_palette_from_string(IntPtr str, out IntPtr colors, out int n_colors);

		public static Gdk.Color[] PaletteFromString(string str) {
			IntPtr parsedColors;
			int n_colors;
			IntPtr native = GLib.Marshaller.StringToPtrGStrdup (str);
			bool raw_ret = gtk_color_selection_palette_from_string(native, out parsedColors, out n_colors);
			GLib.Marshaller.Free (native);
			
			// If things failed, return silently
			if (!raw_ret)
			{
				return null;
			}
			Gdk.Color[] colors = new Gdk.Color[n_colors];
			int colorSize = 0;			
			unsafe {
				colorSize = sizeof(Gdk.Color);
			}
			for (int i=0; i < n_colors; i++)
			{
				colors[i] = Gdk.Color.New(parsedColors);
				parsedColors = (IntPtr) ((int)parsedColors + colorSize);
			}
			GLib.Marshaller.Free (parsedColors);
			return colors;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
		static extern void gtk_color_selection_set_previous_color(IntPtr raw, ref Gdk.Color color);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
		static extern void gtk_color_selection_get_previous_color(IntPtr raw, out Gdk.Color color);

		// Create Gtk# property to replace two Gtk+ functions
		public Gdk.Color PreviousColor
		{
			get
			{
				Gdk.Color returnColor;
				gtk_color_selection_get_previous_color(Handle, out returnColor);	
				return returnColor;
			}
			set
			{
				gtk_color_selection_set_previous_color(Handle, ref value);
			}
		}


#endregion
	}

	internal class ColorSelectionAttribute : GLib.GTypeTypeAttribute {
		[DllImport ("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_color_selection_get_type ();

		private static GLib.GType _gtype = new GLib.GType (gtk_color_selection_get_type ());
		public static GLib.GType GType { get { return _gtype; } }
		public override GLib.GType Type { get { return _gtype; } }

	}
}
