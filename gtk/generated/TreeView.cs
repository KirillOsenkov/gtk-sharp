// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gtk {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	[TreeView]
	public class TreeView : Gtk.Container {

		[Obsolete]
		protected TreeView(GLib.GType gtype) : base(gtype) {}
		public TreeView(IntPtr raw) : base(raw) {}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_tree_view_new();

		public TreeView () : base (IntPtr.Zero)
		{
			if (GetType () != typeof (TreeView)) {
				Gtk.Application.AssertMainThread();
				CreateNativeObject (Array.Empty<IntPtr> (), Array.Empty<GLib.Value> (), 0);
				return;
			}
			owned = true;
			Raw = gtk_tree_view_new();
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_tree_view_get_model(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_model(IntPtr raw, IntPtr model);

		[GLib.Property ("model")]
		public Gtk.TreeModel Model {
			get  {
				IntPtr raw_ret = gtk_tree_view_get_model(Handle);
				Gtk.TreeModel ret = Gtk.TreeModelAdapter.GetObject (raw_ret, false);
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_tree_view_set_model(Handle, value == null ? IntPtr.Zero : value.Handle);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_tree_view_get_hadjustment(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_hadjustment(IntPtr raw, IntPtr adjustment);

		[GLib.Property ("hadjustment")]
		public Gtk.Adjustment Hadjustment {
			get  {
				IntPtr raw_ret = gtk_tree_view_get_hadjustment(Handle);
				Gtk.Adjustment ret = GLib.Object.GetObject(raw_ret) as Gtk.Adjustment;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_tree_view_set_hadjustment(Handle, value == null ? IntPtr.Zero : value.Handle);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_tree_view_get_vadjustment(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_vadjustment(IntPtr raw, IntPtr adjustment);

		[GLib.Property ("vadjustment")]
		public Gtk.Adjustment Vadjustment {
			get  {
				IntPtr raw_ret = gtk_tree_view_get_vadjustment(Handle);
				Gtk.Adjustment ret = GLib.Object.GetObject(raw_ret) as Gtk.Adjustment;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_tree_view_set_vadjustment(Handle, value == null ? IntPtr.Zero : value.Handle);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_view_get_headers_visible(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_headers_visible(IntPtr raw, bool headers_visible);

		[GLib.Property ("headers-visible")]
		public bool HeadersVisible {
			get  {
				bool raw_ret = gtk_tree_view_get_headers_visible(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_tree_view_set_headers_visible(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_view_get_headers_clickable(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_headers_clickable(IntPtr raw, bool setting);

		[GLib.Property ("headers-clickable")]
		public bool HeadersClickable {
			get  {
				bool raw_ret = gtk_tree_view_get_headers_clickable(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_tree_view_set_headers_clickable(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_tree_view_get_expander_column(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_expander_column(IntPtr raw, IntPtr column);

		[GLib.Property ("expander-column")]
		public Gtk.TreeViewColumn ExpanderColumn {
			get  {
				IntPtr raw_ret = gtk_tree_view_get_expander_column(Handle);
				Gtk.TreeViewColumn ret = GLib.Object.GetObject(raw_ret) as Gtk.TreeViewColumn;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_tree_view_set_expander_column(Handle, value == null ? IntPtr.Zero : value.Handle);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_view_get_reorderable(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_reorderable(IntPtr raw, bool reorderable);

		[GLib.Property ("reorderable")]
		public bool Reorderable {
			get  {
				bool raw_ret = gtk_tree_view_get_reorderable(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_tree_view_set_reorderable(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_view_get_rules_hint(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_rules_hint(IntPtr raw, bool setting);

		[GLib.Property ("rules-hint")]
		public bool RulesHint {
			get  {
				bool raw_ret = gtk_tree_view_get_rules_hint(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_tree_view_set_rules_hint(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_view_get_enable_search(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_enable_search(IntPtr raw, bool enable_search);

		[GLib.Property ("enable-search")]
		public bool EnableSearch {
			get  {
				bool raw_ret = gtk_tree_view_get_enable_search(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_tree_view_set_enable_search(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_tree_view_get_search_column(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_search_column(IntPtr raw, int column);

		[GLib.Property ("search-column")]
		public int SearchColumn {
			get  {
				int raw_ret = gtk_tree_view_get_search_column(Handle);
				int ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_tree_view_set_search_column(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_view_get_fixed_height_mode(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_fixed_height_mode(IntPtr raw, bool enable);

		[GLib.Property ("fixed-height-mode")]
		public bool FixedHeightMode {
			get  {
				bool raw_ret = gtk_tree_view_get_fixed_height_mode(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_tree_view_set_fixed_height_mode(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_view_get_hover_selection(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_hover_selection(IntPtr raw, bool hover);

		[GLib.Property ("hover-selection")]
		public bool HoverSelection {
			get  {
				bool raw_ret = gtk_tree_view_get_hover_selection(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_tree_view_set_hover_selection(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_view_get_hover_expand(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_hover_expand(IntPtr raw, bool expand);

		[GLib.Property ("hover-expand")]
		public bool HoverExpand {
			get  {
				bool raw_ret = gtk_tree_view_get_hover_expand(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_tree_view_set_hover_expand(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_view_get_show_expanders(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_show_expanders(IntPtr raw, bool enabled);

		[GLib.Property ("show-expanders")]
		public bool ShowExpanders {
			get  {
				bool raw_ret = gtk_tree_view_get_show_expanders(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_tree_view_set_show_expanders(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_tree_view_get_level_indentation(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_level_indentation(IntPtr raw, int indentation);

		[GLib.Property ("level-indentation")]
		public int LevelIndentation {
			get  {
				int raw_ret = gtk_tree_view_get_level_indentation(Handle);
				int ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_tree_view_set_level_indentation(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_view_get_rubber_banding(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_rubber_banding(IntPtr raw, bool enable);

		[GLib.Property ("rubber-banding")]
		public bool RubberBanding {
			get  {
				bool raw_ret = gtk_tree_view_get_rubber_banding(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_tree_view_set_rubber_banding(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_tree_view_get_grid_lines(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_grid_lines(IntPtr raw, int grid_lines);

		[GLib.Property ("enable-grid-lines")]
		public Gtk.TreeViewGridLines EnableGridLines {
			get  {
				int raw_ret = gtk_tree_view_get_grid_lines(Handle);
				Gtk.TreeViewGridLines ret = (Gtk.TreeViewGridLines) raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_tree_view_set_grid_lines(Handle, (int) value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_view_get_enable_tree_lines(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_enable_tree_lines(IntPtr raw, bool enabled);

		[GLib.Property ("enable-tree-lines")]
		public bool EnableTreeLines {
			get  {
				bool raw_ret = gtk_tree_view_get_enable_tree_lines(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_tree_view_set_enable_tree_lines(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_tree_view_get_tooltip_column(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_tooltip_column(IntPtr raw, int column);

		[GLib.Property ("tooltip-column")]
		public int TooltipColumn {
			get  {
				int raw_ret = gtk_tree_view_get_tooltip_column(Handle);
				int ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_tree_view_set_tooltip_column(Handle, value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ScrollAdjustmentsSetVMDelegate (IntPtr tree_view, IntPtr hadjustment, IntPtr vadjustment);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_treeview_override_set_scroll_adjustments (IntPtr gtype, ScrollAdjustmentsSetVMDelegate cb);

		static ScrollAdjustmentsSetVMDelegate ScrollAdjustmentsSetVMCallback;

		static void scrolladjustmentsset_cb (IntPtr tree_view, IntPtr hadjustment, IntPtr vadjustment)
		{
			try {
				TreeView tree_view_managed = GLib.Object.GetObject (tree_view, false) as TreeView;
				tree_view_managed.OnScrollAdjustmentsSet (GLib.Object.GetObject(hadjustment) as Gtk.Adjustment, GLib.Object.GetObject(vadjustment) as Gtk.Adjustment);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideScrollAdjustmentsSet (GLib.GType gtype)
		{
			if (ScrollAdjustmentsSetVMCallback == null)
				ScrollAdjustmentsSetVMCallback = new ScrollAdjustmentsSetVMDelegate (scrolladjustmentsset_cb);
			gtksharp_treeview_override_set_scroll_adjustments (gtype.Val, ScrollAdjustmentsSetVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_treeview_base_set_scroll_adjustments (IntPtr tree_view, IntPtr hadjustment, IntPtr vadjustment);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TreeView), ConnectionMethod="OverrideScrollAdjustmentsSet")]
		protected virtual void OnScrollAdjustmentsSet (Gtk.Adjustment hadjustment, Gtk.Adjustment vadjustment)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_treeview_base_set_scroll_adjustments (Handle, hadjustment == null ? IntPtr.Zero : hadjustment.Handle, vadjustment == null ? IntPtr.Zero : vadjustment.Handle);
		}

		[GLib.Signal("set_scroll_adjustments")]
		public event Gtk.ScrollAdjustmentsSetHandler ScrollAdjustmentsSet {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "set_scroll_adjustments", typeof (Gtk.ScrollAdjustmentsSetArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "set_scroll_adjustments", typeof (Gtk.ScrollAdjustmentsSetArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void RowActivatedVMDelegate (IntPtr tree_view, IntPtr path, IntPtr column);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_treeview_override_row_activated (IntPtr gtype, RowActivatedVMDelegate cb);

		static RowActivatedVMDelegate RowActivatedVMCallback;

		static void rowactivated_cb (IntPtr tree_view, IntPtr path, IntPtr column)
		{
			try {
				TreeView tree_view_managed = GLib.Object.GetObject (tree_view, false) as TreeView;
				tree_view_managed.OnRowActivated (path == IntPtr.Zero ? null : (Gtk.TreePath) GLib.Opaque.GetOpaque (path, typeof (Gtk.TreePath), false), GLib.Object.GetObject(column) as Gtk.TreeViewColumn);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideRowActivated (GLib.GType gtype)
		{
			if (RowActivatedVMCallback == null)
				RowActivatedVMCallback = new RowActivatedVMDelegate (rowactivated_cb);
			gtksharp_treeview_override_row_activated (gtype.Val, RowActivatedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_treeview_base_row_activated (IntPtr tree_view, IntPtr path, IntPtr column);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TreeView), ConnectionMethod="OverrideRowActivated")]
		protected virtual void OnRowActivated (Gtk.TreePath path, Gtk.TreeViewColumn column)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_treeview_base_row_activated (Handle, path == null ? IntPtr.Zero : path.Handle, column == null ? IntPtr.Zero : column.Handle);
		}

		[GLib.Signal("row_activated")]
		public event Gtk.RowActivatedHandler RowActivated {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "row_activated", typeof (Gtk.RowActivatedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "row_activated", typeof (Gtk.RowActivatedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool TestExpandRowVMDelegate (IntPtr tree_view, IntPtr iter, IntPtr path);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_treeview_override_test_expand_row (IntPtr gtype, TestExpandRowVMDelegate cb);

		static TestExpandRowVMDelegate TestExpandRowVMCallback;

		static bool testexpandrow_cb (IntPtr tree_view, IntPtr iter, IntPtr path)
		{
			try {
				TreeView tree_view_managed = GLib.Object.GetObject (tree_view, false) as TreeView;
				return tree_view_managed.OnTestExpandRow (Gtk.TreeIter.New (iter), path == IntPtr.Zero ? null : (Gtk.TreePath) GLib.Opaque.GetOpaque (path, typeof (Gtk.TreePath), false));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideTestExpandRow (GLib.GType gtype)
		{
			if (TestExpandRowVMCallback == null)
				TestExpandRowVMCallback = new TestExpandRowVMDelegate (testexpandrow_cb);
			gtksharp_treeview_override_test_expand_row (gtype.Val, TestExpandRowVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_treeview_base_test_expand_row (IntPtr tree_view, ref Gtk.TreeIter iter, IntPtr path);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TreeView), ConnectionMethod="OverrideTestExpandRow")]
		protected virtual bool OnTestExpandRow (Gtk.TreeIter iter, Gtk.TreePath path)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_treeview_base_test_expand_row (Handle, ref iter, path == null ? IntPtr.Zero : path.Handle);
			return __ret;
		}

		[GLib.Signal("test-expand-row")]
		public event Gtk.TestExpandRowHandler TestExpandRow {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "test-expand-row", typeof (Gtk.TestExpandRowArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "test-expand-row", typeof (Gtk.TestExpandRowArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool TestCollapseRowVMDelegate (IntPtr tree_view, IntPtr iter, IntPtr path);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_treeview_override_test_collapse_row (IntPtr gtype, TestCollapseRowVMDelegate cb);

		static TestCollapseRowVMDelegate TestCollapseRowVMCallback;

		static bool testcollapserow_cb (IntPtr tree_view, IntPtr iter, IntPtr path)
		{
			try {
				TreeView tree_view_managed = GLib.Object.GetObject (tree_view, false) as TreeView;
				return tree_view_managed.OnTestCollapseRow (Gtk.TreeIter.New (iter), path == IntPtr.Zero ? null : (Gtk.TreePath) GLib.Opaque.GetOpaque (path, typeof (Gtk.TreePath), false));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideTestCollapseRow (GLib.GType gtype)
		{
			if (TestCollapseRowVMCallback == null)
				TestCollapseRowVMCallback = new TestCollapseRowVMDelegate (testcollapserow_cb);
			gtksharp_treeview_override_test_collapse_row (gtype.Val, TestCollapseRowVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_treeview_base_test_collapse_row (IntPtr tree_view, ref Gtk.TreeIter iter, IntPtr path);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TreeView), ConnectionMethod="OverrideTestCollapseRow")]
		protected virtual bool OnTestCollapseRow (Gtk.TreeIter iter, Gtk.TreePath path)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_treeview_base_test_collapse_row (Handle, ref iter, path == null ? IntPtr.Zero : path.Handle);
			return __ret;
		}

		[GLib.Signal("test-collapse-row")]
		public event Gtk.TestCollapseRowHandler TestCollapseRow {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "test-collapse-row", typeof (Gtk.TestCollapseRowArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "test-collapse-row", typeof (Gtk.TestCollapseRowArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void RowExpandedVMDelegate (IntPtr tree_view, IntPtr iter, IntPtr path);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_treeview_override_row_expanded (IntPtr gtype, RowExpandedVMDelegate cb);

		static RowExpandedVMDelegate RowExpandedVMCallback;

		static void rowexpanded_cb (IntPtr tree_view, IntPtr iter, IntPtr path)
		{
			try {
				TreeView tree_view_managed = GLib.Object.GetObject (tree_view, false) as TreeView;
				tree_view_managed.OnRowExpanded (Gtk.TreeIter.New (iter), path == IntPtr.Zero ? null : (Gtk.TreePath) GLib.Opaque.GetOpaque (path, typeof (Gtk.TreePath), false));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideRowExpanded (GLib.GType gtype)
		{
			if (RowExpandedVMCallback == null)
				RowExpandedVMCallback = new RowExpandedVMDelegate (rowexpanded_cb);
			gtksharp_treeview_override_row_expanded (gtype.Val, RowExpandedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_treeview_base_row_expanded (IntPtr tree_view, ref Gtk.TreeIter iter, IntPtr path);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TreeView), ConnectionMethod="OverrideRowExpanded")]
		protected virtual void OnRowExpanded (Gtk.TreeIter iter, Gtk.TreePath path)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_treeview_base_row_expanded (Handle, ref iter, path == null ? IntPtr.Zero : path.Handle);
		}

		[GLib.Signal("row-expanded")]
		public event Gtk.RowExpandedHandler RowExpanded {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "row-expanded", typeof (Gtk.RowExpandedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "row-expanded", typeof (Gtk.RowExpandedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void RowCollapsedVMDelegate (IntPtr tree_view, IntPtr iter, IntPtr path);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_treeview_override_row_collapsed (IntPtr gtype, RowCollapsedVMDelegate cb);

		static RowCollapsedVMDelegate RowCollapsedVMCallback;

		static void rowcollapsed_cb (IntPtr tree_view, IntPtr iter, IntPtr path)
		{
			try {
				TreeView tree_view_managed = GLib.Object.GetObject (tree_view, false) as TreeView;
				tree_view_managed.OnRowCollapsed (Gtk.TreeIter.New (iter), path == IntPtr.Zero ? null : (Gtk.TreePath) GLib.Opaque.GetOpaque (path, typeof (Gtk.TreePath), false));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideRowCollapsed (GLib.GType gtype)
		{
			if (RowCollapsedVMCallback == null)
				RowCollapsedVMCallback = new RowCollapsedVMDelegate (rowcollapsed_cb);
			gtksharp_treeview_override_row_collapsed (gtype.Val, RowCollapsedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_treeview_base_row_collapsed (IntPtr tree_view, ref Gtk.TreeIter iter, IntPtr path);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TreeView), ConnectionMethod="OverrideRowCollapsed")]
		protected virtual void OnRowCollapsed (Gtk.TreeIter iter, Gtk.TreePath path)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_treeview_base_row_collapsed (Handle, ref iter, path == null ? IntPtr.Zero : path.Handle);
		}

		[GLib.Signal("row-collapsed")]
		public event Gtk.RowCollapsedHandler RowCollapsed {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "row-collapsed", typeof (Gtk.RowCollapsedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "row-collapsed", typeof (Gtk.RowCollapsedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ColumnsChangedVMDelegate (IntPtr tree_view);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_treeview_override_columns_changed (IntPtr gtype, ColumnsChangedVMDelegate cb);

		static ColumnsChangedVMDelegate ColumnsChangedVMCallback;

		static void columnschanged_cb (IntPtr tree_view)
		{
			try {
				TreeView tree_view_managed = GLib.Object.GetObject (tree_view, false) as TreeView;
				tree_view_managed.OnColumnsChanged ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideColumnsChanged (GLib.GType gtype)
		{
			if (ColumnsChangedVMCallback == null)
				ColumnsChangedVMCallback = new ColumnsChangedVMDelegate (columnschanged_cb);
			gtksharp_treeview_override_columns_changed (gtype.Val, ColumnsChangedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_treeview_base_columns_changed (IntPtr tree_view);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TreeView), ConnectionMethod="OverrideColumnsChanged")]
		protected virtual void OnColumnsChanged ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_treeview_base_columns_changed (Handle);
		}

		[GLib.Signal("columns-changed")]
		public event System.EventHandler ColumnsChanged {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "columns-changed");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "columns-changed");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void CursorChangedVMDelegate (IntPtr tree_view);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_treeview_override_cursor_changed (IntPtr gtype, CursorChangedVMDelegate cb);

		static CursorChangedVMDelegate CursorChangedVMCallback;

		static void cursorchanged_cb (IntPtr tree_view)
		{
			try {
				TreeView tree_view_managed = GLib.Object.GetObject (tree_view, false) as TreeView;
				tree_view_managed.OnCursorChanged ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideCursorChanged (GLib.GType gtype)
		{
			if (CursorChangedVMCallback == null)
				CursorChangedVMCallback = new CursorChangedVMDelegate (cursorchanged_cb);
			gtksharp_treeview_override_cursor_changed (gtype.Val, CursorChangedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_treeview_base_cursor_changed (IntPtr tree_view);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TreeView), ConnectionMethod="OverrideCursorChanged")]
		protected virtual void OnCursorChanged ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_treeview_base_cursor_changed (Handle);
		}

		[GLib.Signal("cursor-changed")]
		public event System.EventHandler CursorChanged {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "cursor-changed");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "cursor-changed");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool MoveCursorVMDelegate (IntPtr tree_view, int step, int count);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_treeview_override_move_cursor (IntPtr gtype, MoveCursorVMDelegate cb);

		static MoveCursorVMDelegate MoveCursorVMCallback;

		static bool movecursor_cb (IntPtr tree_view, int step, int count)
		{
			try {
				TreeView tree_view_managed = GLib.Object.GetObject (tree_view, false) as TreeView;
				return tree_view_managed.OnMoveCursor ((Gtk.MovementStep) step, count);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideMoveCursor (GLib.GType gtype)
		{
			if (MoveCursorVMCallback == null)
				MoveCursorVMCallback = new MoveCursorVMDelegate (movecursor_cb);
			gtksharp_treeview_override_move_cursor (gtype.Val, MoveCursorVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_treeview_base_move_cursor (IntPtr tree_view, int step, int count);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TreeView), ConnectionMethod="OverrideMoveCursor")]
		protected virtual bool OnMoveCursor (Gtk.MovementStep step, int count)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_treeview_base_move_cursor (Handle, (int) step, count);
			return __ret;
		}

		[GLib.Signal("move_cursor")]
		public event Gtk.MoveCursorHandler MoveCursor {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "move_cursor", typeof (Gtk.MoveCursorArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "move_cursor", typeof (Gtk.MoveCursorArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool SelectAllVMDelegate (IntPtr tree_view);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_treeview_override_select_all (IntPtr gtype, SelectAllVMDelegate cb);

		static SelectAllVMDelegate SelectAllVMCallback;

		static bool selectall_cb (IntPtr tree_view)
		{
			try {
				TreeView tree_view_managed = GLib.Object.GetObject (tree_view, false) as TreeView;
				return tree_view_managed.OnSelectAll ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideSelectAll (GLib.GType gtype)
		{
			if (SelectAllVMCallback == null)
				SelectAllVMCallback = new SelectAllVMDelegate (selectall_cb);
			gtksharp_treeview_override_select_all (gtype.Val, SelectAllVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_treeview_base_select_all (IntPtr tree_view);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TreeView), ConnectionMethod="OverrideSelectAll")]
		protected virtual bool OnSelectAll ()
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_treeview_base_select_all (Handle);
			return __ret;
		}

		[GLib.Signal("select_all")]
		public event Gtk.SelectAllHandler SelectAll {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "select_all", typeof (Gtk.SelectAllArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "select_all", typeof (Gtk.SelectAllArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool UnselectAllVMDelegate (IntPtr tree_view);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_treeview_override_unselect_all (IntPtr gtype, UnselectAllVMDelegate cb);

		static UnselectAllVMDelegate UnselectAllVMCallback;

		static bool unselectall_cb (IntPtr tree_view)
		{
			try {
				TreeView tree_view_managed = GLib.Object.GetObject (tree_view, false) as TreeView;
				return tree_view_managed.OnUnselectAll ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideUnselectAll (GLib.GType gtype)
		{
			if (UnselectAllVMCallback == null)
				UnselectAllVMCallback = new UnselectAllVMDelegate (unselectall_cb);
			gtksharp_treeview_override_unselect_all (gtype.Val, UnselectAllVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_treeview_base_unselect_all (IntPtr tree_view);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TreeView), ConnectionMethod="OverrideUnselectAll")]
		protected virtual bool OnUnselectAll ()
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_treeview_base_unselect_all (Handle);
			return __ret;
		}

		[GLib.Signal("unselect_all")]
		public event Gtk.UnselectAllHandler UnselectAll {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "unselect_all", typeof (Gtk.UnselectAllArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "unselect_all", typeof (Gtk.UnselectAllArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool SelectCursorRowVMDelegate (IntPtr tree_view, bool start_editing);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_treeview_override_select_cursor_row (IntPtr gtype, SelectCursorRowVMDelegate cb);

		static SelectCursorRowVMDelegate SelectCursorRowVMCallback;

		static bool selectcursorrow_cb (IntPtr tree_view, bool start_editing)
		{
			try {
				TreeView tree_view_managed = GLib.Object.GetObject (tree_view, false) as TreeView;
				return tree_view_managed.OnSelectCursorRow (start_editing);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideSelectCursorRow (GLib.GType gtype)
		{
			if (SelectCursorRowVMCallback == null)
				SelectCursorRowVMCallback = new SelectCursorRowVMDelegate (selectcursorrow_cb);
			gtksharp_treeview_override_select_cursor_row (gtype.Val, SelectCursorRowVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_treeview_base_select_cursor_row (IntPtr tree_view, bool start_editing);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TreeView), ConnectionMethod="OverrideSelectCursorRow")]
		protected virtual bool OnSelectCursorRow (bool start_editing)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_treeview_base_select_cursor_row (Handle, start_editing);
			return __ret;
		}

		[GLib.Signal("select_cursor_row")]
		public event Gtk.SelectCursorRowHandler SelectCursorRow {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "select_cursor_row", typeof (Gtk.SelectCursorRowArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "select_cursor_row", typeof (Gtk.SelectCursorRowArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool ToggleCursorRowVMDelegate (IntPtr tree_view);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_treeview_override_toggle_cursor_row (IntPtr gtype, ToggleCursorRowVMDelegate cb);

		static ToggleCursorRowVMDelegate ToggleCursorRowVMCallback;

		static bool togglecursorrow_cb (IntPtr tree_view)
		{
			try {
				TreeView tree_view_managed = GLib.Object.GetObject (tree_view, false) as TreeView;
				return tree_view_managed.OnToggleCursorRow ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideToggleCursorRow (GLib.GType gtype)
		{
			if (ToggleCursorRowVMCallback == null)
				ToggleCursorRowVMCallback = new ToggleCursorRowVMDelegate (togglecursorrow_cb);
			gtksharp_treeview_override_toggle_cursor_row (gtype.Val, ToggleCursorRowVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_treeview_base_toggle_cursor_row (IntPtr tree_view);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TreeView), ConnectionMethod="OverrideToggleCursorRow")]
		protected virtual bool OnToggleCursorRow ()
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_treeview_base_toggle_cursor_row (Handle);
			return __ret;
		}

		[GLib.Signal("toggle_cursor_row")]
		public event Gtk.ToggleCursorRowHandler ToggleCursorRow {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "toggle_cursor_row", typeof (Gtk.ToggleCursorRowArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "toggle_cursor_row", typeof (Gtk.ToggleCursorRowArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool ExpandCollapseCursorRowVMDelegate (IntPtr tree_view, bool logical, bool expand, bool open_all);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_treeview_override_expand_collapse_cursor_row (IntPtr gtype, ExpandCollapseCursorRowVMDelegate cb);

		static ExpandCollapseCursorRowVMDelegate ExpandCollapseCursorRowVMCallback;

		static bool expandcollapsecursorrow_cb (IntPtr tree_view, bool logical, bool expand, bool open_all)
		{
			try {
				TreeView tree_view_managed = GLib.Object.GetObject (tree_view, false) as TreeView;
				return tree_view_managed.OnExpandCollapseCursorRow (logical, expand, open_all);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideExpandCollapseCursorRow (GLib.GType gtype)
		{
			if (ExpandCollapseCursorRowVMCallback == null)
				ExpandCollapseCursorRowVMCallback = new ExpandCollapseCursorRowVMDelegate (expandcollapsecursorrow_cb);
			gtksharp_treeview_override_expand_collapse_cursor_row (gtype.Val, ExpandCollapseCursorRowVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_treeview_base_expand_collapse_cursor_row (IntPtr tree_view, bool logical, bool expand, bool open_all);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TreeView), ConnectionMethod="OverrideExpandCollapseCursorRow")]
		protected virtual bool OnExpandCollapseCursorRow (bool logical, bool expand, bool open_all)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_treeview_base_expand_collapse_cursor_row (Handle, logical, expand, open_all);
			return __ret;
		}

		[GLib.Signal("expand_collapse_cursor_row")]
		public event Gtk.ExpandCollapseCursorRowHandler ExpandCollapseCursorRow {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "expand_collapse_cursor_row", typeof (Gtk.ExpandCollapseCursorRowArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "expand_collapse_cursor_row", typeof (Gtk.ExpandCollapseCursorRowArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool SelectCursorParentVMDelegate (IntPtr tree_view);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_treeview_override_select_cursor_parent (IntPtr gtype, SelectCursorParentVMDelegate cb);

		static SelectCursorParentVMDelegate SelectCursorParentVMCallback;

		static bool selectcursorparent_cb (IntPtr tree_view)
		{
			try {
				TreeView tree_view_managed = GLib.Object.GetObject (tree_view, false) as TreeView;
				return tree_view_managed.OnSelectCursorParent ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideSelectCursorParent (GLib.GType gtype)
		{
			if (SelectCursorParentVMCallback == null)
				SelectCursorParentVMCallback = new SelectCursorParentVMDelegate (selectcursorparent_cb);
			gtksharp_treeview_override_select_cursor_parent (gtype.Val, SelectCursorParentVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_treeview_base_select_cursor_parent (IntPtr tree_view);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TreeView), ConnectionMethod="OverrideSelectCursorParent")]
		protected virtual bool OnSelectCursorParent ()
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_treeview_base_select_cursor_parent (Handle);
			return __ret;
		}

		[GLib.Signal("select_cursor_parent")]
		public event Gtk.SelectCursorParentHandler SelectCursorParent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "select_cursor_parent", typeof (Gtk.SelectCursorParentArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "select_cursor_parent", typeof (Gtk.SelectCursorParentArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool StartInteractiveSearchVMDelegate (IntPtr tree_view);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_treeview_override_start_interactive_search (IntPtr gtype, StartInteractiveSearchVMDelegate cb);

		static StartInteractiveSearchVMDelegate StartInteractiveSearchVMCallback;

		static bool startinteractivesearch_cb (IntPtr tree_view)
		{
			try {
				TreeView tree_view_managed = GLib.Object.GetObject (tree_view, false) as TreeView;
				return tree_view_managed.OnStartInteractiveSearch ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideStartInteractiveSearch (GLib.GType gtype)
		{
			if (StartInteractiveSearchVMCallback == null)
				StartInteractiveSearchVMCallback = new StartInteractiveSearchVMDelegate (startinteractivesearch_cb);
			gtksharp_treeview_override_start_interactive_search (gtype.Val, StartInteractiveSearchVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_treeview_base_start_interactive_search (IntPtr tree_view);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TreeView), ConnectionMethod="OverrideStartInteractiveSearch")]
		protected virtual bool OnStartInteractiveSearch ()
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_treeview_base_start_interactive_search (Handle);
			return __ret;
		}

		[GLib.Signal("start_interactive_search")]
		public event Gtk.StartInteractiveSearchHandler StartInteractiveSearch {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "start_interactive_search", typeof (Gtk.StartInteractiveSearchArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "start_interactive_search", typeof (Gtk.StartInteractiveSearchArgs));
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_tree_view_append_column(IntPtr raw, IntPtr column);

		public int AppendColumn(Gtk.TreeViewColumn column) {
			Gtk.Application.AssertMainThread();
			int raw_ret = gtk_tree_view_append_column(Handle, column == null ? IntPtr.Zero : column.Handle);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_collapse_all(IntPtr raw);

		public void CollapseAll() {
			gtk_tree_view_collapse_all(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_view_collapse_row(IntPtr raw, IntPtr path);

		public bool CollapseRow(Gtk.TreePath path) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_tree_view_collapse_row(Handle, path == null ? IntPtr.Zero : path.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_columns_autosize(IntPtr raw);

		public void ColumnsAutosize() {
			gtk_tree_view_columns_autosize(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_convert_bin_window_to_tree_coords(IntPtr raw, int bx, int by, out int tx, out int ty);

		public void ConvertBinWindowToTreeCoords(int bx, int by, out int tx, out int ty) {
			Gtk.Application.AssertMainThread();
			gtk_tree_view_convert_bin_window_to_tree_coords(Handle, bx, by, out tx, out ty);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_convert_bin_window_to_widget_coords(IntPtr raw, int bx, int by, out int wx, out int wy);

		public void ConvertBinWindowToWidgetCoords(int bx, int by, out int wx, out int wy) {
			Gtk.Application.AssertMainThread();
			gtk_tree_view_convert_bin_window_to_widget_coords(Handle, bx, by, out wx, out wy);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_convert_tree_to_bin_window_coords(IntPtr raw, int tx, int ty, out int bx, out int by);

		public void ConvertTreeToBinWindowCoords(int tx, int ty, out int bx, out int by) {
			Gtk.Application.AssertMainThread();
			gtk_tree_view_convert_tree_to_bin_window_coords(Handle, tx, ty, out bx, out by);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_convert_tree_to_widget_coords(IntPtr raw, int tx, int ty, out int wx, out int wy);

		public void ConvertTreeToWidgetCoords(int tx, int ty, out int wx, out int wy) {
			Gtk.Application.AssertMainThread();
			gtk_tree_view_convert_tree_to_widget_coords(Handle, tx, ty, out wx, out wy);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_convert_widget_to_bin_window_coords(IntPtr raw, int wx, int wy, out int bx, out int by);

		public void ConvertWidgetToBinWindowCoords(int wx, int wy, out int bx, out int by) {
			Gtk.Application.AssertMainThread();
			gtk_tree_view_convert_widget_to_bin_window_coords(Handle, wx, wy, out bx, out by);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_convert_widget_to_tree_coords(IntPtr raw, int wx, int wy, out int tx, out int ty);

		public void ConvertWidgetToTreeCoords(int wx, int wy, out int tx, out int ty) {
			Gtk.Application.AssertMainThread();
			gtk_tree_view_convert_widget_to_tree_coords(Handle, wx, wy, out tx, out ty);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_tree_view_create_row_drag_icon(IntPtr raw, IntPtr path);

		public Gdk.Pixmap CreateRowDragIcon(Gtk.TreePath path) {
			Gtk.Application.AssertMainThread();
			IntPtr raw_ret = gtk_tree_view_create_row_drag_icon(Handle, path == null ? IntPtr.Zero : path.Handle);
			Gdk.Pixmap ret = GLib.Object.GetObject(raw_ret) as Gdk.Pixmap;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_enable_model_drag_dest(IntPtr raw, Gtk.TargetEntry[] targets, int n_targets, int actions);

		public void EnableModelDragDest(Gtk.TargetEntry[] targets, Gdk.DragAction actions) {
			Gtk.Application.AssertMainThread();
			gtk_tree_view_enable_model_drag_dest(Handle, targets, (targets == null ? 0 : targets.Length), (int) actions);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_enable_model_drag_source(IntPtr raw, int start_button_mask, Gtk.TargetEntry[] targets, int n_targets, int actions);

		public void EnableModelDragSource(Gdk.ModifierType start_button_mask, Gtk.TargetEntry[] targets, Gdk.DragAction actions) {
			Gtk.Application.AssertMainThread();
			gtk_tree_view_enable_model_drag_source(Handle, (int) start_button_mask, targets, (targets == null ? 0 : targets.Length), (int) actions);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_expand_all(IntPtr raw);

		public void ExpandAll() {
			gtk_tree_view_expand_all(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_view_expand_row(IntPtr raw, IntPtr path, bool open_all);

		public bool ExpandRow(Gtk.TreePath path, bool open_all) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_tree_view_expand_row(Handle, path == null ? IntPtr.Zero : path.Handle, open_all);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_expand_to_path(IntPtr raw, IntPtr path);

		public void ExpandToPath(Gtk.TreePath path) {
			Gtk.Application.AssertMainThread();
			gtk_tree_view_expand_to_path(Handle, path == null ? IntPtr.Zero : path.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_get_background_area(IntPtr raw, IntPtr path, IntPtr column, ref Gdk.Rectangle rect);

		public Gdk.Rectangle GetBackgroundArea(Gtk.TreePath path, Gtk.TreeViewColumn column) {
			Gdk.Rectangle rect;
			Gtk.Application.AssertMainThread();
			rect = new Gdk.Rectangle();
			gtk_tree_view_get_background_area(Handle, path == null ? IntPtr.Zero : path.Handle, column == null ? IntPtr.Zero : column.Handle, ref rect);
			return rect;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_tree_view_get_bin_window(IntPtr raw);

		public Gdk.Window BinWindow { 
			get {
				IntPtr raw_ret = gtk_tree_view_get_bin_window(Handle);
				Gdk.Window ret = GLib.Object.GetObject(raw_ret) as Gdk.Window;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_get_cell_area(IntPtr raw, IntPtr path, IntPtr column, ref Gdk.Rectangle rect);

		public Gdk.Rectangle GetCellArea(Gtk.TreePath path, Gtk.TreeViewColumn column) {
			Gdk.Rectangle rect;
			Gtk.Application.AssertMainThread();
			rect = new Gdk.Rectangle();
			gtk_tree_view_get_cell_area(Handle, path == null ? IntPtr.Zero : path.Handle, column == null ? IntPtr.Zero : column.Handle, ref rect);
			return rect;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_tree_view_get_column(IntPtr raw, int n);

		public Gtk.TreeViewColumn GetColumn(int n) {
			Gtk.Application.AssertMainThread();
			IntPtr raw_ret = gtk_tree_view_get_column(Handle, n);
			Gtk.TreeViewColumn ret = GLib.Object.GetObject(raw_ret) as Gtk.TreeViewColumn;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_tree_view_get_columns(IntPtr raw);

		public Gtk.TreeViewColumn[] Columns { 
			get {
				IntPtr raw_ret = gtk_tree_view_get_columns(Handle);
				Gtk.TreeViewColumn[] ret = GLib.Marshaller.ListPtrToArray<Gtk.TreeViewColumn> (raw_ret, typeof(GLib.List), true, false);
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_get_cursor(IntPtr raw, out IntPtr path, out IntPtr focus_column);

		public void GetCursor(out Gtk.TreePath path, out Gtk.TreeViewColumn focus_column) {
			Gtk.Application.AssertMainThread();
			IntPtr native_path;
			IntPtr native_focus_column;
			gtk_tree_view_get_cursor(Handle, out native_path, out native_focus_column);
			path = native_path == IntPtr.Zero ? null : (Gtk.TreePath) GLib.Opaque.GetOpaque (native_path, typeof (Gtk.TreePath), true);
			focus_column = GLib.Object.GetObject(native_focus_column) as Gtk.TreeViewColumn;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_view_get_dest_row_at_pos(IntPtr raw, int drag_x, int drag_y, out IntPtr path, out int pos);

		public bool GetDestRowAtPos(int drag_x, int drag_y, out Gtk.TreePath path, out Gtk.TreeViewDropPosition pos) {
			Gtk.Application.AssertMainThread();
			IntPtr native_path;
			int native_pos;
			bool raw_ret = gtk_tree_view_get_dest_row_at_pos(Handle, drag_x, drag_y, out native_path, out native_pos);
			bool ret = raw_ret;
			path = native_path == IntPtr.Zero ? null : (Gtk.TreePath) GLib.Opaque.GetOpaque (native_path, typeof (Gtk.TreePath), true);
			pos = (Gtk.TreeViewDropPosition) native_pos;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_get_drag_dest_row(IntPtr raw, out IntPtr path, out int pos);

		public void GetDragDestRow(out Gtk.TreePath path, out Gtk.TreeViewDropPosition pos) {
			Gtk.Application.AssertMainThread();
			IntPtr native_path;
			int native_pos;
			gtk_tree_view_get_drag_dest_row(Handle, out native_path, out native_pos);
			path = native_path == IntPtr.Zero ? null : (Gtk.TreePath) GLib.Opaque.GetOpaque (native_path, typeof (Gtk.TreePath), true);
			pos = (Gtk.TreeViewDropPosition) native_pos;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_tree_view_get_search_entry(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_search_entry(IntPtr raw, IntPtr entry);

		public Gtk.Entry SearchEntry { 
			get {
				IntPtr raw_ret = gtk_tree_view_get_search_entry(Handle);
				Gtk.Entry ret = GLib.Object.GetObject(raw_ret) as Gtk.Entry;
				return ret;
			}
			set {
				Gtk.Application.AssertMainThread();
				gtk_tree_view_set_search_entry(Handle, value == null ? IntPtr.Zero : value.Handle);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_tree_view_get_selection(IntPtr raw);

		public Gtk.TreeSelection Selection { 
			get {
				IntPtr raw_ret = gtk_tree_view_get_selection(Handle);
				Gtk.TreeSelection ret = GLib.Object.GetObject(raw_ret) as Gtk.TreeSelection;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_view_get_tooltip_context(IntPtr raw, out int x, out int y, bool keyboard_tip, out IntPtr model, out IntPtr path, ref Gtk.TreeIter iter);

		public bool GetTooltipContext(out int x, out int y, bool keyboard_tip, out Gtk.TreeModel model, out Gtk.TreePath path, out Gtk.TreeIter iter) {
			Gtk.Application.AssertMainThread();
			IntPtr native_model;
			IntPtr native_path;
			iter = new Gtk.TreeIter();
			bool raw_ret = gtk_tree_view_get_tooltip_context(Handle, out x, out y, keyboard_tip, out native_model, out native_path, ref iter);
			bool ret = raw_ret;
			model = Gtk.TreeModelAdapter.GetObject (native_model, false);
			path = native_path == IntPtr.Zero ? null : (Gtk.TreePath) GLib.Opaque.GetOpaque (native_path, typeof (Gtk.TreePath), true);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_tree_view_get_type();

		static GLib.GType _gtype = new GLib.GType (gtk_tree_view_get_type());
		public static new GLib.GType GType { 
			get {
								return _gtype;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_view_get_visible_range(IntPtr raw, out IntPtr start_path, out IntPtr end_path);

		public bool GetVisibleRange(out Gtk.TreePath start_path, out Gtk.TreePath end_path) {
			Gtk.Application.AssertMainThread();
			IntPtr native_start_path;
			IntPtr native_end_path;
			bool raw_ret = gtk_tree_view_get_visible_range(Handle, out native_start_path, out native_end_path);
			bool ret = raw_ret;
			start_path = native_start_path == IntPtr.Zero ? null : (Gtk.TreePath) GLib.Opaque.GetOpaque (native_start_path, typeof (Gtk.TreePath), true);
			end_path = native_end_path == IntPtr.Zero ? null : (Gtk.TreePath) GLib.Opaque.GetOpaque (native_end_path, typeof (Gtk.TreePath), true);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_get_visible_rect(IntPtr raw, ref Gdk.Rectangle visible_rect);

		public Gdk.Rectangle VisibleRect { 
			get {
				Gdk.Rectangle visible_rect;
				Gtk.Application.AssertMainThread();
				visible_rect = new Gdk.Rectangle();
				gtk_tree_view_get_visible_rect(Handle, ref visible_rect);
				return visible_rect;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_tree_view_insert_column(IntPtr raw, IntPtr column, int position);

		public int InsertColumn(Gtk.TreeViewColumn column, int position) {
			Gtk.Application.AssertMainThread();
			int raw_ret = gtk_tree_view_insert_column(Handle, column == null ? IntPtr.Zero : column.Handle, position);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_view_is_rubber_banding_active(IntPtr raw);

		public bool IsRubberBandingActive { 
			get {
				bool raw_ret = gtk_tree_view_is_rubber_banding_active(Handle);
				bool ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_map_expanded_rows(IntPtr raw, GtkSharp.TreeViewMappingFuncNative func, IntPtr data);

		public void MapExpandedRows(Gtk.TreeViewMappingFunc func) {
			Gtk.Application.AssertMainThread();
			GCHandle gch = GCHandle.Alloc (func);
			gtk_tree_view_map_expanded_rows(Handle, (func == null) ? null : GtkSharp.TreeViewMappingFuncWrapper.NativeDelegate, (IntPtr)gch);
			gch.Free();
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_move_column_after(IntPtr raw, IntPtr column, IntPtr base_column);

		public void MoveColumnAfter(Gtk.TreeViewColumn column, Gtk.TreeViewColumn base_column) {
			Gtk.Application.AssertMainThread();
			gtk_tree_view_move_column_after(Handle, column == null ? IntPtr.Zero : column.Handle, base_column == null ? IntPtr.Zero : base_column.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_tree_view_remove_column(IntPtr raw, IntPtr column);

		public int RemoveColumn(Gtk.TreeViewColumn column) {
			Gtk.Application.AssertMainThread();
			int raw_ret = gtk_tree_view_remove_column(Handle, column == null ? IntPtr.Zero : column.Handle);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_row_activated(IntPtr raw, IntPtr path, IntPtr column);

		public void ActivateRow(Gtk.TreePath path, Gtk.TreeViewColumn column) {
			Gtk.Application.AssertMainThread();
			gtk_tree_view_row_activated(Handle, path == null ? IntPtr.Zero : path.Handle, column == null ? IntPtr.Zero : column.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_view_row_expanded(IntPtr raw, IntPtr path);

		public bool GetRowExpanded(Gtk.TreePath path) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_tree_view_row_expanded(Handle, path == null ? IntPtr.Zero : path.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_scroll_to_cell(IntPtr raw, IntPtr path, IntPtr column, bool use_align, float row_align, float col_align);

		public void ScrollToCell(Gtk.TreePath path, Gtk.TreeViewColumn column, bool use_align, float row_align, float col_align) {
			Gtk.Application.AssertMainThread();
			gtk_tree_view_scroll_to_cell(Handle, path == null ? IntPtr.Zero : path.Handle, column == null ? IntPtr.Zero : column.Handle, use_align, row_align, col_align);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_scroll_to_point(IntPtr raw, int tree_x, int tree_y);

		public void ScrollToPoint(int tree_x, int tree_y) {
			Gtk.Application.AssertMainThread();
			gtk_tree_view_scroll_to_point(Handle, tree_x, tree_y);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_column_drag_function(IntPtr raw, GtkSharp.TreeViewColumnDropFuncNative func, IntPtr user_data, GLib.DestroyNotify destroy);

		public Gtk.TreeViewColumnDropFunc ColumnDragFunction { 
			set {
				Gtk.Application.AssertMainThread();
				IntPtr user_data;
				GLib.DestroyNotify destroy;
				if (value == null) {
					user_data = IntPtr.Zero;
					destroy = null;
				} else {
					user_data = (IntPtr) GCHandle.Alloc (value);
					destroy = GLib.DestroyHelper.NotifyHandler;
				}
				gtk_tree_view_set_column_drag_function(Handle, (value == null) ? null : GtkSharp.TreeViewColumnDropFuncWrapper.NativeDelegate, user_data, destroy);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_cursor(IntPtr raw, IntPtr path, IntPtr focus_column, bool start_editing);

		public void SetCursor(Gtk.TreePath path, Gtk.TreeViewColumn focus_column, bool start_editing) {
			Gtk.Application.AssertMainThread();
			gtk_tree_view_set_cursor(Handle, path == null ? IntPtr.Zero : path.Handle, focus_column == null ? IntPtr.Zero : focus_column.Handle, start_editing);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_cursor_on_cell(IntPtr raw, IntPtr path, IntPtr focus_column, IntPtr focus_cell, bool start_editing);

		public void SetCursorOnCell(Gtk.TreePath path, Gtk.TreeViewColumn focus_column, Gtk.CellRenderer focus_cell, bool start_editing) {
			Gtk.Application.AssertMainThread();
			gtk_tree_view_set_cursor_on_cell(Handle, path == null ? IntPtr.Zero : path.Handle, focus_column == null ? IntPtr.Zero : focus_column.Handle, focus_cell == null ? IntPtr.Zero : focus_cell.Handle, start_editing);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_destroy_count_func(IntPtr raw, GtkSharp.TreeDestroyCountFuncNative func, IntPtr data, GLib.DestroyNotify destroy);

		public Gtk.TreeDestroyCountFunc DestroyCountFunc { 
			set {
				Gtk.Application.AssertMainThread();
				IntPtr data;
				GLib.DestroyNotify destroy;
				if (value == null) {
					data = IntPtr.Zero;
					destroy = null;
				} else {
					data = (IntPtr) GCHandle.Alloc (value);
					destroy = GLib.DestroyHelper.NotifyHandler;
				}
				gtk_tree_view_set_destroy_count_func(Handle, (value == null) ? null : GtkSharp.TreeDestroyCountFuncWrapper.NativeDelegate, data, destroy);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_drag_dest_row(IntPtr raw, IntPtr path, int pos);

		public void SetDragDestRow(Gtk.TreePath path, Gtk.TreeViewDropPosition pos) {
			Gtk.Application.AssertMainThread();
			gtk_tree_view_set_drag_dest_row(Handle, path == null ? IntPtr.Zero : path.Handle, (int) pos);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_tooltip_cell(IntPtr raw, IntPtr tooltip, IntPtr path, IntPtr column, IntPtr cell);

		public void SetTooltipCell(Gtk.Tooltip tooltip, Gtk.TreePath path, Gtk.TreeViewColumn column, Gtk.CellRenderer cell) {
			Gtk.Application.AssertMainThread();
			gtk_tree_view_set_tooltip_cell(Handle, tooltip == null ? IntPtr.Zero : tooltip.Handle, path == null ? IntPtr.Zero : path.Handle, column == null ? IntPtr.Zero : column.Handle, cell == null ? IntPtr.Zero : cell.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_tooltip_row(IntPtr raw, IntPtr tooltip, IntPtr path);

		public void SetTooltipRow(Gtk.Tooltip tooltip, Gtk.TreePath path) {
			Gtk.Application.AssertMainThread();
			gtk_tree_view_set_tooltip_row(Handle, tooltip == null ? IntPtr.Zero : tooltip.Handle, path == null ? IntPtr.Zero : path.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_tree_to_widget_coords(IntPtr raw, int tx, int ty, out int wx, out int wy);

		[Obsolete]
		public void TreeToWidgetCoords(int tx, int ty, out int wx, out int wy) {
			Gtk.Application.AssertMainThread();
			gtk_tree_view_tree_to_widget_coords(Handle, tx, ty, out wx, out wy);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_unset_rows_drag_dest(IntPtr raw);

		public void UnsetRowsDragDest() {
			gtk_tree_view_unset_rows_drag_dest(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_unset_rows_drag_source(IntPtr raw);

		public void UnsetRowsDragSource() {
			gtk_tree_view_unset_rows_drag_source(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_widget_to_tree_coords(IntPtr raw, int wx, int wy, out int tx, out int ty);

		[Obsolete]
		public void WidgetToTreeCoords(int wx, int wy, out int tx, out int ty) {
			Gtk.Application.AssertMainThread();
			gtk_tree_view_widget_to_tree_coords(Handle, wx, wy, out tx, out ty);
		}

#endregion
#region Customized extensions
#line 1 "TreeView.custom"
// Gtk.TreeView.Custom - Gtk TreeView class customizations
//
// Authors:
//	Kristian Rietveld <kris@gtk.org>
//	Gonzalo Paniagua Javier (gonzalo@ximian.com)
//
// Copyright (c) 2002 Kristian Rietveld
// Copyright (c) 2003 Ximian, Inc. (http://www.ximian.com)
//
// This code is inserted after the automatically generated code.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of version 2 of the Lesser GNU General 
// Public License as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this program; if not, write to the
// Free Software Foundation, Inc., 59 Temple Place - Suite 330,
// Boston, MA 02111-1307, USA.


		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_tree_view_new_with_model(IntPtr model);

		[DllImport("libgobject-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
		static extern void g_object_ref (IntPtr raw);

		public TreeView (Gtk.TreeModel model) : base (IntPtr.Zero)
		{
			if (GetType () != typeof (TreeView)) {
				unsafe {
					var vals = stackalloc GLib.Value[1];
					var names = stackalloc IntPtr[1];
					var param_count = 0;
					if (model != null) {
						names[param_count] = GLib.Marshaller.StringToPtrGStrdup ("model");
						vals[param_count++] = new GLib.Value (model);
					}
					CreateNativeObject (names, vals, param_count);
				}
				return;
			}
			owned = true;
			Raw = gtk_tree_view_new_with_model(model == null ? IntPtr.Zero : model.Handle);
			if (model != null)
				g_object_ref (model.Handle);
		}

		[Obsolete ("Use NodeView with NodeStores")]
		public TreeView (NodeStore store) : base (IntPtr.Zero)
		{
			if (GetType() != typeof (TreeView)) {
				unsafe {
					var vals = stackalloc GLib.Value[1];
					var names = stackalloc IntPtr[1];
					names [0] = GLib.Marshaller.StringToPtrGStrdup ("model");
					vals [0] = new GLib.Value (store);
					CreateNativeObject (names, vals, 1);
				}
				return;
			}

			owned = true;
			Raw = gtk_tree_view_new_with_model (store.Handle);
		}

		public Gdk.Color OddRowColor {
			get {
				GLib.Value value = StyleGetPropertyValue ("odd-row-color");
				Gdk.Color ret = (Gdk.Color)value;
				value.Dispose ();
				return ret;
			}
		}

		public Gdk.Color EvenRowColor {
			get {
				GLib.Value value = StyleGetPropertyValue ("even-row-color");
				Gdk.Color ret = (Gdk.Color)value;
				value.Dispose ();
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
		static extern bool gtk_tree_view_get_path_at_pos (IntPtr raw,
								  int x,
								  int y,
								  out IntPtr path,
								  out IntPtr column,
								  out int cell_x,
								  out int cell_y);

		[DllImport("libgtk-win32-2.0-0.dll", EntryPoint="gtk_tree_view_get_path_at_pos", CallingConvention=CallingConvention.Cdecl)]
		static extern bool gtk_tree_view_get_path_at_pos_intptr (IntPtr raw,
								  int x,
								  int y,
								  out IntPtr path,
								  out IntPtr column,
								  IntPtr cell_x,
								  IntPtr cell_y);

		public bool GetPathAtPos (int x, int y, out Gtk.TreePath path, out Gtk.TreeViewColumn column, out int cell_x, out int cell_y)
		{
			IntPtr pathHandle;
			IntPtr columnHandle;
			bool raw_ret = gtk_tree_view_get_path_at_pos (Handle, x, y, out pathHandle, out columnHandle, out cell_x, out cell_y);
			if (raw_ret) {
				column = (Gtk.TreeViewColumn) GLib.Object.GetObject (columnHandle, false);
				path = (Gtk.TreePath) GLib.Opaque.GetOpaque (pathHandle, typeof (Gtk.TreePath), true);
			} else {
				path = null;
				column = null;
			}

			return raw_ret;
		}


		public bool GetPathAtPos (int x, int y, out Gtk.TreePath path)
		{
			IntPtr pathHandle;
			IntPtr columnHandle;
			bool raw_ret = gtk_tree_view_get_path_at_pos_intptr (Handle, x, y, out pathHandle, out columnHandle, IntPtr.Zero, IntPtr.Zero);
			if (raw_ret)
				path = (Gtk.TreePath) GLib.Opaque.GetOpaque (pathHandle, typeof (Gtk.TreePath), true);
			else
				path = null;

			return raw_ret;
		}

		public bool GetPathAtPos (int x, int y, out Gtk.TreePath path, out Gtk.TreeViewColumn column)
		{
			IntPtr pathHandle;
			IntPtr columnHandle;
			bool raw_ret = gtk_tree_view_get_path_at_pos_intptr (Handle, x, y, out pathHandle, out columnHandle, IntPtr.Zero, IntPtr.Zero);
			if (raw_ret) {
				path = (Gtk.TreePath) GLib.Opaque.GetOpaque (pathHandle, typeof (Gtk.TreePath), true);
				column = (Gtk.TreeViewColumn) GLib.Object.GetObject (columnHandle, false);
			} else {
				path = null;
				column = null;
			}

			return raw_ret;
		}

		public TreeViewColumn AppendColumn (string title, CellRenderer cell, TreeCellDataFunc cell_data) 
		{
			Gtk.TreeViewColumn col = new Gtk.TreeViewColumn ();
			col.Title = title;
			col.PackStart (cell, true);
			col.SetCellDataFunc (cell, cell_data);
			
			AppendColumn (col);
			return col;
		}
		
		public TreeViewColumn AppendColumn (string title, CellRenderer cell, CellLayoutDataFunc cell_data) {
			Gtk.TreeViewColumn col = new Gtk.TreeViewColumn ();
			col.Title = title;
			col.PackStart (cell, true);
			col.SetCellDataFunc (cell, cell_data);
			
			AppendColumn (col);
			return col;
		}
		
		public Gtk.TreeViewColumn AppendColumn (string title, Gtk.CellRenderer cell, params object[] attrs) {
			Gtk.TreeViewColumn col = new Gtk.TreeViewColumn (title, cell, attrs);
			AppendColumn (col);
			return col;
		}

		public int InsertColumn (int pos, string title, CellRenderer cell, CellLayoutDataFunc cell_data) 
		{
			TreeViewColumn col = new TreeViewColumn ();
			col.Title = title;
			col.PackStart (cell, true);
			col.SetCellDataFunc (cell, cell_data);
			return InsertColumn (col, pos);
		}
		
		public int InsertColumn (int pos, string title, CellRenderer cell, params object[] attrs) 
		{
			TreeViewColumn col = new TreeViewColumn (title, cell, attrs);
			return InsertColumn (col, pos);
		}

		[Obsolete ("Replaced by SearchEqualFunc property.")]
		public void SetSearchEqualFunc (TreeViewSearchEqualFunc search_equal_func, IntPtr search_user_data, DestroyNotify search_destroy) 
		{
			SearchEqualFunc = search_equal_func;
		}

		[Obsolete ("Replaced by DestroyCountFunc property.")]
		public void SetDestroyCountFunc (TreeDestroyCountFunc func, IntPtr data, DestroyNotify destroy) 
		{
			DestroyCountFunc = func;
		}

		[Obsolete ("Replaced by ColumnDragFunction property.")]
		public void SetColumnDragFunction (TreeViewColumnDropFunc func, IntPtr user_data, DestroyNotify destroy) 
		{
			ColumnDragFunction = func;
		}

		[Obsolete ("Replaced by VisibleRect property.")]
		public void GetVisibleRect(Gdk.Rectangle visible_rect) {
			;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern GtkSharp.TreeViewRowSeparatorFuncNative gtk_tree_view_get_row_separator_func(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_row_separator_func(IntPtr raw, GtkSharp.TreeViewRowSeparatorFuncNative func, IntPtr data, GLib.DestroyNotify destroy);

		WeakReference<Gtk.TreeViewRowSeparatorFunc> lastRowSeparatorFunc = new WeakReference<Gtk.TreeViewRowSeparatorFunc> (null);
		public Gtk.TreeViewRowSeparatorFunc RowSeparatorFunc { 
			get {
				GtkSharp.TreeViewRowSeparatorFuncNative raw_ret = gtk_tree_view_get_row_separator_func(Handle);
				if (raw_ret == GtkSharp.TreeViewRowSeparatorFuncWrapper.NativeDelegate) {
					Gtk.TreeViewRowSeparatorFunc result;
					lastRowSeparatorFunc.TryGetTarget (out result);
					return result;
				}

				if (raw_ret == null)
					return null;

				Gtk.TreeViewRowSeparatorFunc ret = new GtkSharp.TreeViewRowSeparatorFuncInvoker (raw_ret).Handler;
				return ret;
			}
			set {
				Gtk.Application.AssertMainThread();
				IntPtr data;
				GLib.DestroyNotify destroy;
				if (value == null) {
					data = IntPtr.Zero;
					destroy = null;
				} else {
					data = (IntPtr) GCHandle.Alloc (value);
					destroy = GLib.DestroyHelper.NotifyHandler;
				}
				lastRowSeparatorFunc.SetTarget (value);
				gtk_tree_view_set_row_separator_func(Handle, GtkSharp.TreeViewRowSeparatorFuncWrapper.NativeDelegate, data, destroy);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern GtkSharp.TreeViewSearchEqualFuncNative gtk_tree_view_get_search_equal_func(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_search_equal_func(IntPtr raw, GtkSharp.TreeViewSearchEqualFuncNative search_equal_func, IntPtr search_user_data, GLib.DestroyNotify search_destroy);

		WeakReference<Gtk.TreeViewSearchEqualFunc> lastSearchEqualFunc = new WeakReference<Gtk.TreeViewSearchEqualFunc> (null);
		public Gtk.TreeViewSearchEqualFunc SearchEqualFunc { 
			get {
				GtkSharp.TreeViewSearchEqualFuncNative raw_ret = gtk_tree_view_get_search_equal_func(Handle);
				if (raw_ret == GtkSharp.TreeViewSearchEqualFuncWrapper.NativeDelegate) {
					Gtk.TreeViewSearchEqualFunc result;
					lastSearchEqualFunc.TryGetTarget (out result);
					return result;
				}

				if (raw_ret == null)
					return null;

				Gtk.TreeViewSearchEqualFunc ret = new GtkSharp.TreeViewSearchEqualFuncInvoker (raw_ret).Handler;
				return ret;
			}
			set {
				Gtk.Application.AssertMainThread();
				IntPtr search_user_data;
				GLib.DestroyNotify search_destroy;
				if (value == null) {
					search_user_data = IntPtr.Zero;
					search_destroy = null;
				} else {
					search_user_data = (IntPtr) GCHandle.Alloc (value);
					search_destroy = GLib.DestroyHelper.NotifyHandler;
				}
				lastSearchEqualFunc.SetTarget (value);
				gtk_tree_view_set_search_equal_func(Handle, GtkSharp.TreeViewSearchEqualFuncWrapper.NativeDelegate, search_user_data, search_destroy);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern GtkSharp.TreeViewSearchPositionFuncNative gtk_tree_view_get_search_position_func(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_view_set_search_position_func(IntPtr raw, GtkSharp.TreeViewSearchPositionFuncNative func, IntPtr data, GLib.DestroyNotify destroy);

		WeakReference<Gtk.TreeViewSearchPositionFunc> lastSearchPositionFunc = new WeakReference<Gtk.TreeViewSearchPositionFunc> (null);
		public Gtk.TreeViewSearchPositionFunc SearchPositionFunc { 
			get {
				GtkSharp.TreeViewSearchPositionFuncNative raw_ret = gtk_tree_view_get_search_position_func(Handle);
				if (raw_ret == GtkSharp.TreeViewSearchPositionFuncWrapper.NativeDelegate) {
					Gtk.TreeViewSearchPositionFunc result;
					lastSearchPositionFunc.TryGetTarget (out result);
					return result;
				}

				if (raw_ret == null)
					return null;

				Gtk.TreeViewSearchPositionFunc ret = new GtkSharp.TreeViewSearchPositionFuncInvoker (raw_ret).Handler;
				return ret;
			}
			set {
				Gtk.Application.AssertMainThread();
				IntPtr data;
				GLib.DestroyNotify destroy;
				if (value == null) {
					data = IntPtr.Zero;
					destroy = null;
				} else {
					data = (IntPtr) GCHandle.Alloc (value);
					destroy = GLib.DestroyHelper.NotifyHandler;
				}
				lastSearchPositionFunc.SetTarget (value);
				gtk_tree_view_set_search_position_func(Handle, GtkSharp.TreeViewSearchPositionFuncWrapper.NativeDelegate, data, destroy);
			}
		}

#endregion
	}

	internal class TreeViewAttribute : GLib.GTypeTypeAttribute {
		[DllImport ("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_tree_view_get_type ();

		private static GLib.GType _gtype = new GLib.GType (gtk_tree_view_get_type ());
		public static GLib.GType GType { get { return _gtype; } }
		public override GLib.GType Type { get { return _gtype; } }

	}
}
