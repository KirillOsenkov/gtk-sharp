// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gtk {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	[Notebook]
	public class Notebook : Gtk.Container {

		[Obsolete]
		protected Notebook(GLib.GType gtype) : base(gtype) {}
		public Notebook(IntPtr raw) : base(raw) {}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_notebook_new();

		public Notebook () : base (IntPtr.Zero)
		{
			if (GetType () != typeof (Notebook)) {
				Gtk.Application.AssertMainThread();
				CreateNativeObject (Array.Empty<IntPtr> (), Array.Empty<GLib.Value> (), 0);
				return;
			}
			owned = true;
			Raw = gtk_notebook_new();
		}

		[GLib.Property ("page")]
		public int Page {
			get {
				using (GLib.Value val = GetProperty ("page")) {
					int ret = (int) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("page", val);
				}
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_notebook_get_tab_pos(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_notebook_set_tab_pos(IntPtr raw, int pos);

		[GLib.Property ("tab-pos")]
		public Gtk.PositionType TabPos {
			get  {
				int raw_ret = gtk_notebook_get_tab_pos(Handle);
				Gtk.PositionType ret = (Gtk.PositionType) raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_notebook_set_tab_pos(Handle, (int) value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_notebook_set_tab_border(IntPtr raw, uint border_width);

		[Obsolete]
		[GLib.Property ("tab-border")]
		public uint TabBorder {
			set  {
				Gtk.Application.AssertMainThread();
				gtk_notebook_set_tab_border(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_notebook_set_tab_hborder(IntPtr raw, uint tab_hborder);

		[Obsolete]
		[GLib.Property ("tab-hborder")]
		public uint TabHborder {
			get {
				using (GLib.Value val = GetProperty ("tab-hborder")) {
					uint ret = (uint) val;
					return ret;
				}
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_notebook_set_tab_hborder(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_notebook_set_tab_vborder(IntPtr raw, uint tab_vborder);

		[Obsolete]
		[GLib.Property ("tab-vborder")]
		public uint TabVborder {
			get {
				using (GLib.Value val = GetProperty ("tab-vborder")) {
					uint ret = (uint) val;
					return ret;
				}
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_notebook_set_tab_vborder(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_notebook_get_show_tabs(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_notebook_set_show_tabs(IntPtr raw, bool show_tabs);

		[GLib.Property ("show-tabs")]
		public bool ShowTabs {
			get  {
				bool raw_ret = gtk_notebook_get_show_tabs(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_notebook_set_show_tabs(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_notebook_get_show_border(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_notebook_set_show_border(IntPtr raw, bool show_border);

		[GLib.Property ("show-border")]
		public bool ShowBorder {
			get  {
				bool raw_ret = gtk_notebook_get_show_border(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_notebook_set_show_border(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_notebook_get_scrollable(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_notebook_set_scrollable(IntPtr raw, bool scrollable);

		[GLib.Property ("scrollable")]
		public bool Scrollable {
			get  {
				bool raw_ret = gtk_notebook_get_scrollable(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_notebook_set_scrollable(Handle, value);
			}
		}

		[GLib.Property ("enable-popup")]
		public bool EnablePopup {
			get {
				using (GLib.Value val = GetProperty ("enable-popup")) {
					bool ret = (bool) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("enable-popup", val);
				}
			}
		}

		[Obsolete]
		[GLib.Property ("homogeneous")]
		public bool Homogeneous {
			get {
				using (GLib.Value val = GetProperty ("homogeneous")) {
					bool ret = (bool) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("homogeneous", val);
				}
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_notebook_get_group_id(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_notebook_set_group_id(IntPtr raw, int group_id);

		[Obsolete]
		[GLib.Property ("group-id")]
		public int GroupId {
			get  {
				int raw_ret = gtk_notebook_get_group_id(Handle);
				int ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_notebook_set_group_id(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_notebook_get_group(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_notebook_set_group(IntPtr raw, IntPtr group);

		[GLib.Property ("group")]
		public IntPtr Group {
			get  {
				IntPtr raw_ret = gtk_notebook_get_group(Handle);
				IntPtr ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_notebook_set_group(Handle, value);
			}
		}

		public class NotebookChild : Gtk.Container.ContainerChild {
			protected internal NotebookChild (Gtk.Container parent, Gtk.Widget child) : base (parent, child) {}

			[Gtk.ChildProperty ("tab-label")]
			public string TabLabel {
				get {
					using (GLib.Value val = parent.ChildGetProperty (child, "tab-label")) {
						string ret = (string) val;
						return ret;
					}
				}
				set {
					using (GLib.Value val = new GLib.Value(value)) {
						parent.ChildSetProperty(child, "tab-label", val);
					}
				}
			}

			[Gtk.ChildProperty ("menu-label")]
			public string MenuLabel {
				get {
					using (GLib.Value val = parent.ChildGetProperty (child, "menu-label")) {
						string ret = (string) val;
						return ret;
					}
				}
				set {
					using (GLib.Value val = new GLib.Value(value)) {
						parent.ChildSetProperty(child, "menu-label", val);
					}
				}
			}

			[Gtk.ChildProperty ("position")]
			public int Position {
				get {
					using (GLib.Value val = parent.ChildGetProperty (child, "position")) {
						int ret = (int) val;
						return ret;
					}
				}
				set {
					using (GLib.Value val = new GLib.Value(value)) {
						parent.ChildSetProperty(child, "position", val);
					}
				}
			}

			[Gtk.ChildProperty ("tab-expand")]
			public bool TabExpand {
				get {
					using (GLib.Value val = parent.ChildGetProperty (child, "tab-expand")) {
						bool ret = (bool) val;
						return ret;
					}
				}
				set {
					using (GLib.Value val = new GLib.Value(value)) {
						parent.ChildSetProperty(child, "tab-expand", val);
					}
				}
			}

			[Gtk.ChildProperty ("tab-fill")]
			public bool TabFill {
				get {
					using (GLib.Value val = parent.ChildGetProperty (child, "tab-fill")) {
						bool ret = (bool) val;
						return ret;
					}
				}
				set {
					using (GLib.Value val = new GLib.Value(value)) {
						parent.ChildSetProperty(child, "tab-fill", val);
					}
				}
			}

			[Gtk.ChildProperty ("tab-pack")]
			public Gtk.PackType TabPack {
				get {
					using (GLib.Value val = parent.ChildGetProperty (child, "tab-pack")) {
						Gtk.PackType ret = (Gtk.PackType) (Enum) val;
						return ret;
					}
				}
				set {
					using (GLib.Value val = new GLib.Value((Enum) value)) {
						parent.ChildSetProperty(child, "tab-pack", val);
					}
				}
			}

			[Gtk.ChildProperty ("reorderable")]
			public bool Reorderable {
				get {
					using (GLib.Value val = parent.ChildGetProperty (child, "reorderable")) {
						bool ret = (bool) val;
						return ret;
					}
				}
				set {
					using (GLib.Value val = new GLib.Value(value)) {
						parent.ChildSetProperty(child, "reorderable", val);
					}
				}
			}

			[Gtk.ChildProperty ("detachable")]
			public bool Detachable {
				get {
					using (GLib.Value val = parent.ChildGetProperty (child, "detachable")) {
						bool ret = (bool) val;
						return ret;
					}
				}
				set {
					using (GLib.Value val = new GLib.Value(value)) {
						parent.ChildSetProperty(child, "detachable", val);
					}
				}
			}

		}

		public override Gtk.Container.ContainerChild this [Gtk.Widget child] {
			get {
				return new NotebookChild (this, child);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void SwitchPageVMDelegate (IntPtr notebook, IntPtr page, uint page_num);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_notebook_override_switch_page (IntPtr gtype, SwitchPageVMDelegate cb);

		static SwitchPageVMDelegate SwitchPageVMCallback;

		static void switchpage_cb (IntPtr notebook, IntPtr page, uint page_num)
		{
			try {
				Notebook notebook_managed = GLib.Object.GetObject (notebook, false) as Notebook;
				notebook_managed.OnSwitchPage (page == IntPtr.Zero ? null : (Gtk.NotebookPage) GLib.Opaque.GetOpaque (page, typeof (Gtk.NotebookPage), false), page_num);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideSwitchPage (GLib.GType gtype)
		{
			if (SwitchPageVMCallback == null)
				SwitchPageVMCallback = new SwitchPageVMDelegate (switchpage_cb);
			gtksharp_notebook_override_switch_page (gtype.Val, SwitchPageVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_notebook_base_switch_page (IntPtr notebook, IntPtr page, uint page_num);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Notebook), ConnectionMethod="OverrideSwitchPage")]
		protected virtual void OnSwitchPage (Gtk.NotebookPage page, uint page_num)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_notebook_base_switch_page (Handle, page == null ? IntPtr.Zero : page.Handle, page_num);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void SwitchPageSignalDelegate (IntPtr arg0, IntPtr arg1, uint arg2, IntPtr gch);

		static void SwitchPageSignalCallback (IntPtr arg0, IntPtr arg1, uint arg2, IntPtr gch)
		{
			Gtk.SwitchPageArgs args = new Gtk.SwitchPageArgs ();
			try {
				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
				if (sig == null)
					throw new Exception("Unknown signal GC handle received " + gch);

				args.Args = new object[2];
				args.Args[0] = arg1 == IntPtr.Zero ? null : (Gtk.NotebookPage) GLib.Opaque.GetOpaque (arg1, typeof (Gtk.NotebookPage), false);
				args.Args[1] = arg2;
				Gtk.SwitchPageHandler handler = (Gtk.SwitchPageHandler) sig.Handler;
				handler (GLib.Object.GetObject (arg0), args);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.Signal("switch_page")]
		public event Gtk.SwitchPageHandler SwitchPage {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "switch_page", new SwitchPageSignalDelegate(SwitchPageSignalCallback));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "switch_page", new SwitchPageSignalDelegate(SwitchPageSignalCallback));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool FocusTabVMDelegate (IntPtr notebook, int type);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_notebook_override_focus_tab (IntPtr gtype, FocusTabVMDelegate cb);

		static FocusTabVMDelegate FocusTabVMCallback;

		static bool focustab_cb (IntPtr notebook, int type)
		{
			try {
				Notebook notebook_managed = GLib.Object.GetObject (notebook, false) as Notebook;
				return notebook_managed.OnFocusTab ((Gtk.NotebookTab) type);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideFocusTab (GLib.GType gtype)
		{
			if (FocusTabVMCallback == null)
				FocusTabVMCallback = new FocusTabVMDelegate (focustab_cb);
			gtksharp_notebook_override_focus_tab (gtype.Val, FocusTabVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_notebook_base_focus_tab (IntPtr notebook, int type);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Notebook), ConnectionMethod="OverrideFocusTab")]
		protected virtual bool OnFocusTab (Gtk.NotebookTab type)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_notebook_base_focus_tab (Handle, (int) type);
			return __ret;
		}

		[GLib.Signal("focus_tab")]
		public event Gtk.FocusTabHandler FocusTab {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "focus_tab", typeof (Gtk.FocusTabArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "focus_tab", typeof (Gtk.FocusTabArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool SelectPageVMDelegate (IntPtr notebook, bool move_focus);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_notebook_override_select_page (IntPtr gtype, SelectPageVMDelegate cb);

		static SelectPageVMDelegate SelectPageVMCallback;

		static bool selectpage_cb (IntPtr notebook, bool move_focus)
		{
			try {
				Notebook notebook_managed = GLib.Object.GetObject (notebook, false) as Notebook;
				return notebook_managed.OnSelectPage (move_focus);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideSelectPage (GLib.GType gtype)
		{
			if (SelectPageVMCallback == null)
				SelectPageVMCallback = new SelectPageVMDelegate (selectpage_cb);
			gtksharp_notebook_override_select_page (gtype.Val, SelectPageVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_notebook_base_select_page (IntPtr notebook, bool move_focus);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Notebook), ConnectionMethod="OverrideSelectPage")]
		protected virtual bool OnSelectPage (bool move_focus)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_notebook_base_select_page (Handle, move_focus);
			return __ret;
		}

		[GLib.Signal("select_page")]
		public event Gtk.SelectPageHandler SelectPage {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "select_page", typeof (Gtk.SelectPageArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "select_page", typeof (Gtk.SelectPageArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ChangeCurrentPageVMDelegate (IntPtr notebook, int offset);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_notebook_override_change_current_page (IntPtr gtype, ChangeCurrentPageVMDelegate cb);

		static ChangeCurrentPageVMDelegate ChangeCurrentPageVMCallback;

		static void changecurrentpage_cb (IntPtr notebook, int offset)
		{
			try {
				Notebook notebook_managed = GLib.Object.GetObject (notebook, false) as Notebook;
				notebook_managed.OnChangeCurrentPage (offset);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideChangeCurrentPage (GLib.GType gtype)
		{
			if (ChangeCurrentPageVMCallback == null)
				ChangeCurrentPageVMCallback = new ChangeCurrentPageVMDelegate (changecurrentpage_cb);
			gtksharp_notebook_override_change_current_page (gtype.Val, ChangeCurrentPageVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_notebook_base_change_current_page (IntPtr notebook, int offset);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Notebook), ConnectionMethod="OverrideChangeCurrentPage")]
		protected virtual void OnChangeCurrentPage (int offset)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_notebook_base_change_current_page (Handle, offset);
		}

		[GLib.Signal("change_current_page")]
		public event Gtk.ChangeCurrentPageHandler ChangeCurrentPage {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "change_current_page", typeof (Gtk.ChangeCurrentPageArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "change_current_page", typeof (Gtk.ChangeCurrentPageArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void MoveFocusOutVMDelegate (IntPtr notebook, int direction);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_notebook_override_move_focus_out (IntPtr gtype, MoveFocusOutVMDelegate cb);

		static MoveFocusOutVMDelegate MoveFocusOutVMCallback;

		static void movefocusout_cb (IntPtr notebook, int direction)
		{
			try {
				Notebook notebook_managed = GLib.Object.GetObject (notebook, false) as Notebook;
				notebook_managed.OnMoveFocusOut ((Gtk.DirectionType) direction);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideMoveFocusOut (GLib.GType gtype)
		{
			if (MoveFocusOutVMCallback == null)
				MoveFocusOutVMCallback = new MoveFocusOutVMDelegate (movefocusout_cb);
			gtksharp_notebook_override_move_focus_out (gtype.Val, MoveFocusOutVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_notebook_base_move_focus_out (IntPtr notebook, int direction);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Notebook), ConnectionMethod="OverrideMoveFocusOut")]
		protected virtual void OnMoveFocusOut (Gtk.DirectionType direction)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_notebook_base_move_focus_out (Handle, (int) direction);
		}

		[GLib.Signal("move_focus_out")]
		public event Gtk.MoveFocusOutHandler MoveFocusOut {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "move_focus_out", typeof (Gtk.MoveFocusOutArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "move_focus_out", typeof (Gtk.MoveFocusOutArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ReorderTabVMDelegate (IntPtr notebook, int direction, bool move_to_last);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_notebook_override_reorder_tab (IntPtr gtype, ReorderTabVMDelegate cb);

		static ReorderTabVMDelegate ReorderTabVMCallback;

		static void reordertab_cb (IntPtr notebook, int direction, bool move_to_last)
		{
			try {
				Notebook notebook_managed = GLib.Object.GetObject (notebook, false) as Notebook;
				notebook_managed.OnReorderTab ((Gtk.DirectionType) direction, move_to_last);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideReorderTab (GLib.GType gtype)
		{
			if (ReorderTabVMCallback == null)
				ReorderTabVMCallback = new ReorderTabVMDelegate (reordertab_cb);
			gtksharp_notebook_override_reorder_tab (gtype.Val, ReorderTabVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_notebook_base_reorder_tab (IntPtr notebook, int direction, bool move_to_last);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Notebook), ConnectionMethod="OverrideReorderTab")]
		protected virtual void OnReorderTab (Gtk.DirectionType direction, bool move_to_last)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_notebook_base_reorder_tab (Handle, (int) direction, move_to_last);
		}

		[GLib.Signal("reorder_tab")]
		public event Gtk.ReorderTabHandler ReorderTab {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "reorder_tab", typeof (Gtk.ReorderTabArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "reorder_tab", typeof (Gtk.ReorderTabArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void PageReorderedVMDelegate (IntPtr inst, IntPtr p0, uint p1);

		static PageReorderedVMDelegate PageReorderedVMCallback;

		static void pagereordered_cb (IntPtr inst, IntPtr p0, uint p1)
		{
			try {
				Notebook inst_managed = GLib.Object.GetObject (inst, false) as Notebook;
				inst_managed.OnPageReordered (GLib.Object.GetObject(p0) as Gtk.Widget, p1);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverridePageReordered (GLib.GType gtype)
		{
			if (PageReorderedVMCallback == null)
				PageReorderedVMCallback = new PageReorderedVMDelegate (pagereordered_cb);
			OverrideVirtualMethod (gtype, "page_reordered", PageReorderedVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Notebook), ConnectionMethod="OverridePageReordered")]
		protected virtual void OnPageReordered (Gtk.Widget p0, uint p1)
		{
			GLib.Value ret = GLib.Value.Empty;
			unsafe {
				GLib.Value* inst_and_params = stackalloc GLib.Value [3];
				using (inst_and_params[0] = new GLib.Value (this)) {
					using (inst_and_params [1] = new GLib.Value (p0)) {
						using (inst_and_params [2] = new GLib.Value (p1)) {
							g_signal_chain_from_overridden (inst_and_params, ref ret);
						}
					}
				}
			}
		}

		[GLib.Signal("page_reordered")]
		public event Gtk.PageReorderedHandler PageReordered {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "page_reordered", typeof (Gtk.PageReorderedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "page_reordered", typeof (Gtk.PageReorderedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void PageRemovedVMDelegate (IntPtr inst, IntPtr p0, uint p1);

		static PageRemovedVMDelegate PageRemovedVMCallback;

		static void pageremoved_cb (IntPtr inst, IntPtr p0, uint p1)
		{
			try {
				Notebook inst_managed = GLib.Object.GetObject (inst, false) as Notebook;
				inst_managed.OnPageRemoved (GLib.Object.GetObject(p0) as Gtk.Widget, p1);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverridePageRemoved (GLib.GType gtype)
		{
			if (PageRemovedVMCallback == null)
				PageRemovedVMCallback = new PageRemovedVMDelegate (pageremoved_cb);
			OverrideVirtualMethod (gtype, "page_removed", PageRemovedVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Notebook), ConnectionMethod="OverridePageRemoved")]
		protected virtual void OnPageRemoved (Gtk.Widget p0, uint p1)
		{
			GLib.Value ret = GLib.Value.Empty;
			unsafe {
				GLib.Value* inst_and_params = stackalloc GLib.Value [3];
				using (inst_and_params[0] = new GLib.Value (this)) {
					using (inst_and_params [1] = new GLib.Value (p0)) {
						using (inst_and_params [2] = new GLib.Value (p1)) {
							g_signal_chain_from_overridden (inst_and_params, ref ret);
						}
					}
				}
			}
		}

		[GLib.Signal("page_removed")]
		public event Gtk.PageRemovedHandler PageRemoved {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "page_removed", typeof (Gtk.PageRemovedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "page_removed", typeof (Gtk.PageRemovedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void PageAddedVMDelegate (IntPtr inst, IntPtr p0, uint p1);

		static PageAddedVMDelegate PageAddedVMCallback;

		static void pageadded_cb (IntPtr inst, IntPtr p0, uint p1)
		{
			try {
				Notebook inst_managed = GLib.Object.GetObject (inst, false) as Notebook;
				inst_managed.OnPageAdded (GLib.Object.GetObject(p0) as Gtk.Widget, p1);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverridePageAdded (GLib.GType gtype)
		{
			if (PageAddedVMCallback == null)
				PageAddedVMCallback = new PageAddedVMDelegate (pageadded_cb);
			OverrideVirtualMethod (gtype, "page_added", PageAddedVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Notebook), ConnectionMethod="OverridePageAdded")]
		protected virtual void OnPageAdded (Gtk.Widget p0, uint p1)
		{
			GLib.Value ret = GLib.Value.Empty;
			unsafe {
				GLib.Value* inst_and_params = stackalloc GLib.Value [3];
				using (inst_and_params[0] = new GLib.Value (this)) {
					using (inst_and_params [1] = new GLib.Value (p0)) {
						using (inst_and_params [2] = new GLib.Value (p1)) {
							g_signal_chain_from_overridden (inst_and_params, ref ret);
						}
					}
				}
			}
		}

		[GLib.Signal("page_added")]
		public event Gtk.PageAddedHandler PageAdded {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "page_added", typeof (Gtk.PageAddedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "page_added", typeof (Gtk.PageAddedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr CreateWindowVMDelegate (IntPtr notebook, IntPtr page, int x, int y);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_notebook_override_create_window (IntPtr gtype, CreateWindowVMDelegate cb);

		static CreateWindowVMDelegate CreateWindowVMCallback;

		static IntPtr createwindow_cb (IntPtr notebook, IntPtr page, int x, int y)
		{
			try {
				Notebook notebook_managed = GLib.Object.GetObject (notebook, false) as Notebook;
				Gtk.Notebook raw_ret = notebook_managed.OnCreateWindow (GLib.Object.GetObject(page) as Gtk.Widget, x, y);
				return raw_ret == null ? IntPtr.Zero : raw_ret.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideCreateWindow (GLib.GType gtype)
		{
			if (CreateWindowVMCallback == null)
				CreateWindowVMCallback = new CreateWindowVMDelegate (createwindow_cb);
			gtksharp_notebook_override_create_window (gtype.Val, CreateWindowVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtksharp_notebook_base_create_window (IntPtr notebook, IntPtr page, int x, int y);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Notebook), ConnectionMethod="OverrideCreateWindow")]
		protected virtual Gtk.Notebook OnCreateWindow (Gtk.Widget page, int x, int y)
		{
			Gtk.Application.AssertMainThread();
			IntPtr __ret = gtksharp_notebook_base_create_window (Handle, page == null ? IntPtr.Zero : page.Handle, x, y);
			return GLib.Object.GetObject(__ret) as Gtk.Notebook;
		}

		[GLib.Signal("create_window")]
		public event Gtk.CreateWindowHandler CreateWindow {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "create_window", typeof (Gtk.CreateWindowArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "create_window", typeof (Gtk.CreateWindowArgs));
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_notebook_append_page(IntPtr raw, IntPtr child, IntPtr tab_label);

		public int AppendPage(Gtk.Widget child, Gtk.Widget tab_label) {
			Gtk.Application.AssertMainThread();
			int raw_ret = gtk_notebook_append_page(Handle, child == null ? IntPtr.Zero : child.Handle, tab_label == null ? IntPtr.Zero : tab_label.Handle);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_notebook_append_page_menu(IntPtr raw, IntPtr child, IntPtr tab_label, IntPtr menu_label);

		public int AppendPageMenu(Gtk.Widget child, Gtk.Widget tab_label, Gtk.Widget menu_label) {
			Gtk.Application.AssertMainThread();
			int raw_ret = gtk_notebook_append_page_menu(Handle, child == null ? IntPtr.Zero : child.Handle, tab_label == null ? IntPtr.Zero : tab_label.Handle, menu_label == null ? IntPtr.Zero : menu_label.Handle);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_notebook_get_current_page(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_notebook_set_current_page(IntPtr raw, int page_num);

		public int CurrentPage { 
			get {
				int raw_ret = gtk_notebook_get_current_page(Handle);
				int ret = raw_ret;
				return ret;
			}
			set {
				Gtk.Application.AssertMainThread();
				gtk_notebook_set_current_page(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_notebook_get_menu_label(IntPtr raw, IntPtr child);

		public Gtk.Widget GetMenuLabel(Gtk.Widget child) {
			Gtk.Application.AssertMainThread();
			IntPtr raw_ret = gtk_notebook_get_menu_label(Handle, child == null ? IntPtr.Zero : child.Handle);
			Gtk.Widget ret = GLib.Object.GetObject(raw_ret) as Gtk.Widget;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_notebook_get_menu_label_text(IntPtr raw, IntPtr child);

		public string GetMenuLabelText(Gtk.Widget child) {
			Gtk.Application.AssertMainThread();
			IntPtr raw_ret = gtk_notebook_get_menu_label_text(Handle, child == null ? IntPtr.Zero : child.Handle);
			string ret = GLib.Marshaller.Utf8PtrToString (raw_ret);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_notebook_get_n_pages(IntPtr raw);

		public int NPages { 
			get {
				int raw_ret = gtk_notebook_get_n_pages(Handle);
				int ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_notebook_get_nth_page(IntPtr raw, int page_num);

		public Gtk.Widget GetNthPage(int page_num) {
			Gtk.Application.AssertMainThread();
			IntPtr raw_ret = gtk_notebook_get_nth_page(Handle, page_num);
			Gtk.Widget ret = GLib.Object.GetObject(raw_ret) as Gtk.Widget;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_notebook_get_tab_detachable(IntPtr raw, IntPtr child);

		public bool GetTabDetachable(Gtk.Widget child) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_notebook_get_tab_detachable(Handle, child == null ? IntPtr.Zero : child.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_notebook_get_tab_label(IntPtr raw, IntPtr child);

		public Gtk.Widget GetTabLabel(Gtk.Widget child) {
			Gtk.Application.AssertMainThread();
			IntPtr raw_ret = gtk_notebook_get_tab_label(Handle, child == null ? IntPtr.Zero : child.Handle);
			Gtk.Widget ret = GLib.Object.GetObject(raw_ret) as Gtk.Widget;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_notebook_get_tab_label_text(IntPtr raw, IntPtr child);

		public string GetTabLabelText(Gtk.Widget child) {
			Gtk.Application.AssertMainThread();
			IntPtr raw_ret = gtk_notebook_get_tab_label_text(Handle, child == null ? IntPtr.Zero : child.Handle);
			string ret = GLib.Marshaller.Utf8PtrToString (raw_ret);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_notebook_get_tab_reorderable(IntPtr raw, IntPtr child);

		public bool GetTabReorderable(Gtk.Widget child) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_notebook_get_tab_reorderable(Handle, child == null ? IntPtr.Zero : child.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_notebook_get_type();

		static GLib.GType _gtype = new GLib.GType (gtk_notebook_get_type());
		public static new GLib.GType GType { 
			get {
								return _gtype;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_notebook_insert_page(IntPtr raw, IntPtr child, IntPtr tab_label, int position);

		public int InsertPage(Gtk.Widget child, Gtk.Widget tab_label, int position) {
			Gtk.Application.AssertMainThread();
			int raw_ret = gtk_notebook_insert_page(Handle, child == null ? IntPtr.Zero : child.Handle, tab_label == null ? IntPtr.Zero : tab_label.Handle, position);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_notebook_insert_page_menu(IntPtr raw, IntPtr child, IntPtr tab_label, IntPtr menu_label, int position);

		public int InsertPageMenu(Gtk.Widget child, Gtk.Widget tab_label, Gtk.Widget menu_label, int position) {
			Gtk.Application.AssertMainThread();
			int raw_ret = gtk_notebook_insert_page_menu(Handle, child == null ? IntPtr.Zero : child.Handle, tab_label == null ? IntPtr.Zero : tab_label.Handle, menu_label == null ? IntPtr.Zero : menu_label.Handle, position);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_notebook_next_page(IntPtr raw);

		public void NextPage() {
			gtk_notebook_next_page(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_notebook_popup_disable(IntPtr raw);

		public void PopupDisable() {
			gtk_notebook_popup_disable(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_notebook_popup_enable(IntPtr raw);

		public void PopupEnable() {
			gtk_notebook_popup_enable(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_notebook_prepend_page(IntPtr raw, IntPtr child, IntPtr tab_label);

		public int PrependPage(Gtk.Widget child, Gtk.Widget tab_label) {
			Gtk.Application.AssertMainThread();
			int raw_ret = gtk_notebook_prepend_page(Handle, child == null ? IntPtr.Zero : child.Handle, tab_label == null ? IntPtr.Zero : tab_label.Handle);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_notebook_prepend_page_menu(IntPtr raw, IntPtr child, IntPtr tab_label, IntPtr menu_label);

		public int PrependPageMenu(Gtk.Widget child, Gtk.Widget tab_label, Gtk.Widget menu_label) {
			Gtk.Application.AssertMainThread();
			int raw_ret = gtk_notebook_prepend_page_menu(Handle, child == null ? IntPtr.Zero : child.Handle, tab_label == null ? IntPtr.Zero : tab_label.Handle, menu_label == null ? IntPtr.Zero : menu_label.Handle);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_notebook_prev_page(IntPtr raw);

		public void PrevPage() {
			gtk_notebook_prev_page(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_notebook_query_tab_label_packing(IntPtr raw, IntPtr child, out bool expand, out bool fill, out int pack_type);

		public void QueryTabLabelPacking(Gtk.Widget child, out bool expand, out bool fill, out Gtk.PackType pack_type) {
			Gtk.Application.AssertMainThread();
			int native_pack_type;
			gtk_notebook_query_tab_label_packing(Handle, child == null ? IntPtr.Zero : child.Handle, out expand, out fill, out native_pack_type);
			pack_type = (Gtk.PackType) native_pack_type;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_notebook_remove_page(IntPtr raw, int page_num);

		public void RemovePage(int page_num) {
			Gtk.Application.AssertMainThread();
			gtk_notebook_remove_page(Handle, page_num);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_notebook_reorder_child(IntPtr raw, IntPtr child, int position);

		public void ReorderChild(Gtk.Widget child, int position) {
			Gtk.Application.AssertMainThread();
			gtk_notebook_reorder_child(Handle, child == null ? IntPtr.Zero : child.Handle, position);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_notebook_set_homogeneous_tabs(IntPtr raw, bool homogeneous);

		[Obsolete]
		public bool HomogeneousTabs { 
			set {
				Gtk.Application.AssertMainThread();
				gtk_notebook_set_homogeneous_tabs(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_notebook_set_menu_label(IntPtr raw, IntPtr child, IntPtr menu_label);

		public void SetMenuLabel(Gtk.Widget child, Gtk.Widget menu_label) {
			Gtk.Application.AssertMainThread();
			gtk_notebook_set_menu_label(Handle, child == null ? IntPtr.Zero : child.Handle, menu_label == null ? IntPtr.Zero : menu_label.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_notebook_set_menu_label_text(IntPtr raw, IntPtr child, IntPtr menu_text);

		public void SetMenuLabelText(Gtk.Widget child, string menu_text) {
			Gtk.Application.AssertMainThread();
			IntPtr native_menu_text = GLib.Marshaller.StringToPtrGStrdup (menu_text);
			gtk_notebook_set_menu_label_text(Handle, child == null ? IntPtr.Zero : child.Handle, native_menu_text);
			GLib.Marshaller.Free (native_menu_text);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_notebook_set_tab_detachable(IntPtr raw, IntPtr child, bool detachable);

		public void SetTabDetachable(Gtk.Widget child, bool detachable) {
			Gtk.Application.AssertMainThread();
			gtk_notebook_set_tab_detachable(Handle, child == null ? IntPtr.Zero : child.Handle, detachable);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_notebook_set_tab_label(IntPtr raw, IntPtr child, IntPtr tab_label);

		public void SetTabLabel(Gtk.Widget child, Gtk.Widget tab_label) {
			Gtk.Application.AssertMainThread();
			gtk_notebook_set_tab_label(Handle, child == null ? IntPtr.Zero : child.Handle, tab_label == null ? IntPtr.Zero : tab_label.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_notebook_set_tab_label_packing(IntPtr raw, IntPtr child, bool expand, bool fill, int pack_type);

		public void SetTabLabelPacking(Gtk.Widget child, bool expand, bool fill, Gtk.PackType pack_type) {
			Gtk.Application.AssertMainThread();
			gtk_notebook_set_tab_label_packing(Handle, child == null ? IntPtr.Zero : child.Handle, expand, fill, (int) pack_type);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_notebook_set_tab_label_text(IntPtr raw, IntPtr child, IntPtr tab_text);

		public void SetTabLabelText(Gtk.Widget child, string tab_text) {
			Gtk.Application.AssertMainThread();
			IntPtr native_tab_text = GLib.Marshaller.StringToPtrGStrdup (tab_text);
			gtk_notebook_set_tab_label_text(Handle, child == null ? IntPtr.Zero : child.Handle, native_tab_text);
			GLib.Marshaller.Free (native_tab_text);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_notebook_set_tab_reorderable(IntPtr raw, IntPtr child, bool reorderable);

		public void SetTabReorderable(Gtk.Widget child, bool reorderable) {
			Gtk.Application.AssertMainThread();
			gtk_notebook_set_tab_reorderable(Handle, child == null ? IntPtr.Zero : child.Handle, reorderable);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_notebook_set_window_creation_hook(GtkSharp.NotebookWindowCreationFuncNative func, IntPtr data, GLib.DestroyNotify destroy);

		public static Gtk.NotebookWindowCreationFunc WindowCreationHook { 
			set {
				Gtk.Application.AssertMainThread();
				IntPtr data;
				GLib.DestroyNotify destroy;
				if (value == null) {
					data = IntPtr.Zero;
					destroy = null;
				} else {
					data = (IntPtr) GCHandle.Alloc (value);
					destroy = GLib.DestroyHelper.NotifyHandler;
				}
				gtk_notebook_set_window_creation_hook((value == null) ? null : GtkSharp.NotebookWindowCreationFuncWrapper.NativeDelegate, data, destroy);
			}
		}

#endregion
#region Customized extensions
#line 1 "Notebook.custom"
// Notebook.custom - customization for Gtk.Notebook
//
// Authors: Xavier Amado (xavier@blackbloodstudios.com)
//          Mike Kestner (mkestner@ximian.com)
//
// Copyright (c) 2004 Novel, Inc.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of version 2 of the Lesser GNU General 
// Public License as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this program; if not, write to the
// Free Software Foundation, Inc., 59 Temple Place - Suite 330,
// Boston, MA 02111-1307, USA.


public Widget CurrentPageWidget {
        get {
                return GetNthPage (CurrentPage);
        }
}       

[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
static extern int gtk_notebook_page_num (IntPtr handle, IntPtr child);

public int PageNum (Widget child)
{
	return gtk_notebook_page_num (Handle, child.Handle);
}

#endregion
	}

	internal class NotebookAttribute : GLib.GTypeTypeAttribute {
		[DllImport ("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_notebook_get_type ();

		private static GLib.GType _gtype = new GLib.GType (gtk_notebook_get_type ());
		public static GLib.GType GType { get { return _gtype; } }
		public override GLib.GType Type { get { return _gtype; } }

	}
}
