// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gtk {

	using System;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public class CellEditableAdapter : GLib.GInterfaceAdapter, Gtk.CellEditable {

		static CellEditableIface iface;

		struct CellEditableIface {
			public IntPtr gtype;
			public IntPtr itype;

			public IntPtr editing_done;
			public IntPtr remove_widget;
			public StartEditingDelegate start_editing;
		}

		static CellEditableAdapter ()
		{
			GLib.GType.Register (_gtype, typeof(CellEditableAdapter));
			iface.start_editing = new StartEditingDelegate (StartEditingCallback);
		}


		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void StartEditingDelegate (IntPtr cell_editable, IntPtr evnt);

		static void StartEditingCallback (IntPtr cell_editable, IntPtr evnt)
		{
			try {
				Gtk.CellEditableImplementor __obj = GLib.Object.GetObject (cell_editable, false) as Gtk.CellEditableImplementor;
				__obj.StartEditing (Gdk.Event.GetEvent (evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}
		static void Initialize (IntPtr ifaceptr, IntPtr data)
		{
			CellEditableIface native_iface = Marshal.PtrToStructure<CellEditableIface> (ifaceptr);
			native_iface.start_editing = iface.start_editing;
			Marshal.StructureToPtr<CellEditableIface> (native_iface, ifaceptr, false);
			GCHandle gch = (GCHandle) data;
			gch.Free ();
		}

		public CellEditableAdapter ()
		{
			InitHandler = new GLib.GInterfaceInitHandler (Initialize);
		}

		CellEditableImplementor implementor;

		public CellEditableAdapter (CellEditableImplementor implementor)
		{
			if (implementor == null)
				throw new ArgumentNullException ("implementor");
			this.implementor = implementor;
		}

		public CellEditableAdapter (IntPtr handle)
		{
			this.handle = handle;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_cell_editable_get_type();

		private static GLib.GType _gtype = new GLib.GType (gtk_cell_editable_get_type ());

		public override GLib.GType GType {
			get {
				return _gtype;
			}
		}

		IntPtr handle;
		public override IntPtr Handle {
			get {
				if (handle != IntPtr.Zero)
					return handle;
				return implementor == null ? IntPtr.Zero : implementor.Handle;
			}
		}

		public static CellEditable GetObject (IntPtr handle, bool owned)
		{
			GLib.Object obj = GLib.Object.GetObject (handle, owned);
			return GetObject (obj);
		}

		public static CellEditable GetObject (GLib.Object obj)
		{
			if (obj == null)
				return null;
			else if (obj is CellEditableImplementor)
				return new CellEditableAdapter (obj as CellEditableImplementor);
			else if (obj as CellEditable == null)
				return new CellEditableAdapter (obj.Handle);
			else
				return obj as CellEditable;
		}

		public CellEditableImplementor Implementor {
			get {
				return implementor;
			}
		}

		[GLib.Signal("editing_done")]
		public event System.EventHandler EditingDone {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (GLib.Object.GetObject (Handle), "editing_done");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (GLib.Object.GetObject (Handle), "editing_done");
				sig.RemoveDelegate (value);
			}
		}

		[GLib.Signal("remove_widget")]
		public event System.EventHandler WidgetRemoved {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (GLib.Object.GetObject (Handle), "remove_widget");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (GLib.Object.GetObject (Handle), "remove_widget");
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_cell_editable_editing_done(IntPtr raw);

		public void FinishEditing() {
			gtk_cell_editable_editing_done(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_cell_editable_remove_widget(IntPtr raw);

		public void RemoveWidget() {
			gtk_cell_editable_remove_widget(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_cell_editable_start_editing(IntPtr raw, IntPtr evnt);

		public void StartEditing(Gdk.Event evnt) {
			Gtk.Application.AssertMainThread();
			gtk_cell_editable_start_editing(Handle, evnt == null ? IntPtr.Zero : evnt.Handle);
		}

#endregion
	}
}
