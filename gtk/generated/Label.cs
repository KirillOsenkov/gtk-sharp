// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gtk {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	[Label]
	public class Label : Gtk.Misc {

		[Obsolete]
		protected Label(GLib.GType gtype) : base(gtype) {}
		public Label(IntPtr raw) : base(raw) {}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_label_new(IntPtr str);

		public static Label New(string str)
		{
			Gtk.Application.AssertMainThread();
			IntPtr native_str = GLib.Marshaller.StringToPtrGStrdup (str);
			Label result = new Label (gtk_label_new(native_str));
			GLib.Marshaller.Free (native_str);
			return result;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_label_new_with_mnemonic(IntPtr str);

		public Label (string str) : base (IntPtr.Zero)
		{
			if (GetType () != typeof (Label)) {
				Gtk.Application.AssertMainThread();
				unsafe {
					var vals = stackalloc GLib.Value[1];
					var names = stackalloc IntPtr[1];
					names[0] = GLib.Marshaller.StringToPtrGStrdup ("label");
					vals[0] = new GLib.Value (str);
					CreateNativeObject (names, vals, 1);
				}
				return;
			}
			Gtk.Application.AssertMainThread();
			IntPtr native_str = GLib.Marshaller.StringToPtrGStrdup (str);
			owned = true;
			Raw = gtk_label_new_with_mnemonic(native_str);
			GLib.Marshaller.Free (native_str);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_label_get_label(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_label_set_label(IntPtr raw, IntPtr str);

		[GLib.Property ("label")]
		public string LabelProp {
			get  {
				IntPtr raw_ret = gtk_label_get_label(Handle);
				string ret = GLib.Marshaller.Utf8PtrToString (raw_ret);
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				IntPtr native_value = GLib.Marshaller.StringToPtrGStrdup (value);
				gtk_label_set_label(Handle, native_value);
				GLib.Marshaller.Free (native_value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_label_get_attributes(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_label_set_attributes(IntPtr raw, IntPtr attrs);

		[GLib.Property ("attributes")]
		public Pango.AttrList Attributes {
			get  {
				IntPtr raw_ret = gtk_label_get_attributes(Handle);
				Pango.AttrList ret = raw_ret == IntPtr.Zero ? null : (Pango.AttrList) GLib.Opaque.GetOpaque (raw_ret, typeof (Pango.AttrList), false);
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_label_set_attributes(Handle, value == null ? IntPtr.Zero : value.Handle);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_label_get_use_markup(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_label_set_use_markup(IntPtr raw, bool setting);

		[GLib.Property ("use-markup")]
		public bool UseMarkup {
			get  {
				bool raw_ret = gtk_label_get_use_markup(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_label_set_use_markup(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_label_get_use_underline(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_label_set_use_underline(IntPtr raw, bool setting);

		[GLib.Property ("use-underline")]
		public bool UseUnderline {
			get  {
				bool raw_ret = gtk_label_get_use_underline(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_label_set_use_underline(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_label_get_justify(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_label_set_justify(IntPtr raw, int jtype);

		[GLib.Property ("justify")]
		public Gtk.Justification Justify {
			get  {
				int raw_ret = gtk_label_get_justify(Handle);
				Gtk.Justification ret = (Gtk.Justification) raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_label_set_justify(Handle, (int) value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_label_set_pattern(IntPtr raw, IntPtr pattern);

		[GLib.Property ("pattern")]
		public string Pattern {
			set  {
				Gtk.Application.AssertMainThread();
				IntPtr native_value = GLib.Marshaller.StringToPtrGStrdup (value);
				gtk_label_set_pattern(Handle, native_value);
				GLib.Marshaller.Free (native_value);
			}
		}

		[GLib.Property ("wrap")]
		public bool Wrap {
			get {
				using (GLib.Value val = GetProperty ("wrap")) {
					bool ret = (bool) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("wrap", val);
				}
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_label_get_line_wrap_mode(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_label_set_line_wrap_mode(IntPtr raw, int wrap_mode);

		[GLib.Property ("wrap-mode")]
		public Pango.WrapMode LineWrapMode {
			get  {
				int raw_ret = gtk_label_get_line_wrap_mode(Handle);
				Pango.WrapMode ret = (Pango.WrapMode) raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_label_set_line_wrap_mode(Handle, (int) value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_label_get_selectable(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_label_set_selectable(IntPtr raw, bool setting);

		[GLib.Property ("selectable")]
		public bool Selectable {
			get  {
				bool raw_ret = gtk_label_get_selectable(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_label_set_selectable(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern uint gtk_label_get_mnemonic_keyval(IntPtr raw);

		[GLib.Property ("mnemonic-keyval")]
		public uint MnemonicKeyval {
			get  {
				uint raw_ret = gtk_label_get_mnemonic_keyval(Handle);
				uint ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_label_get_mnemonic_widget(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_label_set_mnemonic_widget(IntPtr raw, IntPtr widget);

		[GLib.Property ("mnemonic-widget")]
		public Gtk.Widget MnemonicWidget {
			get  {
				IntPtr raw_ret = gtk_label_get_mnemonic_widget(Handle);
				Gtk.Widget ret = GLib.Object.GetObject(raw_ret) as Gtk.Widget;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_label_set_mnemonic_widget(Handle, value == null ? IntPtr.Zero : value.Handle);
			}
		}

		[GLib.Property ("cursor-position")]
		public int CursorPosition {
			get {
				using (GLib.Value val = GetProperty ("cursor-position")) {
					int ret = (int) val;
					return ret;
				}
			}
		}

		[GLib.Property ("selection-bound")]
		public int SelectionBound {
			get {
				using (GLib.Value val = GetProperty ("selection-bound")) {
					int ret = (int) val;
					return ret;
				}
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_label_get_ellipsize(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_label_set_ellipsize(IntPtr raw, int mode);

		[GLib.Property ("ellipsize")]
		public Pango.EllipsizeMode Ellipsize {
			get  {
				int raw_ret = gtk_label_get_ellipsize(Handle);
				Pango.EllipsizeMode ret = (Pango.EllipsizeMode) raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_label_set_ellipsize(Handle, (int) value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_label_get_width_chars(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_label_set_width_chars(IntPtr raw, int n_chars);

		[GLib.Property ("width-chars")]
		public int WidthChars {
			get  {
				int raw_ret = gtk_label_get_width_chars(Handle);
				int ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_label_set_width_chars(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_label_get_single_line_mode(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_label_set_single_line_mode(IntPtr raw, bool single_line_mode);

		[GLib.Property ("single-line-mode")]
		public bool SingleLineMode {
			get  {
				bool raw_ret = gtk_label_get_single_line_mode(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_label_set_single_line_mode(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern double gtk_label_get_angle(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_label_set_angle(IntPtr raw, double angle);

		[GLib.Property ("angle")]
		public double Angle {
			get  {
				double raw_ret = gtk_label_get_angle(Handle);
				double ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_label_set_angle(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_label_get_max_width_chars(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_label_set_max_width_chars(IntPtr raw, int n_chars);

		[GLib.Property ("max-width-chars")]
		public int MaxWidthChars {
			get  {
				int raw_ret = gtk_label_get_max_width_chars(Handle);
				int ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_label_set_max_width_chars(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_label_get_text(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_label_set_text(IntPtr raw, IntPtr str);

		public string Text {
			get  {
				IntPtr raw_ret = gtk_label_get_text(Handle);
				string ret = GLib.Marshaller.Utf8PtrToString (raw_ret);
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				IntPtr native_value = GLib.Marshaller.StringToPtrGStrdup (value);
				gtk_label_set_text(Handle, native_value);
				GLib.Marshaller.Free (native_value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_label_get_layout(IntPtr raw);

		public Pango.Layout Layout {
			get  {
				IntPtr raw_ret = gtk_label_get_layout(Handle);
				Pango.Layout ret = GLib.Object.GetObject(raw_ret) as Pango.Layout;
				return ret;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void MoveCursorVMDelegate (IntPtr label, int step, int count, bool extend_selection);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_label_override_move_cursor (IntPtr gtype, MoveCursorVMDelegate cb);

		static MoveCursorVMDelegate MoveCursorVMCallback;

		static void movecursor_cb (IntPtr label, int step, int count, bool extend_selection)
		{
			try {
				Label label_managed = GLib.Object.GetObject (label, false) as Label;
				label_managed.OnMoveCursor ((Gtk.MovementStep) step, count, extend_selection);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideMoveCursor (GLib.GType gtype)
		{
			if (MoveCursorVMCallback == null)
				MoveCursorVMCallback = new MoveCursorVMDelegate (movecursor_cb);
			gtksharp_label_override_move_cursor (gtype.Val, MoveCursorVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_label_base_move_cursor (IntPtr label, int step, int count, bool extend_selection);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Label), ConnectionMethod="OverrideMoveCursor")]
		protected virtual void OnMoveCursor (Gtk.MovementStep step, int count, bool extend_selection)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_label_base_move_cursor (Handle, (int) step, count, extend_selection);
		}

		[GLib.Signal("move_cursor")]
		public event Gtk.MoveCursorHandler MoveCursor {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "move_cursor", typeof (Gtk.MoveCursorArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "move_cursor", typeof (Gtk.MoveCursorArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void CopyClipboardVMDelegate (IntPtr label);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_label_override_copy_clipboard (IntPtr gtype, CopyClipboardVMDelegate cb);

		static CopyClipboardVMDelegate CopyClipboardVMCallback;

		static void copyclipboard_cb (IntPtr label)
		{
			try {
				Label label_managed = GLib.Object.GetObject (label, false) as Label;
				label_managed.OnCopyClipboard ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideCopyClipboard (GLib.GType gtype)
		{
			if (CopyClipboardVMCallback == null)
				CopyClipboardVMCallback = new CopyClipboardVMDelegate (copyclipboard_cb);
			gtksharp_label_override_copy_clipboard (gtype.Val, CopyClipboardVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_label_base_copy_clipboard (IntPtr label);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Label), ConnectionMethod="OverrideCopyClipboard")]
		protected virtual void OnCopyClipboard ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_label_base_copy_clipboard (Handle);
		}

		[GLib.Signal("copy_clipboard")]
		public event System.EventHandler CopyClipboard {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "copy_clipboard");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "copy_clipboard");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void PopulatePopupVMDelegate (IntPtr label, IntPtr menu);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_label_override_populate_popup (IntPtr gtype, PopulatePopupVMDelegate cb);

		static PopulatePopupVMDelegate PopulatePopupVMCallback;

		static void populatepopup_cb (IntPtr label, IntPtr menu)
		{
			try {
				Label label_managed = GLib.Object.GetObject (label, false) as Label;
				label_managed.OnPopulatePopup (GLib.Object.GetObject(menu) as Gtk.Menu);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverridePopulatePopup (GLib.GType gtype)
		{
			if (PopulatePopupVMCallback == null)
				PopulatePopupVMCallback = new PopulatePopupVMDelegate (populatepopup_cb);
			gtksharp_label_override_populate_popup (gtype.Val, PopulatePopupVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_label_base_populate_popup (IntPtr label, IntPtr menu);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Label), ConnectionMethod="OverridePopulatePopup")]
		protected virtual void OnPopulatePopup (Gtk.Menu menu)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_label_base_populate_popup (Handle, menu == null ? IntPtr.Zero : menu.Handle);
		}

		[GLib.Signal("populate_popup")]
		public event Gtk.PopulatePopupHandler PopulatePopup {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "populate_popup", typeof (Gtk.PopulatePopupArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "populate_popup", typeof (Gtk.PopulatePopupArgs));
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_label_get(IntPtr raw, out IntPtr str);

		[Obsolete]
		public string Get() {
			string str;
			Gtk.Application.AssertMainThread();
			IntPtr native_str;
			gtk_label_get(Handle, out native_str);
			str = GLib.Marshaller.PtrToStringGFree(native_str);
			return str;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_label_get_layout_offsets(IntPtr raw, out int x, out int y);

		public void GetLayoutOffsets(out int x, out int y) {
			Gtk.Application.AssertMainThread();
			gtk_label_get_layout_offsets(Handle, out x, out y);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_label_get_line_wrap(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_label_set_line_wrap(IntPtr raw, bool wrap);

		public bool LineWrap { 
			get {
				bool raw_ret = gtk_label_get_line_wrap(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set {
				Gtk.Application.AssertMainThread();
				gtk_label_set_line_wrap(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_label_get_selection_bounds(IntPtr raw, out int start, out int end);

		public bool GetSelectionBounds(out int start, out int end) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_label_get_selection_bounds(Handle, out start, out end);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_label_get_type();

		static GLib.GType _gtype = new GLib.GType (gtk_label_get_type());
		public static new GLib.GType GType { 
			get {
								return _gtype;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern uint gtk_label_parse_uline(IntPtr raw, IntPtr str1ng);

		[Obsolete]
		public uint ParseUline(string str1ng) {
			Gtk.Application.AssertMainThread();
			IntPtr native_str1ng = GLib.Marshaller.StringToPtrGStrdup (str1ng);
			uint raw_ret = gtk_label_parse_uline(Handle, native_str1ng);
			uint ret = raw_ret;
			GLib.Marshaller.Free (native_str1ng);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_label_select_region(IntPtr raw, int start_offset, int end_offset);

		public void SelectRegion(int start_offset, int end_offset) {
			Gtk.Application.AssertMainThread();
			gtk_label_select_region(Handle, start_offset, end_offset);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_label_set_markup(IntPtr raw, IntPtr str);

		public string Markup { 
			set {
				Gtk.Application.AssertMainThread();
				IntPtr native_value = GLib.Marshaller.StringToPtrGStrdup (value);
				gtk_label_set_markup(Handle, native_value);
				GLib.Marshaller.Free (native_value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_label_set_markup_with_mnemonic(IntPtr raw, IntPtr str);

		public string MarkupWithMnemonic { 
			set {
				Gtk.Application.AssertMainThread();
				IntPtr native_value = GLib.Marshaller.StringToPtrGStrdup (value);
				gtk_label_set_markup_with_mnemonic(Handle, native_value);
				GLib.Marshaller.Free (native_value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_label_set_text_with_mnemonic(IntPtr raw, IntPtr str);

		public string TextWithMnemonic { 
			set {
				Gtk.Application.AssertMainThread();
				IntPtr native_value = GLib.Marshaller.StringToPtrGStrdup (value);
				gtk_label_set_text_with_mnemonic(Handle, native_value);
				GLib.Marshaller.Free (native_value);
			}
		}

#endregion
#region Customized extensions
#line 1 "Label.custom"
//
// Gtk.Label.custom
//
// This code is inserted after the automatically generated code.
//
//  Author: John Luke  <jluke@cfl.rr.com>
//
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of version 2 of the Lesser GNU General 
// Public License as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this program; if not, write to the
// Free Software Foundation, Inc., 59 Temple Place - Suite 330,
// Boston, MA 02111-1307, USA.


		public Label () : this (null) {}

#endregion
	}

	internal class LabelAttribute : GLib.GTypeTypeAttribute {
		[DllImport ("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_label_get_type ();

		private static GLib.GType _gtype = new GLib.GType (gtk_label_get_type ());
		public static GLib.GType GType { get { return _gtype; } }
		public override GLib.GType Type { get { return _gtype; } }

	}
}
