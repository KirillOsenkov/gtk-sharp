// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gtk {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	[Paned]
	public class Paned : Gtk.Container {

		[Obsolete]
		protected Paned(GLib.GType gtype) : base(gtype) {}
		public Paned(IntPtr raw) : base(raw) {}

		protected Paned() : base(IntPtr.Zero)
		{
			CreateNativeObject (Array.Empty<IntPtr> (), Array.Empty<GLib.Value> (), 0);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_paned_get_position(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_paned_set_position(IntPtr raw, int position);

		[GLib.Property ("position")]
		public int Position {
			get  {
				int raw_ret = gtk_paned_get_position(Handle);
				int ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_paned_set_position(Handle, value);
			}
		}

		[GLib.Property ("position-set")]
		public bool PositionSet {
			get {
				using (GLib.Value val = GetProperty ("position-set")) {
					bool ret = (bool) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("position-set", val);
				}
			}
		}

		[GLib.Property ("min-position")]
		public int MinPosition {
			get {
				using (GLib.Value val = GetProperty ("min-position")) {
					int ret = (int) val;
					return ret;
				}
			}
		}

		[GLib.Property ("max-position")]
		public int MaxPosition {
			get {
				using (GLib.Value val = GetProperty ("max-position")) {
					int ret = (int) val;
					return ret;
				}
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_paned_get_child1(IntPtr raw);

		public Gtk.Widget Child1 {
			get  {
				IntPtr raw_ret = gtk_paned_get_child1(Handle);
				Gtk.Widget ret = GLib.Object.GetObject(raw_ret) as Gtk.Widget;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_paned_get_child2(IntPtr raw);

		public Gtk.Widget Child2 {
			get  {
				IntPtr raw_ret = gtk_paned_get_child2(Handle);
				Gtk.Widget ret = GLib.Object.GetObject(raw_ret) as Gtk.Widget;
				return ret;
			}
		}

		public class PanedChild : Gtk.Container.ContainerChild {
			protected internal PanedChild (Gtk.Container parent, Gtk.Widget child) : base (parent, child) {}

			[Gtk.ChildProperty ("resize")]
			public bool Resize {
				get {
					using (GLib.Value val = parent.ChildGetProperty (child, "resize")) {
						bool ret = (bool) val;
						return ret;
					}
				}
				set {
					using (GLib.Value val = new GLib.Value(value)) {
						parent.ChildSetProperty(child, "resize", val);
					}
				}
			}

			[Gtk.ChildProperty ("shrink")]
			public bool Shrink {
				get {
					using (GLib.Value val = parent.ChildGetProperty (child, "shrink")) {
						bool ret = (bool) val;
						return ret;
					}
				}
				set {
					using (GLib.Value val = new GLib.Value(value)) {
						parent.ChildSetProperty(child, "shrink", val);
					}
				}
			}

		}

		public override Gtk.Container.ContainerChild this [Gtk.Widget child] {
			get {
				return new PanedChild (this, child);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool CycleChildFocusVMDelegate (IntPtr paned, bool reverse);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_paned_override_cycle_child_focus (IntPtr gtype, CycleChildFocusVMDelegate cb);

		static CycleChildFocusVMDelegate CycleChildFocusVMCallback;

		static bool cyclechildfocus_cb (IntPtr paned, bool reverse)
		{
			try {
				Paned paned_managed = GLib.Object.GetObject (paned, false) as Paned;
				return paned_managed.OnCycleChildFocus (reverse);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideCycleChildFocus (GLib.GType gtype)
		{
			if (CycleChildFocusVMCallback == null)
				CycleChildFocusVMCallback = new CycleChildFocusVMDelegate (cyclechildfocus_cb);
			gtksharp_paned_override_cycle_child_focus (gtype.Val, CycleChildFocusVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_paned_base_cycle_child_focus (IntPtr paned, bool reverse);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Paned), ConnectionMethod="OverrideCycleChildFocus")]
		protected virtual bool OnCycleChildFocus (bool reverse)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_paned_base_cycle_child_focus (Handle, reverse);
			return __ret;
		}

		[GLib.Signal("cycle_child_focus")]
		public event Gtk.CycleChildFocusHandler CycleChildFocus {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "cycle_child_focus", typeof (Gtk.CycleChildFocusArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "cycle_child_focus", typeof (Gtk.CycleChildFocusArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool ToggleHandleFocusVMDelegate (IntPtr paned);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_paned_override_toggle_handle_focus (IntPtr gtype, ToggleHandleFocusVMDelegate cb);

		static ToggleHandleFocusVMDelegate ToggleHandleFocusVMCallback;

		static bool togglehandlefocus_cb (IntPtr paned)
		{
			try {
				Paned paned_managed = GLib.Object.GetObject (paned, false) as Paned;
				return paned_managed.OnToggleHandleFocus ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideToggleHandleFocus (GLib.GType gtype)
		{
			if (ToggleHandleFocusVMCallback == null)
				ToggleHandleFocusVMCallback = new ToggleHandleFocusVMDelegate (togglehandlefocus_cb);
			gtksharp_paned_override_toggle_handle_focus (gtype.Val, ToggleHandleFocusVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_paned_base_toggle_handle_focus (IntPtr paned);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Paned), ConnectionMethod="OverrideToggleHandleFocus")]
		protected virtual bool OnToggleHandleFocus ()
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_paned_base_toggle_handle_focus (Handle);
			return __ret;
		}

		[GLib.Signal("toggle_handle_focus")]
		public event Gtk.ToggleHandleFocusHandler ToggleHandleFocus {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "toggle_handle_focus", typeof (Gtk.ToggleHandleFocusArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "toggle_handle_focus", typeof (Gtk.ToggleHandleFocusArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool MoveHandleVMDelegate (IntPtr paned, int scroll);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_paned_override_move_handle (IntPtr gtype, MoveHandleVMDelegate cb);

		static MoveHandleVMDelegate MoveHandleVMCallback;

		static bool movehandle_cb (IntPtr paned, int scroll)
		{
			try {
				Paned paned_managed = GLib.Object.GetObject (paned, false) as Paned;
				return paned_managed.OnMoveHandle ((Gtk.ScrollType) scroll);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideMoveHandle (GLib.GType gtype)
		{
			if (MoveHandleVMCallback == null)
				MoveHandleVMCallback = new MoveHandleVMDelegate (movehandle_cb);
			gtksharp_paned_override_move_handle (gtype.Val, MoveHandleVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_paned_base_move_handle (IntPtr paned, int scroll);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Paned), ConnectionMethod="OverrideMoveHandle")]
		protected virtual bool OnMoveHandle (Gtk.ScrollType scroll)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_paned_base_move_handle (Handle, (int) scroll);
			return __ret;
		}

		[GLib.Signal("move_handle")]
		public event Gtk.MoveHandleHandler MoveHandle {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "move_handle", typeof (Gtk.MoveHandleArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "move_handle", typeof (Gtk.MoveHandleArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool CycleHandleFocusVMDelegate (IntPtr paned, bool reverse);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_paned_override_cycle_handle_focus (IntPtr gtype, CycleHandleFocusVMDelegate cb);

		static CycleHandleFocusVMDelegate CycleHandleFocusVMCallback;

		static bool cyclehandlefocus_cb (IntPtr paned, bool reverse)
		{
			try {
				Paned paned_managed = GLib.Object.GetObject (paned, false) as Paned;
				return paned_managed.OnCycleHandleFocus (reverse);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideCycleHandleFocus (GLib.GType gtype)
		{
			if (CycleHandleFocusVMCallback == null)
				CycleHandleFocusVMCallback = new CycleHandleFocusVMDelegate (cyclehandlefocus_cb);
			gtksharp_paned_override_cycle_handle_focus (gtype.Val, CycleHandleFocusVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_paned_base_cycle_handle_focus (IntPtr paned, bool reverse);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Paned), ConnectionMethod="OverrideCycleHandleFocus")]
		protected virtual bool OnCycleHandleFocus (bool reverse)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_paned_base_cycle_handle_focus (Handle, reverse);
			return __ret;
		}

		[GLib.Signal("cycle_handle_focus")]
		public event Gtk.CycleHandleFocusHandler CycleHandleFocus {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "cycle_handle_focus", typeof (Gtk.CycleHandleFocusArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "cycle_handle_focus", typeof (Gtk.CycleHandleFocusArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool AcceptPositionVMDelegate (IntPtr paned);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_paned_override_accept_position (IntPtr gtype, AcceptPositionVMDelegate cb);

		static AcceptPositionVMDelegate AcceptPositionVMCallback;

		static bool acceptposition_cb (IntPtr paned)
		{
			try {
				Paned paned_managed = GLib.Object.GetObject (paned, false) as Paned;
				return paned_managed.OnAcceptPosition ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideAcceptPosition (GLib.GType gtype)
		{
			if (AcceptPositionVMCallback == null)
				AcceptPositionVMCallback = new AcceptPositionVMDelegate (acceptposition_cb);
			gtksharp_paned_override_accept_position (gtype.Val, AcceptPositionVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_paned_base_accept_position (IntPtr paned);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Paned), ConnectionMethod="OverrideAcceptPosition")]
		protected virtual bool OnAcceptPosition ()
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_paned_base_accept_position (Handle);
			return __ret;
		}

		[GLib.Signal("accept_position")]
		public event Gtk.AcceptPositionHandler AcceptPosition {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "accept_position", typeof (Gtk.AcceptPositionArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "accept_position", typeof (Gtk.AcceptPositionArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool CancelPositionVMDelegate (IntPtr paned);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_paned_override_cancel_position (IntPtr gtype, CancelPositionVMDelegate cb);

		static CancelPositionVMDelegate CancelPositionVMCallback;

		static bool cancelposition_cb (IntPtr paned)
		{
			try {
				Paned paned_managed = GLib.Object.GetObject (paned, false) as Paned;
				return paned_managed.OnCancelPosition ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideCancelPosition (GLib.GType gtype)
		{
			if (CancelPositionVMCallback == null)
				CancelPositionVMCallback = new CancelPositionVMDelegate (cancelposition_cb);
			gtksharp_paned_override_cancel_position (gtype.Val, CancelPositionVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_paned_base_cancel_position (IntPtr paned);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Paned), ConnectionMethod="OverrideCancelPosition")]
		protected virtual bool OnCancelPosition ()
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_paned_base_cancel_position (Handle);
			return __ret;
		}

		[GLib.Signal("cancel_position")]
		public event Gtk.CancelPositionHandler CancelPosition {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "cancel_position", typeof (Gtk.CancelPositionArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "cancel_position", typeof (Gtk.CancelPositionArgs));
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_paned_add1(IntPtr raw, IntPtr child);

		public void Add1(Gtk.Widget child) {
			Gtk.Application.AssertMainThread();
			gtk_paned_add1(Handle, child == null ? IntPtr.Zero : child.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_paned_add2(IntPtr raw, IntPtr child);

		public void Add2(Gtk.Widget child) {
			Gtk.Application.AssertMainThread();
			gtk_paned_add2(Handle, child == null ? IntPtr.Zero : child.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_paned_compute_position(IntPtr raw, int allocation, int child1_req, int child2_req);

		[Obsolete]
		public void ComputePosition(int allocation, int child1_req, int child2_req) {
			Gtk.Application.AssertMainThread();
			gtk_paned_compute_position(Handle, allocation, child1_req, child2_req);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_paned_get_type();

		static GLib.GType _gtype = new GLib.GType (gtk_paned_get_type());
		public static new GLib.GType GType { 
			get {
								return _gtype;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_paned_pack1(IntPtr raw, IntPtr child, bool resize, bool shrink);

		public void Pack1(Gtk.Widget child, bool resize, bool shrink) {
			Gtk.Application.AssertMainThread();
			gtk_paned_pack1(Handle, child == null ? IntPtr.Zero : child.Handle, resize, shrink);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_paned_pack2(IntPtr raw, IntPtr child, bool resize, bool shrink);

		public void Pack2(Gtk.Widget child, bool resize, bool shrink) {
			Gtk.Application.AssertMainThread();
			gtk_paned_pack2(Handle, child == null ? IntPtr.Zero : child.Handle, resize, shrink);
		}

#endregion
	}

	internal class PanedAttribute : GLib.GTypeTypeAttribute {
		[DllImport ("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_paned_get_type ();

		private static GLib.GType _gtype = new GLib.GType (gtk_paned_get_type ());
		public static GLib.GType GType { get { return _gtype; } }
		public override GLib.GType Type { get { return _gtype; } }

	}
}
