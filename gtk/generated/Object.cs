// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gtk {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	[Object]
	public class Object : GLib.InitiallyUnowned {

		[Obsolete]
		protected Object(GLib.GType gtype) : base(gtype) {}
		public Object(IntPtr raw) : base(raw) {}

		protected Object() : base(IntPtr.Zero)
		{
			CreateNativeObject (Array.Empty<IntPtr> (), Array.Empty<GLib.Value> (), 0);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_object_get_user_data(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_object_set_user_data(IntPtr raw, IntPtr data);

		[Obsolete]
		[GLib.Property ("user-data")]
		public IntPtr UserData {
			get  {
				IntPtr raw_ret = gtk_object_get_user_data(Handle);
				IntPtr ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_object_set_user_data(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_object_add_arg_type(IntPtr arg_name, IntPtr arg_type, uint arg_flags, uint arg_id);

		[Obsolete]
		public static void AddArgType(string arg_name, GLib.GType arg_type, uint arg_flags, uint arg_id) {
			Gtk.Application.AssertMainThread();
			IntPtr native_arg_name = GLib.Marshaller.StringToPtrGStrdup (arg_name);
			gtk_object_add_arg_type(native_arg_name, arg_type.Val, arg_flags, arg_id);
			GLib.Marshaller.Free (native_arg_name);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_object_get_data(IntPtr raw, IntPtr key);

		[Obsolete]
		public IntPtr GetData(string key) {
			Gtk.Application.AssertMainThread();
			IntPtr native_key = GLib.Marshaller.StringToPtrGStrdup (key);
			IntPtr raw_ret = gtk_object_get_data(Handle, native_key);
			IntPtr ret = raw_ret;
			GLib.Marshaller.Free (native_key);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_object_get_data_by_id(IntPtr raw, int data_id);

		[Obsolete]
		public IntPtr GetDataById(int data_id) {
			Gtk.Application.AssertMainThread();
			IntPtr raw_ret = gtk_object_get_data_by_id(Handle, data_id);
			IntPtr ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_object_get_type();

		static GLib.GType _gtype = new GLib.GType (gtk_object_get_type());
		public static new GLib.GType GType { 
			get {
								return _gtype;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_object_ref(IntPtr raw);

		[Obsolete]
		public Gtk.Object Ref() {
			IntPtr raw_ret = gtk_object_ref(Handle);
			Gtk.Object ret = GLib.Object.GetObject(raw_ret) as Gtk.Object;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_object_remove_data(IntPtr raw, IntPtr key);

		[Obsolete]
		public void RemoveData(string key) {
			Gtk.Application.AssertMainThread();
			IntPtr native_key = GLib.Marshaller.StringToPtrGStrdup (key);
			gtk_object_remove_data(Handle, native_key);
			GLib.Marshaller.Free (native_key);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_object_remove_data_by_id(IntPtr raw, int data_id);

		[Obsolete]
		public void RemoveDataById(int data_id) {
			Gtk.Application.AssertMainThread();
			gtk_object_remove_data_by_id(Handle, data_id);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_object_remove_no_notify(IntPtr raw, IntPtr key);

		[Obsolete]
		public void RemoveNoNotify(string key) {
			Gtk.Application.AssertMainThread();
			IntPtr native_key = GLib.Marshaller.StringToPtrGStrdup (key);
			gtk_object_remove_no_notify(Handle, native_key);
			GLib.Marshaller.Free (native_key);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_object_remove_no_notify_by_id(IntPtr raw, int key_id);

		[Obsolete]
		public void RemoveNoNotifyById(int key_id) {
			Gtk.Application.AssertMainThread();
			gtk_object_remove_no_notify_by_id(Handle, key_id);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_object_set_data(IntPtr raw, IntPtr key, IntPtr data);

		[Obsolete]
		public void SetData(string key, IntPtr data) {
			Gtk.Application.AssertMainThread();
			IntPtr native_key = GLib.Marshaller.StringToPtrGStrdup (key);
			gtk_object_set_data(Handle, native_key, data);
			GLib.Marshaller.Free (native_key);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_object_set_data_by_id(IntPtr raw, int data_id, IntPtr data);

		[Obsolete]
		public void SetDataById(int data_id, IntPtr data) {
			Gtk.Application.AssertMainThread();
			gtk_object_set_data_by_id(Handle, data_id, data);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_object_set_data_by_id_full(IntPtr raw, int data_id, IntPtr data, GtkSharp.DestroyNotifyNative destroy);

		[Obsolete]
		public void SetDataByIdFull(int data_id, IntPtr data, Gtk.DestroyNotify destroy) {
			Gtk.Application.AssertMainThread();
			GtkSharp.DestroyNotifyWrapper destroy_wrapper = new GtkSharp.DestroyNotifyWrapper (destroy);
			GCHandle gch = GCHandle.Alloc (destroy_wrapper);
			gtk_object_set_data_by_id_full(Handle, data_id, data, (destroy_wrapper == null) ? null : GtkSharp.DestroyNotifyWrapper.NativeDelegate);
			gch.Free();
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_object_set_data_full(IntPtr raw, IntPtr key, IntPtr data, GtkSharp.DestroyNotifyNative destroy);

		[Obsolete]
		public void SetDataFull(string key, IntPtr data, Gtk.DestroyNotify destroy) {
			Gtk.Application.AssertMainThread();
			IntPtr native_key = GLib.Marshaller.StringToPtrGStrdup (key);
			GtkSharp.DestroyNotifyWrapper destroy_wrapper = new GtkSharp.DestroyNotifyWrapper (destroy);
			GCHandle gch = GCHandle.Alloc (destroy_wrapper);
			gtk_object_set_data_full(Handle, native_key, data, (destroy_wrapper == null) ? null : GtkSharp.DestroyNotifyWrapper.NativeDelegate);
			GLib.Marshaller.Free (native_key);
			gch.Free();
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_object_sink(IntPtr raw);

		[Obsolete]
		public void Sink() {
			gtk_object_sink(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_object_unref(IntPtr raw);

		[Obsolete]
		public void Unref() {
			gtk_object_unref(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_object_weakref(IntPtr raw, GtkSharp.DestroyNotifyNative notify, IntPtr data);

		[Obsolete]
		public void Weakref(Gtk.DestroyNotify notify) {
			Gtk.Application.AssertMainThread();
			GtkSharp.DestroyNotifyWrapper notify_wrapper = new GtkSharp.DestroyNotifyWrapper (notify);
			GCHandle gch = GCHandle.Alloc (notify_wrapper);
			gtk_object_weakref(Handle, (notify_wrapper == null) ? null : GtkSharp.DestroyNotifyWrapper.NativeDelegate, (IntPtr)gch);
			gch.Free();
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_object_weakunref(IntPtr raw, GtkSharp.DestroyNotifyNative notify, IntPtr data);

		[Obsolete]
		public void Weakunref(Gtk.DestroyNotify notify) {
			Gtk.Application.AssertMainThread();
			GtkSharp.DestroyNotifyWrapper notify_wrapper = new GtkSharp.DestroyNotifyWrapper (notify);
			GCHandle gch = GCHandle.Alloc (notify_wrapper);
			gtk_object_weakunref(Handle, (notify_wrapper == null) ? null : GtkSharp.DestroyNotifyWrapper.NativeDelegate, (IntPtr)gch);
			gch.Free();
		}

#endregion
#region Customized extensions
#line 1 "Object.custom"
// Gtk.Object.custom - Gtk Object class customizations
//
// Author: Mike Kestner <mkestner@novell.com>
//
// Copyright (c) 2002-2003 Mike Kestner
// Copyright (c) 2007 Novell, Inc.
//
// This code is inserted after the automatically generated code.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of version 2 of the Lesser GNU General 
// Public License as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this program; if not, write to the
// Free Software Foundation, Inc., 59 Temple Place - Suite 330,
// Boston, MA 02111-1307, USA.

		static System.Collections.Generic.Dictionary<IntPtr, EventHandler> destroy_handlers;
		static System.Collections.Generic.Dictionary<IntPtr, EventHandler> DestroyHandlers {
			get {
				if (destroy_handlers == null)
					destroy_handlers = new System.Collections.Generic.Dictionary<IntPtr, EventHandler> (IntPtrEqualityComparer.Instance);
				return destroy_handlers;
			}
		}

		private static void OverrideDestroyed (GLib.GType gtype)
		{
			// Do Nothing.  We don't want to hook into the native vtable.
			// We will manually invoke the VM on signal invocation. The signal
			// always raises before the default handler because this signal
			// is RUN_CLEANUP.
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Object), ConnectionMethod="OverrideDestroyed")]
		protected virtual void OnDestroyed ()
		{
			EventHandler handler;
			if (DestroyHandlers.TryGetValue (Handle, out handler)) {
				handler (this, EventArgs.Empty);
				DestroyHandlers.Remove (Handle);
			}
		}

		[GLib.Signal("destroy")]
		public event EventHandler Destroyed {
			add {
				EventHandler handler;
				DestroyHandlers.TryGetValue (Handle, out handler);
				DestroyHandlers [Handle] = (EventHandler)Delegate.Combine (handler, value);
			}
			remove {
				EventHandler handler;
				DestroyHandlers.TryGetValue (Handle, out handler);
				handler = (EventHandler) Delegate.Remove (handler, value);
				if (handler != null)
					DestroyHandlers [Handle] = handler;
				else
					DestroyHandlers.Remove (Handle);
			}
		}

		event EventHandler InternalDestroyed {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "destroy");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "destroy");
				sig.RemoveDelegate (value);
			}
		}

		static void NativeDestroy (object o, EventArgs args)
		{
			Gtk.Object obj = o as Gtk.Object;
			if (obj == null)
				return;
			obj.OnDestroyed ();
			obj.FreeSignals ();
		}
		
		static EventHandler native_destroy_handler;
		static EventHandler NativeDestroyHandler {
			get {
				if (native_destroy_handler == null)
					native_destroy_handler = new EventHandler (NativeDestroy);
				return native_destroy_handler;
			}
		}

		public override void Dispose ()
		{
			// Don't call base.Dispose because it's calling g_object_unref
			// which is done by gtk_object_destroy for Gtk.Object

			//Should line below be uncommented?(but it breaks backward compatiblity)
			//throw new InvalidOperationException("Calling Dispose is invalid for Gtk objects. Call Destroy().");
		}

		protected override IntPtr Raw {
			get {
				return base.Raw;
			}
			set {
				base.Raw = value;
				if (value != IntPtr.Zero)
					InternalDestroyed += NativeDestroyHandler;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
		private static extern void gtk_object_destroy (IntPtr raw);

		public virtual void Destroy ()
		{
			if (Handle == IntPtr.Zero)
				return;
			if (IsFloating)//We have to check or we will increment ref_count
				IsFloating = false;
			gtk_object_destroy (Handle);
			InternalDestroyed -= NativeDestroyHandler;
		}

		[DllImport("gtksharpglue-2", CallingConvention=CallingConvention.Cdecl)]
		private static extern bool gtksharp_object_is_floating (IntPtr raw);

		[DllImport("gtksharpglue-2", CallingConvention=CallingConvention.Cdecl)]
		private static extern bool gtksharp_object_set_floating (IntPtr raw, bool val);

		public bool IsFloating {
			get {
				return gtksharp_object_is_floating (Handle);
			}
			set {
				gtksharp_object_set_floating (Handle, value);
			}
		}


#endregion
	}

	internal class ObjectAttribute : GLib.GTypeTypeAttribute {
		[DllImport ("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_object_get_type ();

		private static GLib.GType _gtype = new GLib.GType (gtk_object_get_type ());
		public static GLib.GType GType { get { return _gtype; } }
		public override GLib.GType Type { get { return _gtype; } }

	}
}
