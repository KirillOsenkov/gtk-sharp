// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gtk {

	using System;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public class TreeModelAdapter : GLib.GInterfaceAdapter, Gtk.TreeModel {

		static TreeModelIface iface;

		struct TreeModelIface {
			public IntPtr gtype;
			public IntPtr itype;

			public IntPtr row_changed;
			public IntPtr row_inserted;
			public IntPtr row_has_child_toggled;
			public IntPtr row_deleted;
			public IntPtr rows_reordered;
			public GetFlagsDelegate get_flags;
			public GetNColumnsDelegate get_n_columns;
			public GetColumnTypeDelegate get_column_type;
			public GetIterDelegate get_iter;
			public GetPathDelegate get_path;
			public GetValueDelegate get_value;
			public IterNextDelegate iter_next;
			public IterChildrenDelegate iter_children;
			public IterHasChildDelegate iter_has_child;
			public IterNChildrenDelegate iter_n_children;
			public IterNthChildDelegate iter_nth_child;
			public IterParentDelegate iter_parent;
			public RefNodeDelegate ref_node;
			public UnrefNodeDelegate unref_node;
		}

		static TreeModelAdapter ()
		{
			GLib.GType.Register (_gtype, typeof(TreeModelAdapter));
			iface.get_flags = new GetFlagsDelegate (GetFlagsCallback);
			iface.get_n_columns = new GetNColumnsDelegate (GetNColumnsCallback);
			iface.get_column_type = new GetColumnTypeDelegate (GetColumnTypeCallback);
			iface.get_iter = new GetIterDelegate (GetIterCallback);
			iface.get_path = new GetPathDelegate (GetPathCallback);
			iface.get_value = new GetValueDelegate (GetValueCallback);
			iface.iter_next = new IterNextDelegate (IterNextCallback);
			iface.iter_children = new IterChildrenDelegate (IterChildrenCallback);
			iface.iter_has_child = new IterHasChildDelegate (IterHasChildCallback);
			iface.iter_n_children = new IterNChildrenDelegate (IterNChildrenCallback);
			iface.iter_nth_child = new IterNthChildDelegate (IterNthChildCallback);
			iface.iter_parent = new IterParentDelegate (IterParentCallback);
			iface.ref_node = new RefNodeDelegate (RefNodeCallback);
			iface.unref_node = new UnrefNodeDelegate (UnrefNodeCallback);
		}


		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate int GetFlagsDelegate (IntPtr tree_model);

		static int GetFlagsCallback (IntPtr tree_model)
		{
			try {
				Gtk.TreeModelImplementor __obj = GLib.Object.GetObject (tree_model, false) as Gtk.TreeModelImplementor;
				Gtk.TreeModelFlags __result = __obj.Flags;
				return (int) __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate int GetNColumnsDelegate (IntPtr tree_model);

		static int GetNColumnsCallback (IntPtr tree_model)
		{
			try {
				Gtk.TreeModelImplementor __obj = GLib.Object.GetObject (tree_model, false) as Gtk.TreeModelImplementor;
				int __result = __obj.NColumns;
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr GetColumnTypeDelegate (IntPtr tree_model, int index_);

		static IntPtr GetColumnTypeCallback (IntPtr tree_model, int index_)
		{
			try {
				Gtk.TreeModelImplementor __obj = GLib.Object.GetObject (tree_model, false) as Gtk.TreeModelImplementor;
				GLib.GType __result = __obj.GetColumnType (index_);
				return __result.Val;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool GetIterDelegate (IntPtr tree_model, IntPtr iter, IntPtr path);

		static bool GetIterCallback (IntPtr tree_model, IntPtr iter, IntPtr path)
		{
			try {
				Gtk.TreeModelImplementor __obj = GLib.Object.GetObject (tree_model, false) as Gtk.TreeModelImplementor;
				Gtk.TreeIter myiter;
				bool __result = __obj.GetIter (out myiter, path == IntPtr.Zero ? null : (Gtk.TreePath) GLib.Opaque.GetOpaque (path, typeof (Gtk.TreePath), false));
				unsafe { if (iter != IntPtr.Zero) *(Gtk.TreeIter*)iter = myiter; }
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr GetPathDelegate (IntPtr tree_model, IntPtr iter);

		static IntPtr GetPathCallback (IntPtr tree_model, IntPtr iter)
		{
			try {
				Gtk.TreeModelImplementor __obj = GLib.Object.GetObject (tree_model, false) as Gtk.TreeModelImplementor;
				Gtk.TreePath __result = __obj.GetPath (Gtk.TreeIter.New (iter));
				return __result == null ? IntPtr.Zero : __result.OwnedCopy;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void GetValueDelegate (IntPtr tree_model, IntPtr iter, int column, ref GLib.Value value);

		static void GetValueCallback (IntPtr tree_model, IntPtr iter, int column, ref GLib.Value value)
		{
			try {
				Gtk.TreeModelImplementor __obj = GLib.Object.GetObject (tree_model, false) as Gtk.TreeModelImplementor;
				__obj.GetValue (Gtk.TreeIter.New (iter), column, ref value);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool IterNextDelegate (IntPtr tree_model, IntPtr iter);

		static bool IterNextCallback (IntPtr tree_model, IntPtr iter)
		{
			try {
				Gtk.TreeModelImplementor __obj = GLib.Object.GetObject (tree_model, false) as Gtk.TreeModelImplementor;
				Gtk.TreeIter myiter = Gtk.TreeIter.New (iter);
				bool __result = __obj.IterNext (ref myiter);
				unsafe { if (iter != IntPtr.Zero) *(Gtk.TreeIter*)iter = myiter; }
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool IterChildrenDelegate (IntPtr tree_model, IntPtr iter, IntPtr parent);

		static bool IterChildrenCallback (IntPtr tree_model, IntPtr iter, IntPtr parent)
		{
			try {
				Gtk.TreeModelImplementor __obj = GLib.Object.GetObject (tree_model, false) as Gtk.TreeModelImplementor;
				Gtk.TreeIter myiter;
				bool __result = __obj.IterChildren (out myiter, Gtk.TreeIter.New (parent));
				unsafe { if (iter != IntPtr.Zero) *(Gtk.TreeIter*)iter = myiter; }
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool IterHasChildDelegate (IntPtr tree_model, IntPtr iter);

		static bool IterHasChildCallback (IntPtr tree_model, IntPtr iter)
		{
			try {
				Gtk.TreeModelImplementor __obj = GLib.Object.GetObject (tree_model, false) as Gtk.TreeModelImplementor;
				bool __result = __obj.IterHasChild (Gtk.TreeIter.New (iter));
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate int IterNChildrenDelegate (IntPtr tree_model, IntPtr iter);

		static int IterNChildrenCallback (IntPtr tree_model, IntPtr iter)
		{
			try {
				Gtk.TreeModelImplementor __obj = GLib.Object.GetObject (tree_model, false) as Gtk.TreeModelImplementor;
				int __result = __obj.IterNChildren (Gtk.TreeIter.New (iter));
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool IterNthChildDelegate (IntPtr tree_model, IntPtr iter, IntPtr parent, int n);

		static bool IterNthChildCallback (IntPtr tree_model, IntPtr iter, IntPtr parent, int n)
		{
			try {
				Gtk.TreeModelImplementor __obj = GLib.Object.GetObject (tree_model, false) as Gtk.TreeModelImplementor;
				Gtk.TreeIter myiter;
				bool __result = __obj.IterNthChild (out myiter, Gtk.TreeIter.New (parent), n);
				unsafe { if (iter != IntPtr.Zero) *(Gtk.TreeIter*)iter = myiter; }
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool IterParentDelegate (IntPtr tree_model, IntPtr iter, IntPtr child);

		static bool IterParentCallback (IntPtr tree_model, IntPtr iter, IntPtr child)
		{
			try {
				Gtk.TreeModelImplementor __obj = GLib.Object.GetObject (tree_model, false) as Gtk.TreeModelImplementor;
				Gtk.TreeIter myiter;
				bool __result = __obj.IterParent (out myiter, Gtk.TreeIter.New (child));
				unsafe { if (iter != IntPtr.Zero) *(Gtk.TreeIter*)iter = myiter; }
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void RefNodeDelegate (IntPtr tree_model, IntPtr iter);

		static void RefNodeCallback (IntPtr tree_model, IntPtr iter)
		{
			try {
				Gtk.TreeModelImplementor __obj = GLib.Object.GetObject (tree_model, false) as Gtk.TreeModelImplementor;
				__obj.RefNode (Gtk.TreeIter.New (iter));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void UnrefNodeDelegate (IntPtr tree_model, IntPtr iter);

		static void UnrefNodeCallback (IntPtr tree_model, IntPtr iter)
		{
			try {
				Gtk.TreeModelImplementor __obj = GLib.Object.GetObject (tree_model, false) as Gtk.TreeModelImplementor;
				__obj.UnrefNode (Gtk.TreeIter.New (iter));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}
		static void Initialize (IntPtr ifaceptr, IntPtr data)
		{
			TreeModelIface native_iface = Marshal.PtrToStructure<TreeModelIface> (ifaceptr);
			native_iface.get_flags = iface.get_flags;
			native_iface.get_n_columns = iface.get_n_columns;
			native_iface.get_column_type = iface.get_column_type;
			native_iface.get_iter = iface.get_iter;
			native_iface.get_path = iface.get_path;
			native_iface.get_value = iface.get_value;
			native_iface.iter_next = iface.iter_next;
			native_iface.iter_children = iface.iter_children;
			native_iface.iter_has_child = iface.iter_has_child;
			native_iface.iter_n_children = iface.iter_n_children;
			native_iface.iter_nth_child = iface.iter_nth_child;
			native_iface.iter_parent = iface.iter_parent;
			native_iface.ref_node = iface.ref_node;
			native_iface.unref_node = iface.unref_node;
			Marshal.StructureToPtr<TreeModelIface> (native_iface, ifaceptr, false);
			GCHandle gch = (GCHandle) data;
			gch.Free ();
		}

		public TreeModelAdapter ()
		{
			InitHandler = new GLib.GInterfaceInitHandler (Initialize);
		}

		TreeModelImplementor implementor;

		public TreeModelAdapter (TreeModelImplementor implementor)
		{
			if (implementor == null)
				throw new ArgumentNullException ("implementor");
			this.implementor = implementor;
		}

		public TreeModelAdapter (IntPtr handle)
		{
			this.handle = handle;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_tree_model_get_type();

		private static GLib.GType _gtype = new GLib.GType (gtk_tree_model_get_type ());

		public override GLib.GType GType {
			get {
				return _gtype;
			}
		}

		IntPtr handle;
		public override IntPtr Handle {
			get {
				if (handle != IntPtr.Zero)
					return handle;
				return implementor == null ? IntPtr.Zero : implementor.Handle;
			}
		}

		public static TreeModel GetObject (IntPtr handle, bool owned)
		{
			GLib.Object obj = GLib.Object.GetObject (handle, owned);
			return GetObject (obj);
		}

		public static TreeModel GetObject (GLib.Object obj)
		{
			if (obj == null)
				return null;
			else if (obj is TreeModelImplementor)
				return new TreeModelAdapter (obj as TreeModelImplementor);
			else if (obj as TreeModel == null)
				return new TreeModelAdapter (obj.Handle);
			else
				return obj as TreeModel;
		}

		public TreeModelImplementor Implementor {
			get {
				return implementor;
			}
		}

		[GLib.Signal("row_changed")]
		public event Gtk.RowChangedHandler RowChanged {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (GLib.Object.GetObject (Handle), "row_changed", typeof (Gtk.RowChangedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (GLib.Object.GetObject (Handle), "row_changed", typeof (Gtk.RowChangedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.Signal("row_inserted")]
		public event Gtk.RowInsertedHandler RowInserted {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (GLib.Object.GetObject (Handle), "row_inserted", typeof (Gtk.RowInsertedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (GLib.Object.GetObject (Handle), "row_inserted", typeof (Gtk.RowInsertedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.Signal("row_has_child_toggled")]
		public event Gtk.RowHasChildToggledHandler RowHasChildToggled {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (GLib.Object.GetObject (Handle), "row_has_child_toggled", typeof (Gtk.RowHasChildToggledArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (GLib.Object.GetObject (Handle), "row_has_child_toggled", typeof (Gtk.RowHasChildToggledArgs));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.Signal("row_deleted")]
		public event Gtk.RowDeletedHandler RowDeleted {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (GLib.Object.GetObject (Handle), "row_deleted", typeof (Gtk.RowDeletedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (GLib.Object.GetObject (Handle), "row_deleted", typeof (Gtk.RowDeletedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_model_foreach(IntPtr raw, GtkSharp.TreeModelForeachFuncNative func, IntPtr user_data);

		public void Foreach(Gtk.TreeModelForeachFunc func) {
			Gtk.Application.AssertMainThread();
			GCHandle gch = GCHandle.Alloc (func);
			gtk_tree_model_foreach(Handle, (func == null) ? null : GtkSharp.TreeModelForeachFuncWrapper.NativeDelegate, (IntPtr)gch);
			gch.Free();
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_tree_model_get_column_type(IntPtr raw, int index_);

		public GLib.GType GetColumnType(int index_) {
			Gtk.Application.AssertMainThread();
			IntPtr raw_ret = gtk_tree_model_get_column_type(Handle, index_);
			GLib.GType ret = new GLib.GType(raw_ret);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_tree_model_get_flags(IntPtr raw);

		public Gtk.TreeModelFlags Flags { 
			get {
				int raw_ret = gtk_tree_model_get_flags(Handle);
				Gtk.TreeModelFlags ret = (Gtk.TreeModelFlags) raw_ret;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_model_get_iter(IntPtr raw, ref Gtk.TreeIter iter, IntPtr path);

		public bool GetIter(out Gtk.TreeIter iter, Gtk.TreePath path) {
			Gtk.Application.AssertMainThread();
			iter = new Gtk.TreeIter();
			bool raw_ret = gtk_tree_model_get_iter(Handle, ref iter, path == null ? IntPtr.Zero : path.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_model_get_iter_first(IntPtr raw, ref Gtk.TreeIter iter);

		public bool GetIterFirst(out Gtk.TreeIter iter) {
			Gtk.Application.AssertMainThread();
			iter = new Gtk.TreeIter();
			bool raw_ret = gtk_tree_model_get_iter_first(Handle, ref iter);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_model_get_iter_from_string(IntPtr raw, ref Gtk.TreeIter iter, IntPtr path_string);

		public bool GetIterFromString(out Gtk.TreeIter iter, string path_string) {
			Gtk.Application.AssertMainThread();
			iter = new Gtk.TreeIter();
			IntPtr native_path_string = GLib.Marshaller.StringToPtrGStrdup (path_string);
			bool raw_ret = gtk_tree_model_get_iter_from_string(Handle, ref iter, native_path_string);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_path_string);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_tree_model_get_n_columns(IntPtr raw);

		public int NColumns { 
			get {
				int raw_ret = gtk_tree_model_get_n_columns(Handle);
				int ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_tree_model_get_path(IntPtr raw, ref Gtk.TreeIter iter);

		public Gtk.TreePath GetPath(Gtk.TreeIter iter) {
			Gtk.Application.AssertMainThread();
			IntPtr raw_ret = gtk_tree_model_get_path(Handle, ref iter);
			Gtk.TreePath ret = raw_ret == IntPtr.Zero ? null : (Gtk.TreePath) GLib.Opaque.GetOpaque (raw_ret, typeof (Gtk.TreePath), true);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_tree_model_get_string_from_iter(IntPtr raw, ref Gtk.TreeIter iter);

		public string GetStringFromIter(Gtk.TreeIter iter) {
			Gtk.Application.AssertMainThread();
			IntPtr raw_ret = gtk_tree_model_get_string_from_iter(Handle, ref iter);
			string ret = GLib.Marshaller.PtrToStringGFree(raw_ret);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_model_get_valist(IntPtr raw, ref Gtk.TreeIter iter, IntPtr var_args);

		public void GetValist(Gtk.TreeIter iter, IntPtr var_args) {
			Gtk.Application.AssertMainThread();
			gtk_tree_model_get_valist(Handle, ref iter, var_args);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_model_get_value(IntPtr raw, ref Gtk.TreeIter iter, int column, ref GLib.Value value);

		public void GetValue(Gtk.TreeIter iter, int column, ref GLib.Value value) {
			Gtk.Application.AssertMainThread();
			gtk_tree_model_get_value(Handle, ref iter, column, ref value);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_model_iter_children(IntPtr raw, ref Gtk.TreeIter iter, ref Gtk.TreeIter parent);

		public bool IterChildren(out Gtk.TreeIter iter, Gtk.TreeIter parent) {
			Gtk.Application.AssertMainThread();
			iter = new Gtk.TreeIter();
			bool raw_ret = gtk_tree_model_iter_children(Handle, ref iter, ref parent);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_model_iter_has_child(IntPtr raw, ref Gtk.TreeIter iter);

		public bool IterHasChild(Gtk.TreeIter iter) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_tree_model_iter_has_child(Handle, ref iter);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_tree_model_iter_n_children(IntPtr raw, ref Gtk.TreeIter iter);

		public int IterNChildren(Gtk.TreeIter iter) {
			Gtk.Application.AssertMainThread();
			int raw_ret = gtk_tree_model_iter_n_children(Handle, ref iter);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_model_iter_next(IntPtr raw, ref Gtk.TreeIter iter);

		public bool IterNext(ref Gtk.TreeIter iter) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_tree_model_iter_next(Handle, ref iter);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_model_iter_nth_child(IntPtr raw, ref Gtk.TreeIter iter, ref Gtk.TreeIter parent, int n);

		public bool IterNthChild(out Gtk.TreeIter iter, Gtk.TreeIter parent, int n) {
			Gtk.Application.AssertMainThread();
			iter = new Gtk.TreeIter();
			bool raw_ret = gtk_tree_model_iter_nth_child(Handle, ref iter, ref parent, n);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_model_iter_parent(IntPtr raw, ref Gtk.TreeIter iter, ref Gtk.TreeIter child);

		public bool IterParent(out Gtk.TreeIter iter, Gtk.TreeIter child) {
			Gtk.Application.AssertMainThread();
			iter = new Gtk.TreeIter();
			bool raw_ret = gtk_tree_model_iter_parent(Handle, ref iter, ref child);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_model_ref_node(IntPtr raw, ref Gtk.TreeIter iter);

		public void RefNode(Gtk.TreeIter iter) {
			Gtk.Application.AssertMainThread();
			gtk_tree_model_ref_node(Handle, ref iter);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_model_row_changed(IntPtr raw, IntPtr path, ref Gtk.TreeIter iter);

		public void EmitRowChanged(Gtk.TreePath path, Gtk.TreeIter iter) {
			Gtk.Application.AssertMainThread();
			gtk_tree_model_row_changed(Handle, path == null ? IntPtr.Zero : path.Handle, ref iter);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_model_row_deleted(IntPtr raw, IntPtr path);

		public void EmitRowDeleted(Gtk.TreePath path) {
			Gtk.Application.AssertMainThread();
			gtk_tree_model_row_deleted(Handle, path == null ? IntPtr.Zero : path.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_model_row_has_child_toggled(IntPtr raw, IntPtr path, ref Gtk.TreeIter iter);

		public void EmitRowHasChildToggled(Gtk.TreePath path, Gtk.TreeIter iter) {
			Gtk.Application.AssertMainThread();
			gtk_tree_model_row_has_child_toggled(Handle, path == null ? IntPtr.Zero : path.Handle, ref iter);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_model_row_inserted(IntPtr raw, IntPtr path, ref Gtk.TreeIter iter);

		public void EmitRowInserted(Gtk.TreePath path, Gtk.TreeIter iter) {
			Gtk.Application.AssertMainThread();
			gtk_tree_model_row_inserted(Handle, path == null ? IntPtr.Zero : path.Handle, ref iter);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_model_rows_reordered(IntPtr raw, IntPtr path, ref Gtk.TreeIter iter, int[] new_order);

		public void EmitRowsReordered(Gtk.TreePath path, Gtk.TreeIter iter, int[] new_order) {
			Gtk.Application.AssertMainThread();
			gtk_tree_model_rows_reordered(Handle, path == null ? IntPtr.Zero : path.Handle, ref iter, new_order);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_model_unref_node(IntPtr raw, ref Gtk.TreeIter iter);

		public void UnrefNode(Gtk.TreeIter iter) {
			Gtk.Application.AssertMainThread();
			gtk_tree_model_unref_node(Handle, ref iter);
		}

#endregion
#region Customized extensions
#line 1 "TreeModelAdapter.custom"
//  Gtk.TreeModelAdapter.custom - Gtk TreeModelAdapter customizations
//
//  Author:  Mike Kestner  <mkestner@novell.com>
//
//  Copyright (c) 2007 Novell, Inc.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of version 2 of the Lesser GNU General
// Public License as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this program; if not, write to the
// Free Software Foundation, Inc., 59 Temple Place - Suite 330,
// Boston, MA 02111-1307, USA.


		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
		static extern bool gtk_tree_model_iter_children (IntPtr raw, out Gtk.TreeIter iter, IntPtr parent);
		public bool IterChildren (out Gtk.TreeIter iter) {
			bool raw_ret = gtk_tree_model_iter_children (Handle, out iter, IntPtr.Zero);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", EntryPoint="gtk_tree_model_iter_n_children", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_tree_model_iter_n_children_ptr(IntPtr raw, IntPtr iter);

		public int IterNChildren ()
		{
			int raw_ret = gtk_tree_model_iter_n_children_ptr (Handle, IntPtr.Zero);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
		static extern bool gtk_tree_model_iter_nth_child (IntPtr raw, out Gtk.TreeIter iter, IntPtr parent, int n);
		public bool IterNthChild (out Gtk.TreeIter iter, int n) {
			bool raw_ret = gtk_tree_model_iter_nth_child (Handle, out iter, IntPtr.Zero, n);
			bool ret = raw_ret;
			return ret;
		}

		public void SetValue (Gtk.TreeIter iter, int column, bool value) {
			throw new NotImplementedException ();
		}

		public void SetValue (Gtk.TreeIter iter, int column, double value) {
			throw new NotImplementedException ();
		}

		public void SetValue (Gtk.TreeIter iter, int column, int value) {
			throw new NotImplementedException ();
		}

		public void SetValue (Gtk.TreeIter iter, int column, string value) {
			throw new NotImplementedException ();
		}

		public void SetValue (Gtk.TreeIter iter, int column, float value) {
			throw new NotImplementedException ();
		}

		public void SetValue (Gtk.TreeIter iter, int column, uint value) {
			throw new NotImplementedException ();
		}

		public void SetValue (Gtk.TreeIter iter, int column, object value) {
			throw new NotImplementedException ();
		}

		public object GetValue (Gtk.TreeIter iter, int column) {
			GLib.Value val = GLib.Value.Empty;
			GetValue (iter, column, ref val);
			object ret = val.Val;
			val.Dispose ();
			return ret;
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void RowsReorderedSignalDelegate (IntPtr arg0, IntPtr arg1, IntPtr arg2, IntPtr arg3, IntPtr gch);

		static void RowsReorderedSignalCallback (IntPtr arg0, IntPtr arg1, IntPtr arg2, IntPtr arg3, IntPtr gch)
		{
			Gtk.RowsReorderedArgs args = new Gtk.RowsReorderedArgs ();
			try {
				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
				if (sig == null)
					throw new Exception("Unknown signal GC handle received " + gch);

				TreeModelFilter sender = GLib.Object.GetObject (arg0) as TreeModelFilter;
				args.Args = new object[3];
				args.Args[0] = arg1 == IntPtr.Zero ? null : (Gtk.TreePath) GLib.Opaque.GetOpaque (arg1, typeof (Gtk.TreePath), false);
				args.Args[1] = Gtk.TreeIter.New (arg2);
				int child_cnt = arg2 == IntPtr.Zero ? sender.IterNChildren () : sender.IterNChildren ((TreeIter)args.Args[1]);
				int[] new_order = new int [child_cnt];
				Marshal.Copy (arg3, new_order, 0, child_cnt);
				args.Args[2] = new_order;
				Gtk.RowsReorderedHandler handler = (Gtk.RowsReorderedHandler) sig.Handler;
				handler (sender, args);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

#if false
		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void RowsReorderedVMDelegate (IntPtr tree_model, IntPtr path, IntPtr iter, IntPtr new_order);

		static RowsReorderedVMDelegate RowsReorderedVMCallback;

		static void rowsreordered_cb (IntPtr tree_model, IntPtr path_ptr, IntPtr iter_ptr, IntPtr new_order)
		{
			try {
				TreeModelFilter store = GLib.Object.GetObject (tree_model, false) as TreeModelFilter;
				TreePath path = GLib.Opaque.GetOpaque (path_ptr, typeof (TreePath), false) as TreePath;
				TreeIter iter = TreeIter.New (iter_ptr);
				int child_cnt = store.IterNChildren (iter);
				int[] child_order = new int [child_cnt];
				Marshal.Copy (new_order, child_order, 0, child_cnt);
				store.OnRowsReordered (path, iter, child_order);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideRowsReordered (GLib.GType gtype)
		{
			if (RowsReorderedVMCallback == null)
				RowsReorderedVMCallback = new RowsReorderedVMDelegate (rowsreordered_cb);
			OverrideVirtualMethod (gtype, "rows_reordered", RowsReorderedVMCallback);
		}

		[Obsolete ("Replaced by int[] new_order overload.")]
		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TreeModelFilter), ConnectionMethod="OverrideRowsReordered")]
		protected virtual void OnRowsReordered (Gtk.TreePath path, Gtk.TreeIter iter, out int new_order)
		{
			new_order = -1;
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TreeModelFilter), ConnectionMethod="OverrideRowsReordered")]
		protected virtual void OnRowsReordered (Gtk.TreePath path, Gtk.TreeIter iter, int[] new_order)
		{
			int dummy;
			OnRowsReordered (path, iter, out dummy);
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (4);
			GLib.Value[] vals = new GLib.Value [4];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (path);
			inst_and_params.Append (vals [1]);
			vals [2] = new GLib.Value (iter);
			inst_and_params.Append (vals [2]);
			int cnt = IterNChildren (iter);
			IntPtr new_order_ptr = Marshal.AllocHGlobal (Marshal.SizeOf (typeof (int)) * cnt);
			Marshal.Copy (new_order, 0, new_order_ptr, cnt);
			vals [3] = new GLib.Value (new_order_ptr);
			inst_and_params.Append (vals [3]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			Marshal.FreeHGlobal (new_order_ptr);

			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

#endif
		[GLib.Signal("rows_reordered")]
		public event Gtk.RowsReorderedHandler RowsReordered {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (GLib.Object.GetObject (Handle), "rows_reordered", new RowsReorderedSignalDelegate(RowsReorderedSignalCallback));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (GLib.Object.GetObject (Handle), "rows_reordered", new RowsReorderedSignalDelegate(RowsReorderedSignalCallback));
				sig.RemoveDelegate (value);
			}
		}

#endregion
	}
}
