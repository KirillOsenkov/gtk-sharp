// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gtk {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	[TextView]
	public class TextView : Gtk.Container {

		[Obsolete]
		protected TextView(GLib.GType gtype) : base(gtype) {}
		public TextView(IntPtr raw) : base(raw) {}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_text_view_new();

		public TextView () : base (IntPtr.Zero)
		{
			if (GetType () != typeof (TextView)) {
				Gtk.Application.AssertMainThread();
				CreateNativeObject (Array.Empty<IntPtr> (), Array.Empty<GLib.Value> (), 0);
				return;
			}
			owned = true;
			Raw = gtk_text_view_new();
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_text_view_get_pixels_above_lines(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_view_set_pixels_above_lines(IntPtr raw, int pixels_above_lines);

		[GLib.Property ("pixels-above-lines")]
		public int PixelsAboveLines {
			get  {
				int raw_ret = gtk_text_view_get_pixels_above_lines(Handle);
				int ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_text_view_set_pixels_above_lines(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_text_view_get_pixels_below_lines(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_view_set_pixels_below_lines(IntPtr raw, int pixels_below_lines);

		[GLib.Property ("pixels-below-lines")]
		public int PixelsBelowLines {
			get  {
				int raw_ret = gtk_text_view_get_pixels_below_lines(Handle);
				int ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_text_view_set_pixels_below_lines(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_text_view_get_pixels_inside_wrap(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_view_set_pixels_inside_wrap(IntPtr raw, int pixels_inside_wrap);

		[GLib.Property ("pixels-inside-wrap")]
		public int PixelsInsideWrap {
			get  {
				int raw_ret = gtk_text_view_get_pixels_inside_wrap(Handle);
				int ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_text_view_set_pixels_inside_wrap(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_text_view_get_editable(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_view_set_editable(IntPtr raw, bool setting);

		[GLib.Property ("editable")]
		public bool Editable {
			get  {
				bool raw_ret = gtk_text_view_get_editable(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_text_view_set_editable(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_text_view_get_wrap_mode(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_view_set_wrap_mode(IntPtr raw, int wrap_mode);

		[GLib.Property ("wrap-mode")]
		public Gtk.WrapMode WrapMode {
			get  {
				int raw_ret = gtk_text_view_get_wrap_mode(Handle);
				Gtk.WrapMode ret = (Gtk.WrapMode) raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_text_view_set_wrap_mode(Handle, (int) value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_text_view_get_justification(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_view_set_justification(IntPtr raw, int justification);

		[GLib.Property ("justification")]
		public Gtk.Justification Justification {
			get  {
				int raw_ret = gtk_text_view_get_justification(Handle);
				Gtk.Justification ret = (Gtk.Justification) raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_text_view_set_justification(Handle, (int) value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_text_view_get_left_margin(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_view_set_left_margin(IntPtr raw, int left_margin);

		[GLib.Property ("left-margin")]
		public int LeftMargin {
			get  {
				int raw_ret = gtk_text_view_get_left_margin(Handle);
				int ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_text_view_set_left_margin(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_text_view_get_right_margin(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_view_set_right_margin(IntPtr raw, int right_margin);

		[GLib.Property ("right-margin")]
		public int RightMargin {
			get  {
				int raw_ret = gtk_text_view_get_right_margin(Handle);
				int ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_text_view_set_right_margin(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_text_view_get_indent(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_view_set_indent(IntPtr raw, int indent);

		[GLib.Property ("indent")]
		public int Indent {
			get  {
				int raw_ret = gtk_text_view_get_indent(Handle);
				int ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_text_view_set_indent(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_text_view_get_tabs(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_view_set_tabs(IntPtr raw, IntPtr tabs);

		[GLib.Property ("tabs")]
		public Pango.TabArray Tabs {
			get  {
				IntPtr raw_ret = gtk_text_view_get_tabs(Handle);
				Pango.TabArray ret = raw_ret == IntPtr.Zero ? null : (Pango.TabArray) GLib.Opaque.GetOpaque (raw_ret, typeof (Pango.TabArray), false);
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_text_view_set_tabs(Handle, value == null ? IntPtr.Zero : value.Handle);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_text_view_get_cursor_visible(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_view_set_cursor_visible(IntPtr raw, bool setting);

		[GLib.Property ("cursor-visible")]
		public bool CursorVisible {
			get  {
				bool raw_ret = gtk_text_view_get_cursor_visible(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_text_view_set_cursor_visible(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_text_view_get_buffer(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_view_set_buffer(IntPtr raw, IntPtr buffer);

		[GLib.Property ("buffer")]
		public Gtk.TextBuffer Buffer {
			get  {
				IntPtr raw_ret = gtk_text_view_get_buffer(Handle);
				Gtk.TextBuffer ret = GLib.Object.GetObject(raw_ret) as Gtk.TextBuffer;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_text_view_set_buffer(Handle, value == null ? IntPtr.Zero : value.Handle);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_text_view_get_overwrite(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_view_set_overwrite(IntPtr raw, bool overwrite);

		[GLib.Property ("overwrite")]
		public bool Overwrite {
			get  {
				bool raw_ret = gtk_text_view_get_overwrite(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_text_view_set_overwrite(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_text_view_get_accepts_tab(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_view_set_accepts_tab(IntPtr raw, bool accepts_tab);

		[GLib.Property ("accepts-tab")]
		public bool AcceptsTab {
			get  {
				bool raw_ret = gtk_text_view_get_accepts_tab(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_text_view_set_accepts_tab(Handle, value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void MoveCursorVMDelegate (IntPtr text_view, int step, int count, bool extend_selection);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textview_override_move_cursor (IntPtr gtype, MoveCursorVMDelegate cb);

		static MoveCursorVMDelegate MoveCursorVMCallback;

		static void movecursor_cb (IntPtr text_view, int step, int count, bool extend_selection)
		{
			try {
				TextView text_view_managed = GLib.Object.GetObject (text_view, false) as TextView;
				text_view_managed.OnMoveCursor ((Gtk.MovementStep) step, count, extend_selection);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideMoveCursor (GLib.GType gtype)
		{
			if (MoveCursorVMCallback == null)
				MoveCursorVMCallback = new MoveCursorVMDelegate (movecursor_cb);
			gtksharp_textview_override_move_cursor (gtype.Val, MoveCursorVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textview_base_move_cursor (IntPtr text_view, int step, int count, bool extend_selection);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TextView), ConnectionMethod="OverrideMoveCursor")]
		protected virtual void OnMoveCursor (Gtk.MovementStep step, int count, bool extend_selection)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_textview_base_move_cursor (Handle, (int) step, count, extend_selection);
		}

		[GLib.Signal("move_cursor")]
		public event Gtk.MoveCursorHandler MoveCursor {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "move_cursor", typeof (Gtk.MoveCursorArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "move_cursor", typeof (Gtk.MoveCursorArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void PageHorizontallyVMDelegate (IntPtr text_view, int count, bool extend_selection);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textview_override_page_horizontally (IntPtr gtype, PageHorizontallyVMDelegate cb);

		static PageHorizontallyVMDelegate PageHorizontallyVMCallback;

		static void pagehorizontally_cb (IntPtr text_view, int count, bool extend_selection)
		{
			try {
				TextView text_view_managed = GLib.Object.GetObject (text_view, false) as TextView;
				text_view_managed.OnPageHorizontally (count, extend_selection);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverridePageHorizontally (GLib.GType gtype)
		{
			if (PageHorizontallyVMCallback == null)
				PageHorizontallyVMCallback = new PageHorizontallyVMDelegate (pagehorizontally_cb);
			gtksharp_textview_override_page_horizontally (gtype.Val, PageHorizontallyVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textview_base_page_horizontally (IntPtr text_view, int count, bool extend_selection);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TextView), ConnectionMethod="OverridePageHorizontally")]
		protected virtual void OnPageHorizontally (int count, bool extend_selection)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_textview_base_page_horizontally (Handle, count, extend_selection);
		}

		[GLib.Signal("page_horizontally")]
		public event Gtk.PageHorizontallyHandler PageHorizontally {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "page_horizontally", typeof (Gtk.PageHorizontallyArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "page_horizontally", typeof (Gtk.PageHorizontallyArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void MoveViewportVMDelegate (IntPtr inst, int p0, int p1);

		static MoveViewportVMDelegate MoveViewportVMCallback;

		static void moveviewport_cb (IntPtr inst, int p0, int p1)
		{
			try {
				TextView inst_managed = GLib.Object.GetObject (inst, false) as TextView;
				inst_managed.OnMoveViewport ((Gtk.ScrollStep) p0, p1);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideMoveViewport (GLib.GType gtype)
		{
			if (MoveViewportVMCallback == null)
				MoveViewportVMCallback = new MoveViewportVMDelegate (moveviewport_cb);
			OverrideVirtualMethod (gtype, "move_viewport", MoveViewportVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TextView), ConnectionMethod="OverrideMoveViewport")]
		protected virtual void OnMoveViewport (Gtk.ScrollStep p0, int p1)
		{
			GLib.Value ret = GLib.Value.Empty;
			unsafe {
				GLib.Value* inst_and_params = stackalloc GLib.Value [3];
				using (inst_and_params[0] = new GLib.Value (this)) {
					using (inst_and_params [1] = new GLib.Value (p0)) {
						using (inst_and_params [2] = new GLib.Value (p1)) {
							g_signal_chain_from_overridden (inst_and_params, ref ret);
						}
					}
				}
			}
		}

		[GLib.Signal("move_viewport")]
		public event Gtk.MoveViewportHandler MoveViewport {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "move_viewport", typeof (Gtk.MoveViewportArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "move_viewport", typeof (Gtk.MoveViewportArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void SetAnchorVMDelegate (IntPtr text_view);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textview_override_set_anchor (IntPtr gtype, SetAnchorVMDelegate cb);

		static SetAnchorVMDelegate SetAnchorVMCallback;

		static void setanchor_cb (IntPtr text_view)
		{
			try {
				TextView text_view_managed = GLib.Object.GetObject (text_view, false) as TextView;
				text_view_managed.OnSetAnchor ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideSetAnchor (GLib.GType gtype)
		{
			if (SetAnchorVMCallback == null)
				SetAnchorVMCallback = new SetAnchorVMDelegate (setanchor_cb);
			gtksharp_textview_override_set_anchor (gtype.Val, SetAnchorVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textview_base_set_anchor (IntPtr text_view);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TextView), ConnectionMethod="OverrideSetAnchor")]
		protected virtual void OnSetAnchor ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_textview_base_set_anchor (Handle);
		}

		[GLib.Signal("set_anchor")]
		public event System.EventHandler SetAnchor {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "set_anchor");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "set_anchor");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void InsertAtCursorVMDelegate (IntPtr text_view, IntPtr str);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textview_override_insert_at_cursor (IntPtr gtype, InsertAtCursorVMDelegate cb);

		static InsertAtCursorVMDelegate InsertAtCursorVMCallback;

		static void insertatcursor_cb (IntPtr text_view, IntPtr str)
		{
			try {
				TextView text_view_managed = GLib.Object.GetObject (text_view, false) as TextView;
				text_view_managed.OnInsertAtCursor (GLib.Marshaller.Utf8PtrToString (str));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideInsertAtCursor (GLib.GType gtype)
		{
			if (InsertAtCursorVMCallback == null)
				InsertAtCursorVMCallback = new InsertAtCursorVMDelegate (insertatcursor_cb);
			gtksharp_textview_override_insert_at_cursor (gtype.Val, InsertAtCursorVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textview_base_insert_at_cursor (IntPtr text_view, IntPtr str);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TextView), ConnectionMethod="OverrideInsertAtCursor")]
		protected virtual void OnInsertAtCursor (string str)
		{
			Gtk.Application.AssertMainThread();
			IntPtr native_str = GLib.Marshaller.StringToPtrGStrdup (str);
			gtksharp_textview_base_insert_at_cursor (Handle, native_str);
			GLib.Marshaller.Free (native_str);
		}

		[GLib.Signal("insert_at_cursor")]
		public event Gtk.InsertAtCursorHandler InsertAtCursor {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "insert_at_cursor", typeof (Gtk.InsertAtCursorArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "insert_at_cursor", typeof (Gtk.InsertAtCursorArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DeleteFromCursorVMDelegate (IntPtr text_view, int type, int count);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textview_override_delete_from_cursor (IntPtr gtype, DeleteFromCursorVMDelegate cb);

		static DeleteFromCursorVMDelegate DeleteFromCursorVMCallback;

		static void deletefromcursor_cb (IntPtr text_view, int type, int count)
		{
			try {
				TextView text_view_managed = GLib.Object.GetObject (text_view, false) as TextView;
				text_view_managed.OnDeleteFromCursor ((Gtk.DeleteType) type, count);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideDeleteFromCursor (GLib.GType gtype)
		{
			if (DeleteFromCursorVMCallback == null)
				DeleteFromCursorVMCallback = new DeleteFromCursorVMDelegate (deletefromcursor_cb);
			gtksharp_textview_override_delete_from_cursor (gtype.Val, DeleteFromCursorVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textview_base_delete_from_cursor (IntPtr text_view, int type, int count);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TextView), ConnectionMethod="OverrideDeleteFromCursor")]
		protected virtual void OnDeleteFromCursor (Gtk.DeleteType type, int count)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_textview_base_delete_from_cursor (Handle, (int) type, count);
		}

		[GLib.Signal("delete_from_cursor")]
		public event Gtk.DeleteFromCursorHandler DeleteFromCursor {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "delete_from_cursor", typeof (Gtk.DeleteFromCursorArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "delete_from_cursor", typeof (Gtk.DeleteFromCursorArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void BackspaceVMDelegate (IntPtr text_view);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textview_override_backspace (IntPtr gtype, BackspaceVMDelegate cb);

		static BackspaceVMDelegate BackspaceVMCallback;

		static void backspace_cb (IntPtr text_view)
		{
			try {
				TextView text_view_managed = GLib.Object.GetObject (text_view, false) as TextView;
				text_view_managed.OnBackspace ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideBackspace (GLib.GType gtype)
		{
			if (BackspaceVMCallback == null)
				BackspaceVMCallback = new BackspaceVMDelegate (backspace_cb);
			gtksharp_textview_override_backspace (gtype.Val, BackspaceVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textview_base_backspace (IntPtr text_view);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TextView), ConnectionMethod="OverrideBackspace")]
		protected virtual void OnBackspace ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_textview_base_backspace (Handle);
		}

		[GLib.Signal("backspace")]
		public event System.EventHandler Backspace {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "backspace");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "backspace");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void CutClipboardVMDelegate (IntPtr text_view);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textview_override_cut_clipboard (IntPtr gtype, CutClipboardVMDelegate cb);

		static CutClipboardVMDelegate CutClipboardVMCallback;

		static void cutclipboard_cb (IntPtr text_view)
		{
			try {
				TextView text_view_managed = GLib.Object.GetObject (text_view, false) as TextView;
				text_view_managed.OnCutClipboard ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideCutClipboard (GLib.GType gtype)
		{
			if (CutClipboardVMCallback == null)
				CutClipboardVMCallback = new CutClipboardVMDelegate (cutclipboard_cb);
			gtksharp_textview_override_cut_clipboard (gtype.Val, CutClipboardVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textview_base_cut_clipboard (IntPtr text_view);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TextView), ConnectionMethod="OverrideCutClipboard")]
		protected virtual void OnCutClipboard ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_textview_base_cut_clipboard (Handle);
		}

		[GLib.Signal("cut_clipboard")]
		public event System.EventHandler CutClipboard {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "cut_clipboard");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "cut_clipboard");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void CopyClipboardVMDelegate (IntPtr text_view);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textview_override_copy_clipboard (IntPtr gtype, CopyClipboardVMDelegate cb);

		static CopyClipboardVMDelegate CopyClipboardVMCallback;

		static void copyclipboard_cb (IntPtr text_view)
		{
			try {
				TextView text_view_managed = GLib.Object.GetObject (text_view, false) as TextView;
				text_view_managed.OnCopyClipboard ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideCopyClipboard (GLib.GType gtype)
		{
			if (CopyClipboardVMCallback == null)
				CopyClipboardVMCallback = new CopyClipboardVMDelegate (copyclipboard_cb);
			gtksharp_textview_override_copy_clipboard (gtype.Val, CopyClipboardVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textview_base_copy_clipboard (IntPtr text_view);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TextView), ConnectionMethod="OverrideCopyClipboard")]
		protected virtual void OnCopyClipboard ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_textview_base_copy_clipboard (Handle);
		}

		[GLib.Signal("copy_clipboard")]
		public event System.EventHandler CopyClipboard {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "copy_clipboard");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "copy_clipboard");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void PasteClipboardVMDelegate (IntPtr text_view);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textview_override_paste_clipboard (IntPtr gtype, PasteClipboardVMDelegate cb);

		static PasteClipboardVMDelegate PasteClipboardVMCallback;

		static void pasteclipboard_cb (IntPtr text_view)
		{
			try {
				TextView text_view_managed = GLib.Object.GetObject (text_view, false) as TextView;
				text_view_managed.OnPasteClipboard ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverridePasteClipboard (GLib.GType gtype)
		{
			if (PasteClipboardVMCallback == null)
				PasteClipboardVMCallback = new PasteClipboardVMDelegate (pasteclipboard_cb);
			gtksharp_textview_override_paste_clipboard (gtype.Val, PasteClipboardVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textview_base_paste_clipboard (IntPtr text_view);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TextView), ConnectionMethod="OverridePasteClipboard")]
		protected virtual void OnPasteClipboard ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_textview_base_paste_clipboard (Handle);
		}

		[GLib.Signal("paste_clipboard")]
		public event System.EventHandler PasteClipboard {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "paste_clipboard");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "paste_clipboard");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ToggleOverwriteVMDelegate (IntPtr text_view);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textview_override_toggle_overwrite (IntPtr gtype, ToggleOverwriteVMDelegate cb);

		static ToggleOverwriteVMDelegate ToggleOverwriteVMCallback;

		static void toggleoverwrite_cb (IntPtr text_view)
		{
			try {
				TextView text_view_managed = GLib.Object.GetObject (text_view, false) as TextView;
				text_view_managed.OnToggleOverwrite ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideToggleOverwrite (GLib.GType gtype)
		{
			if (ToggleOverwriteVMCallback == null)
				ToggleOverwriteVMCallback = new ToggleOverwriteVMDelegate (toggleoverwrite_cb);
			gtksharp_textview_override_toggle_overwrite (gtype.Val, ToggleOverwriteVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textview_base_toggle_overwrite (IntPtr text_view);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TextView), ConnectionMethod="OverrideToggleOverwrite")]
		protected virtual void OnToggleOverwrite ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_textview_base_toggle_overwrite (Handle);
		}

		[GLib.Signal("toggle_overwrite")]
		public event System.EventHandler ToggleOverwrite {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "toggle_overwrite");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "toggle_overwrite");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ScrollAdjustmentsSetVMDelegate (IntPtr text_view, IntPtr hadjustment, IntPtr vadjustment);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textview_override_set_scroll_adjustments (IntPtr gtype, ScrollAdjustmentsSetVMDelegate cb);

		static ScrollAdjustmentsSetVMDelegate ScrollAdjustmentsSetVMCallback;

		static void scrolladjustmentsset_cb (IntPtr text_view, IntPtr hadjustment, IntPtr vadjustment)
		{
			try {
				TextView text_view_managed = GLib.Object.GetObject (text_view, false) as TextView;
				text_view_managed.OnScrollAdjustmentsSet (GLib.Object.GetObject(hadjustment) as Gtk.Adjustment, GLib.Object.GetObject(vadjustment) as Gtk.Adjustment);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideScrollAdjustmentsSet (GLib.GType gtype)
		{
			if (ScrollAdjustmentsSetVMCallback == null)
				ScrollAdjustmentsSetVMCallback = new ScrollAdjustmentsSetVMDelegate (scrolladjustmentsset_cb);
			gtksharp_textview_override_set_scroll_adjustments (gtype.Val, ScrollAdjustmentsSetVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textview_base_set_scroll_adjustments (IntPtr text_view, IntPtr hadjustment, IntPtr vadjustment);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TextView), ConnectionMethod="OverrideScrollAdjustmentsSet")]
		protected virtual void OnScrollAdjustmentsSet (Gtk.Adjustment hadjustment, Gtk.Adjustment vadjustment)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_textview_base_set_scroll_adjustments (Handle, hadjustment == null ? IntPtr.Zero : hadjustment.Handle, vadjustment == null ? IntPtr.Zero : vadjustment.Handle);
		}

		[GLib.Signal("set_scroll_adjustments")]
		public event Gtk.ScrollAdjustmentsSetHandler ScrollAdjustmentsSet {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "set_scroll_adjustments", typeof (Gtk.ScrollAdjustmentsSetArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "set_scroll_adjustments", typeof (Gtk.ScrollAdjustmentsSetArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void PopulatePopupVMDelegate (IntPtr text_view, IntPtr menu);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textview_override_populate_popup (IntPtr gtype, PopulatePopupVMDelegate cb);

		static PopulatePopupVMDelegate PopulatePopupVMCallback;

		static void populatepopup_cb (IntPtr text_view, IntPtr menu)
		{
			try {
				TextView text_view_managed = GLib.Object.GetObject (text_view, false) as TextView;
				text_view_managed.OnPopulatePopup (GLib.Object.GetObject(menu) as Gtk.Menu);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverridePopulatePopup (GLib.GType gtype)
		{
			if (PopulatePopupVMCallback == null)
				PopulatePopupVMCallback = new PopulatePopupVMDelegate (populatepopup_cb);
			gtksharp_textview_override_populate_popup (gtype.Val, PopulatePopupVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textview_base_populate_popup (IntPtr text_view, IntPtr menu);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TextView), ConnectionMethod="OverridePopulatePopup")]
		protected virtual void OnPopulatePopup (Gtk.Menu menu)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_textview_base_populate_popup (Handle, menu == null ? IntPtr.Zero : menu.Handle);
		}

		[GLib.Signal("populate_popup")]
		public event Gtk.PopulatePopupHandler PopulatePopup {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "populate_popup", typeof (Gtk.PopulatePopupArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "populate_popup", typeof (Gtk.PopulatePopupArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void SelectAllVMDelegate (IntPtr inst, bool p0);

		static SelectAllVMDelegate SelectAllVMCallback;

		static void selectall_cb (IntPtr inst, bool p0)
		{
			try {
				TextView inst_managed = GLib.Object.GetObject (inst, false) as TextView;
				inst_managed.OnSelectAll (p0);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideSelectAll (GLib.GType gtype)
		{
			if (SelectAllVMCallback == null)
				SelectAllVMCallback = new SelectAllVMDelegate (selectall_cb);
			OverrideVirtualMethod (gtype, "select_all", SelectAllVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TextView), ConnectionMethod="OverrideSelectAll")]
		protected virtual void OnSelectAll (bool p0)
		{
			GLib.Value ret = GLib.Value.Empty;
			unsafe {
				GLib.Value* inst_and_params = stackalloc GLib.Value [2];
				using (inst_and_params[0] = new GLib.Value (this)) {
					using (inst_and_params [1] = new GLib.Value (p0)) {
						g_signal_chain_from_overridden (inst_and_params, ref ret);
					}
				}
			}
		}

		[GLib.Signal("select_all")]
		public event Gtk.SelectAllHandler SelectAll {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "select_all", typeof (Gtk.SelectAllArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "select_all", typeof (Gtk.SelectAllArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ToggleCursorVisibleVMDelegate (IntPtr inst);

		static ToggleCursorVisibleVMDelegate ToggleCursorVisibleVMCallback;

		static void togglecursorvisible_cb (IntPtr inst)
		{
			try {
				TextView inst_managed = GLib.Object.GetObject (inst, false) as TextView;
				inst_managed.OnToggleCursorVisible ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideToggleCursorVisible (GLib.GType gtype)
		{
			if (ToggleCursorVisibleVMCallback == null)
				ToggleCursorVisibleVMCallback = new ToggleCursorVisibleVMDelegate (togglecursorvisible_cb);
			OverrideVirtualMethod (gtype, "toggle_cursor_visible", ToggleCursorVisibleVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TextView), ConnectionMethod="OverrideToggleCursorVisible")]
		protected virtual void OnToggleCursorVisible ()
		{
			GLib.Value ret = GLib.Value.Empty;
			unsafe {
				GLib.Value* inst_and_params = stackalloc GLib.Value [1];
				using (inst_and_params[0] = new GLib.Value (this)) {
					g_signal_chain_from_overridden (inst_and_params, ref ret);
				}
			}
		}

		[GLib.Signal("toggle_cursor_visible")]
		public event System.EventHandler ToggleCursorVisible {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "toggle_cursor_visible");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "toggle_cursor_visible");
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_view_add_child_at_anchor(IntPtr raw, IntPtr child, IntPtr anchor);

		public void AddChildAtAnchor(Gtk.Widget child, Gtk.TextChildAnchor anchor) {
			Gtk.Application.AssertMainThread();
			gtk_text_view_add_child_at_anchor(Handle, child == null ? IntPtr.Zero : child.Handle, anchor == null ? IntPtr.Zero : anchor.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_view_add_child_in_window(IntPtr raw, IntPtr child, int which_window, int xpos, int ypos);

		public void AddChildInWindow(Gtk.Widget child, Gtk.TextWindowType which_window, int xpos, int ypos) {
			Gtk.Application.AssertMainThread();
			gtk_text_view_add_child_in_window(Handle, child == null ? IntPtr.Zero : child.Handle, (int) which_window, xpos, ypos);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_text_view_backward_display_line(IntPtr raw, ref Gtk.TextIter iter);

		public bool BackwardDisplayLine(ref Gtk.TextIter iter) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_text_view_backward_display_line(Handle, ref iter);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_text_view_backward_display_line_start(IntPtr raw, ref Gtk.TextIter iter);

		public bool BackwardDisplayLineStart(ref Gtk.TextIter iter) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_text_view_backward_display_line_start(Handle, ref iter);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_view_buffer_to_window_coords(IntPtr raw, int win, int buffer_x, int buffer_y, out int window_x, out int window_y);

		public void BufferToWindowCoords(Gtk.TextWindowType win, int buffer_x, int buffer_y, out int window_x, out int window_y) {
			Gtk.Application.AssertMainThread();
			gtk_text_view_buffer_to_window_coords(Handle, (int) win, buffer_x, buffer_y, out window_x, out window_y);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_text_view_forward_display_line(IntPtr raw, ref Gtk.TextIter iter);

		public bool ForwardDisplayLine(ref Gtk.TextIter iter) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_text_view_forward_display_line(Handle, ref iter);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_text_view_forward_display_line_end(IntPtr raw, ref Gtk.TextIter iter);

		public bool ForwardDisplayLineEnd(ref Gtk.TextIter iter) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_text_view_forward_display_line_end(Handle, ref iter);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_text_view_get_border_window_size(IntPtr raw, int type);

		public int GetBorderWindowSize(Gtk.TextWindowType type) {
			Gtk.Application.AssertMainThread();
			int raw_ret = gtk_text_view_get_border_window_size(Handle, (int) type);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_text_view_get_default_attributes(IntPtr raw);

		public Gtk.TextAttributes DefaultAttributes { 
			get {
				IntPtr raw_ret = gtk_text_view_get_default_attributes(Handle);
				Gtk.TextAttributes ret = raw_ret == IntPtr.Zero ? null : (Gtk.TextAttributes) GLib.Opaque.GetOpaque (raw_ret, typeof (Gtk.TextAttributes), true);
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_view_get_iter_at_location(IntPtr raw, ref Gtk.TextIter iter, int x, int y);

		public Gtk.TextIter GetIterAtLocation(int x, int y) {
			Gtk.TextIter iter;
			Gtk.Application.AssertMainThread();
			iter = new Gtk.TextIter();
			gtk_text_view_get_iter_at_location(Handle, ref iter, x, y);
			return iter;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_view_get_iter_at_position(IntPtr raw, ref Gtk.TextIter iter, out int trailing, int x, int y);

		public int GetIterAtPosition(Gtk.TextIter iter, int x, int y) {
			int trailing;
			Gtk.Application.AssertMainThread();
			gtk_text_view_get_iter_at_position(Handle, ref iter, out trailing, x, y);
			return trailing;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_view_get_iter_location(IntPtr raw, ref Gtk.TextIter iter, ref Gdk.Rectangle location);

		public Gdk.Rectangle GetIterLocation(Gtk.TextIter iter) {
			Gdk.Rectangle location;
			Gtk.Application.AssertMainThread();
			location = new Gdk.Rectangle();
			gtk_text_view_get_iter_location(Handle, ref iter, ref location);
			return location;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_view_get_line_at_y(IntPtr raw, ref Gtk.TextIter target_iter, int y, out int line_top);

		public void GetLineAtY(out Gtk.TextIter target_iter, int y, out int line_top) {
			Gtk.Application.AssertMainThread();
			target_iter = new Gtk.TextIter();
			gtk_text_view_get_line_at_y(Handle, ref target_iter, y, out line_top);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_view_get_line_yrange(IntPtr raw, ref Gtk.TextIter iter, out int y, out int height);

		public void GetLineYrange(Gtk.TextIter iter, out int y, out int height) {
			Gtk.Application.AssertMainThread();
			gtk_text_view_get_line_yrange(Handle, ref iter, out y, out height);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_text_view_get_type();

		static GLib.GType _gtype = new GLib.GType (gtk_text_view_get_type());
		public static new GLib.GType GType { 
			get {
								return _gtype;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_view_get_visible_rect(IntPtr raw, ref Gdk.Rectangle visible_rect);

		public Gdk.Rectangle VisibleRect { 
			get {
				Gdk.Rectangle visible_rect;
				Gtk.Application.AssertMainThread();
				visible_rect = new Gdk.Rectangle();
				gtk_text_view_get_visible_rect(Handle, ref visible_rect);
				return visible_rect;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_text_view_get_window(IntPtr raw, int win);

		public Gdk.Window GetWindow(Gtk.TextWindowType win) {
			Gtk.Application.AssertMainThread();
			IntPtr raw_ret = gtk_text_view_get_window(Handle, (int) win);
			Gdk.Window ret = GLib.Object.GetObject(raw_ret) as Gdk.Window;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_text_view_get_window_type(IntPtr raw, IntPtr window);

		public Gtk.TextWindowType GetWindowType(Gdk.Window window) {
			Gtk.Application.AssertMainThread();
			int raw_ret = gtk_text_view_get_window_type(Handle, window == null ? IntPtr.Zero : window.Handle);
			Gtk.TextWindowType ret = (Gtk.TextWindowType) raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_view_move_child(IntPtr raw, IntPtr child, int xpos, int ypos);

		public void MoveChild(Gtk.Widget child, int xpos, int ypos) {
			Gtk.Application.AssertMainThread();
			gtk_text_view_move_child(Handle, child == null ? IntPtr.Zero : child.Handle, xpos, ypos);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_text_view_move_mark_onscreen(IntPtr raw, IntPtr mark);

		public bool MoveMarkOnscreen(Gtk.TextMark mark) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_text_view_move_mark_onscreen(Handle, mark == null ? IntPtr.Zero : mark.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_text_view_move_visually(IntPtr raw, ref Gtk.TextIter iter, int count);

		public bool MoveVisually(ref Gtk.TextIter iter, int count) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_text_view_move_visually(Handle, ref iter, count);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_text_view_place_cursor_onscreen(IntPtr raw);

		public bool PlaceCursorOnscreen() {
			bool raw_ret = gtk_text_view_place_cursor_onscreen(Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_view_scroll_mark_onscreen(IntPtr raw, IntPtr mark);

		public void ScrollMarkOnscreen(Gtk.TextMark mark) {
			Gtk.Application.AssertMainThread();
			gtk_text_view_scroll_mark_onscreen(Handle, mark == null ? IntPtr.Zero : mark.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_text_view_scroll_to_iter(IntPtr raw, ref Gtk.TextIter iter, double within_margin, bool use_align, double xalign, double yalign);

		public bool ScrollToIter(Gtk.TextIter iter, double within_margin, bool use_align, double xalign, double yalign) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_text_view_scroll_to_iter(Handle, ref iter, within_margin, use_align, xalign, yalign);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_view_scroll_to_mark(IntPtr raw, IntPtr mark, double within_margin, bool use_align, double xalign, double yalign);

		public void ScrollToMark(Gtk.TextMark mark, double within_margin, bool use_align, double xalign, double yalign) {
			Gtk.Application.AssertMainThread();
			gtk_text_view_scroll_to_mark(Handle, mark == null ? IntPtr.Zero : mark.Handle, within_margin, use_align, xalign, yalign);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_view_set_border_window_size(IntPtr raw, int type, int size);

		public void SetBorderWindowSize(Gtk.TextWindowType type, int size) {
			Gtk.Application.AssertMainThread();
			gtk_text_view_set_border_window_size(Handle, (int) type, size);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_text_view_starts_display_line(IntPtr raw, ref Gtk.TextIter iter);

		public bool StartsDisplayLine(Gtk.TextIter iter) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_text_view_starts_display_line(Handle, ref iter);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_view_window_to_buffer_coords(IntPtr raw, int win, int window_x, int window_y, out int buffer_x, out int buffer_y);

		public void WindowToBufferCoords(Gtk.TextWindowType win, int window_x, int window_y, out int buffer_x, out int buffer_y) {
			Gtk.Application.AssertMainThread();
			gtk_text_view_window_to_buffer_coords(Handle, (int) win, window_x, window_y, out buffer_x, out buffer_y);
		}

#endregion
#region Customized extensions
#line 1 "TextView.custom"
// Gtk.TextView.custom - Gtk TextView class customizations
//
// Author: Mike Kestner <mkestner@ximian.com>
//
// Copyright (C) 2004 Novell, Inc.
//
// This code is inserted after the automatically generated code.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of version 2 of the Lesser GNU General
// Public License as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this program; if not, write to the
// Free Software Foundation, Inc., 59 Temple Place - Suite 330,
// Boston, MA 02111-1307, USA.


		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
		static extern IntPtr gtk_text_view_new_with_buffer (IntPtr buffer);

		public TextView (TextBuffer buffer) : base (IntPtr.Zero)
		{
			if (GetType() != typeof (TextView)) {
				CreateNativeObject (Array.Empty<IntPtr> (), Array.Empty<GLib.Value> (), 0);
				Buffer = buffer;
				return;
			}

			owned = true;
			Raw = gtk_text_view_new_with_buffer (buffer.Handle);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void MoveFocusSignalDelegate (IntPtr arg0, int arg1, IntPtr gch);

		static void MoveFocusSignalCallback (IntPtr arg0, int arg1, IntPtr gch)
		{
			Gtk.MoveFocusArgs args = new Gtk.MoveFocusArgs ();
			try {
				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
				if (sig == null)
					throw new Exception("Unknown signal GC handle received " + gch);

				args.Args = new object[1];
				args.Args[0] = (Gtk.DirectionType) arg1;
				Gtk.MoveFocusHandler handler = (Gtk.MoveFocusHandler) sig.Handler;
				handler (GLib.Object.GetObject (arg0), args);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void MoveFocusVMDelegate (IntPtr text_view, int direction);

		static MoveFocusVMDelegate MoveFocusVMCallback;

		static void movefocus_cb (IntPtr text_view, int direction)
		{
			try {
				TextView text_view_managed = GLib.Object.GetObject (text_view, false) as TextView;
				text_view_managed.OnMoveFocus ((Gtk.DirectionType) direction);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideMoveFocus (GLib.GType gtype)
		{
			if (MoveFocusVMCallback == null)
				MoveFocusVMCallback = new MoveFocusVMDelegate (movefocus_cb);
			OverrideVirtualMethod (gtype, "move_focus", MoveFocusVMCallback);
		}

		[Obsolete ("Replaced by keybinding signal on Gtk.Widget")]
		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TextView), ConnectionMethod="OverrideMoveFocus")]
		protected virtual void OnMoveFocus (Gtk.DirectionType direction)
		{
			GLib.Value ret = GLib.Value.Empty;
			unsafe {
				GLib.Value* inst_and_params = stackalloc GLib.Value [2];
				using (inst_and_params [0] = new GLib.Value (this)) {
					using (inst_and_params [1] = new GLib.Value (direction)) {
						g_signal_chain_from_overridden (inst_and_params, ref ret);
					}
				}
			}
		}

		[Obsolete ("Replaced by keybinding signal on Gtk.Widget")]
		[GLib.Signal("move_focus")]
		public event Gtk.MoveFocusHandler MoveFocus {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "move_focus", new MoveFocusSignalDelegate(MoveFocusSignalCallback));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "move_focus", new MoveFocusSignalDelegate(MoveFocusSignalCallback));
				sig.RemoveDelegate (value);
			}
		}

#endregion
	}

	internal class TextViewAttribute : GLib.GTypeTypeAttribute {
		[DllImport ("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_text_view_get_type ();

		private static GLib.GType _gtype = new GLib.GType (gtk_text_view_get_type ());
		public static GLib.GType GType { get { return _gtype; } }
		public override GLib.GType Type { get { return _gtype; } }

	}
}
