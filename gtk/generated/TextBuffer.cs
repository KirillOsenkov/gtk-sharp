// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gtk {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	[TextBuffer]
	public class TextBuffer : GLib.Object {

		[Obsolete]
		protected TextBuffer(GLib.GType gtype) : base(gtype) {}
		public TextBuffer(IntPtr raw) : base(raw) {}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_text_buffer_new(IntPtr table);

		public TextBuffer (Gtk.TextTagTable table) : base (IntPtr.Zero)
		{
			if (GetType () != typeof (TextBuffer)) {
				Gtk.Application.AssertMainThread();
				unsafe {
					var vals = stackalloc GLib.Value[1];
					var names = stackalloc IntPtr[1];
					var param_count = 0;
					if (table != null) {
						names[param_count] = GLib.Marshaller.StringToPtrGStrdup ("tag_table");
						vals[param_count++] = new GLib.Value (table);
					}
					CreateNativeObject (names, vals, param_count);
				}
				return;
			}
			Gtk.Application.AssertMainThread();
			owned = true;
			Raw = gtk_text_buffer_new(table == null ? IntPtr.Zero : table.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_text_buffer_get_tag_table(IntPtr raw);

		[GLib.Property ("tag-table")]
		public Gtk.TextTagTable TagTable {
			get  {
				IntPtr raw_ret = gtk_text_buffer_get_tag_table(Handle);
				Gtk.TextTagTable ret = GLib.Object.GetObject(raw_ret) as Gtk.TextTagTable;
				return ret;
			}
		}

		[GLib.Property ("text")]
		public string Text {
			get {
				using (GLib.Value val = GetProperty ("text")) {
					string ret = (string) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("text", val);
				}
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_text_buffer_get_has_selection(IntPtr raw);

		[GLib.Property ("has-selection")]
		public bool HasSelection {
			get  {
				bool raw_ret = gtk_text_buffer_get_has_selection(Handle);
				bool ret = raw_ret;
				return ret;
			}
		}

		[GLib.Property ("cursor-position")]
		public int CursorPosition {
			get {
				using (GLib.Value val = GetProperty ("cursor-position")) {
					int ret = (int) val;
					return ret;
				}
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_text_buffer_get_copy_target_list(IntPtr raw);

		[GLib.Property ("copy-target-list")]
		public Gtk.TargetList CopyTargetList {
			get  {
				IntPtr raw_ret = gtk_text_buffer_get_copy_target_list(Handle);
				Gtk.TargetList ret = raw_ret == IntPtr.Zero ? null : (Gtk.TargetList) GLib.Opaque.GetOpaque (raw_ret, typeof (Gtk.TargetList), false);
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_text_buffer_get_paste_target_list(IntPtr raw);

		[GLib.Property ("paste-target-list")]
		public Gtk.TargetList PasteTargetList {
			get  {
				IntPtr raw_ret = gtk_text_buffer_get_paste_target_list(Handle);
				Gtk.TargetList ret = raw_ret == IntPtr.Zero ? null : (Gtk.TargetList) GLib.Opaque.GetOpaque (raw_ret, typeof (Gtk.TargetList), false);
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_text_buffer_get_modified(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_set_modified(IntPtr raw, bool setting);

		public bool Modified {
			get  {
				bool raw_ret = gtk_text_buffer_get_modified(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_text_buffer_set_modified(Handle, value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void InsertTextVMDelegate (IntPtr buffer, IntPtr pos, IntPtr text, int length);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textbuffer_override_insert_text (IntPtr gtype, InsertTextVMDelegate cb);

		static InsertTextVMDelegate InsertTextVMCallback;

		static void inserttext_cb (IntPtr buffer, IntPtr pos, IntPtr text, int length)
		{
			try {
				TextBuffer buffer_managed = GLib.Object.GetObject (buffer, false) as TextBuffer;
				buffer_managed.OnInsertText (Gtk.TextIter.New (pos), GLib.Marshaller.Utf8PtrToString (text));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideInsertText (GLib.GType gtype)
		{
			if (InsertTextVMCallback == null)
				InsertTextVMCallback = new InsertTextVMDelegate (inserttext_cb);
			gtksharp_textbuffer_override_insert_text (gtype.Val, InsertTextVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textbuffer_base_insert_text (IntPtr buffer, ref Gtk.TextIter pos, IntPtr text, int length);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TextBuffer), ConnectionMethod="OverrideInsertText")]
		protected virtual void OnInsertText (Gtk.TextIter pos, string text)
		{
			Gtk.Application.AssertMainThread();
			IntPtr native_text = GLib.Marshaller.StringToPtrGStrdup (text);
			gtksharp_textbuffer_base_insert_text (Handle, ref pos, native_text, System.Text.Encoding.UTF8.GetByteCount (text));
			GLib.Marshaller.Free (native_text);
		}

		[GLib.Signal("insert_text")]
		public event Gtk.InsertTextHandler InsertText {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "insert_text", typeof (Gtk.InsertTextArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "insert_text", typeof (Gtk.InsertTextArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void PixbufInsertedVMDelegate (IntPtr buffer, IntPtr pos, IntPtr pixbuf);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textbuffer_override_insert_pixbuf (IntPtr gtype, PixbufInsertedVMDelegate cb);

		static PixbufInsertedVMDelegate PixbufInsertedVMCallback;

		static void pixbufinserted_cb (IntPtr buffer, IntPtr pos, IntPtr pixbuf)
		{
			try {
				TextBuffer buffer_managed = GLib.Object.GetObject (buffer, false) as TextBuffer;
				buffer_managed.OnPixbufInserted (Gtk.TextIter.New (pos), GLib.Object.GetObject(pixbuf) as Gdk.Pixbuf);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverridePixbufInserted (GLib.GType gtype)
		{
			if (PixbufInsertedVMCallback == null)
				PixbufInsertedVMCallback = new PixbufInsertedVMDelegate (pixbufinserted_cb);
			gtksharp_textbuffer_override_insert_pixbuf (gtype.Val, PixbufInsertedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textbuffer_base_insert_pixbuf (IntPtr buffer, ref Gtk.TextIter pos, IntPtr pixbuf);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TextBuffer), ConnectionMethod="OverridePixbufInserted")]
		protected virtual void OnPixbufInserted (Gtk.TextIter pos, Gdk.Pixbuf pixbuf)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_textbuffer_base_insert_pixbuf (Handle, ref pos, pixbuf == null ? IntPtr.Zero : pixbuf.Handle);
		}

		[GLib.Signal("insert_pixbuf")]
		public event Gtk.PixbufInsertedHandler PixbufInserted {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "insert_pixbuf", typeof (Gtk.PixbufInsertedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "insert_pixbuf", typeof (Gtk.PixbufInsertedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ChildAnchorInsertedVMDelegate (IntPtr buffer, IntPtr pos, IntPtr anchor);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textbuffer_override_insert_child_anchor (IntPtr gtype, ChildAnchorInsertedVMDelegate cb);

		static ChildAnchorInsertedVMDelegate ChildAnchorInsertedVMCallback;

		static void childanchorinserted_cb (IntPtr buffer, IntPtr pos, IntPtr anchor)
		{
			try {
				TextBuffer buffer_managed = GLib.Object.GetObject (buffer, false) as TextBuffer;
				buffer_managed.OnChildAnchorInserted (Gtk.TextIter.New (pos), GLib.Object.GetObject(anchor) as Gtk.TextChildAnchor);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideChildAnchorInserted (GLib.GType gtype)
		{
			if (ChildAnchorInsertedVMCallback == null)
				ChildAnchorInsertedVMCallback = new ChildAnchorInsertedVMDelegate (childanchorinserted_cb);
			gtksharp_textbuffer_override_insert_child_anchor (gtype.Val, ChildAnchorInsertedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textbuffer_base_insert_child_anchor (IntPtr buffer, ref Gtk.TextIter pos, IntPtr anchor);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TextBuffer), ConnectionMethod="OverrideChildAnchorInserted")]
		protected virtual void OnChildAnchorInserted (Gtk.TextIter pos, Gtk.TextChildAnchor anchor)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_textbuffer_base_insert_child_anchor (Handle, ref pos, anchor == null ? IntPtr.Zero : anchor.Handle);
		}

		[GLib.Signal("insert_child_anchor")]
		public event Gtk.ChildAnchorInsertedHandler ChildAnchorInserted {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "insert_child_anchor", typeof (Gtk.ChildAnchorInsertedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "insert_child_anchor", typeof (Gtk.ChildAnchorInsertedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DeleteRangeVMDelegate (IntPtr buffer, IntPtr start, IntPtr end);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textbuffer_override_delete_range (IntPtr gtype, DeleteRangeVMDelegate cb);

		static DeleteRangeVMDelegate DeleteRangeVMCallback;

		static void deleterange_cb (IntPtr buffer, IntPtr start, IntPtr end)
		{
			try {
				TextBuffer buffer_managed = GLib.Object.GetObject (buffer, false) as TextBuffer;
				buffer_managed.OnDeleteRange (Gtk.TextIter.New (start), Gtk.TextIter.New (end));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideDeleteRange (GLib.GType gtype)
		{
			if (DeleteRangeVMCallback == null)
				DeleteRangeVMCallback = new DeleteRangeVMDelegate (deleterange_cb);
			gtksharp_textbuffer_override_delete_range (gtype.Val, DeleteRangeVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textbuffer_base_delete_range (IntPtr buffer, ref Gtk.TextIter start, ref Gtk.TextIter end);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TextBuffer), ConnectionMethod="OverrideDeleteRange")]
		protected virtual void OnDeleteRange (Gtk.TextIter start, Gtk.TextIter end)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_textbuffer_base_delete_range (Handle, ref start, ref end);
		}

		[GLib.Signal("delete_range")]
		public event Gtk.DeleteRangeHandler DeleteRange {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "delete_range", typeof (Gtk.DeleteRangeArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "delete_range", typeof (Gtk.DeleteRangeArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ChangedVMDelegate (IntPtr buffer);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textbuffer_override_changed (IntPtr gtype, ChangedVMDelegate cb);

		static ChangedVMDelegate ChangedVMCallback;

		static void changed_cb (IntPtr buffer)
		{
			try {
				TextBuffer buffer_managed = GLib.Object.GetObject (buffer, false) as TextBuffer;
				buffer_managed.OnChanged ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideChanged (GLib.GType gtype)
		{
			if (ChangedVMCallback == null)
				ChangedVMCallback = new ChangedVMDelegate (changed_cb);
			gtksharp_textbuffer_override_changed (gtype.Val, ChangedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textbuffer_base_changed (IntPtr buffer);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TextBuffer), ConnectionMethod="OverrideChanged")]
		protected virtual void OnChanged ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_textbuffer_base_changed (Handle);
		}

		[GLib.Signal("changed")]
		public event System.EventHandler Changed {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "changed");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "changed");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ModifiedChangedVMDelegate (IntPtr buffer);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textbuffer_override_modified_changed (IntPtr gtype, ModifiedChangedVMDelegate cb);

		static ModifiedChangedVMDelegate ModifiedChangedVMCallback;

		static void modifiedchanged_cb (IntPtr buffer)
		{
			try {
				TextBuffer buffer_managed = GLib.Object.GetObject (buffer, false) as TextBuffer;
				buffer_managed.OnModifiedChanged ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideModifiedChanged (GLib.GType gtype)
		{
			if (ModifiedChangedVMCallback == null)
				ModifiedChangedVMCallback = new ModifiedChangedVMDelegate (modifiedchanged_cb);
			gtksharp_textbuffer_override_modified_changed (gtype.Val, ModifiedChangedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textbuffer_base_modified_changed (IntPtr buffer);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TextBuffer), ConnectionMethod="OverrideModifiedChanged")]
		protected virtual void OnModifiedChanged ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_textbuffer_base_modified_changed (Handle);
		}

		[GLib.Signal("modified_changed")]
		public event System.EventHandler ModifiedChanged {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "modified_changed");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "modified_changed");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void MarkSetVMDelegate (IntPtr buffer, IntPtr location, IntPtr mark);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textbuffer_override_mark_set (IntPtr gtype, MarkSetVMDelegate cb);

		static MarkSetVMDelegate MarkSetVMCallback;

		static void markset_cb (IntPtr buffer, IntPtr location, IntPtr mark)
		{
			try {
				TextBuffer buffer_managed = GLib.Object.GetObject (buffer, false) as TextBuffer;
				buffer_managed.OnMarkSet (Gtk.TextIter.New (location), GLib.Object.GetObject(mark) as Gtk.TextMark);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideMarkSet (GLib.GType gtype)
		{
			if (MarkSetVMCallback == null)
				MarkSetVMCallback = new MarkSetVMDelegate (markset_cb);
			gtksharp_textbuffer_override_mark_set (gtype.Val, MarkSetVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textbuffer_base_mark_set (IntPtr buffer, ref Gtk.TextIter location, IntPtr mark);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TextBuffer), ConnectionMethod="OverrideMarkSet")]
		protected virtual void OnMarkSet (Gtk.TextIter location, Gtk.TextMark mark)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_textbuffer_base_mark_set (Handle, ref location, mark == null ? IntPtr.Zero : mark.Handle);
		}

		[GLib.Signal("mark_set")]
		public event Gtk.MarkSetHandler MarkSet {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "mark_set", typeof (Gtk.MarkSetArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "mark_set", typeof (Gtk.MarkSetArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void MarkDeletedVMDelegate (IntPtr buffer, IntPtr mark);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textbuffer_override_mark_deleted (IntPtr gtype, MarkDeletedVMDelegate cb);

		static MarkDeletedVMDelegate MarkDeletedVMCallback;

		static void markdeleted_cb (IntPtr buffer, IntPtr mark)
		{
			try {
				TextBuffer buffer_managed = GLib.Object.GetObject (buffer, false) as TextBuffer;
				buffer_managed.OnMarkDeleted (GLib.Object.GetObject(mark) as Gtk.TextMark);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideMarkDeleted (GLib.GType gtype)
		{
			if (MarkDeletedVMCallback == null)
				MarkDeletedVMCallback = new MarkDeletedVMDelegate (markdeleted_cb);
			gtksharp_textbuffer_override_mark_deleted (gtype.Val, MarkDeletedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textbuffer_base_mark_deleted (IntPtr buffer, IntPtr mark);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TextBuffer), ConnectionMethod="OverrideMarkDeleted")]
		protected virtual void OnMarkDeleted (Gtk.TextMark mark)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_textbuffer_base_mark_deleted (Handle, mark == null ? IntPtr.Zero : mark.Handle);
		}

		[GLib.Signal("mark_deleted")]
		public event Gtk.MarkDeletedHandler MarkDeleted {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "mark_deleted", typeof (Gtk.MarkDeletedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "mark_deleted", typeof (Gtk.MarkDeletedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void TagAppliedVMDelegate (IntPtr buffer, IntPtr tag, IntPtr start_char, IntPtr end_char);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textbuffer_override_apply_tag (IntPtr gtype, TagAppliedVMDelegate cb);

		static TagAppliedVMDelegate TagAppliedVMCallback;

		static void tagapplied_cb (IntPtr buffer, IntPtr tag, IntPtr start_char, IntPtr end_char)
		{
			try {
				TextBuffer buffer_managed = GLib.Object.GetObject (buffer, false) as TextBuffer;
				buffer_managed.OnTagApplied (GLib.Object.GetObject(tag) as Gtk.TextTag, Gtk.TextIter.New (start_char), Gtk.TextIter.New (end_char));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideTagApplied (GLib.GType gtype)
		{
			if (TagAppliedVMCallback == null)
				TagAppliedVMCallback = new TagAppliedVMDelegate (tagapplied_cb);
			gtksharp_textbuffer_override_apply_tag (gtype.Val, TagAppliedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textbuffer_base_apply_tag (IntPtr buffer, IntPtr tag, ref Gtk.TextIter start_char, ref Gtk.TextIter end_char);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TextBuffer), ConnectionMethod="OverrideTagApplied")]
		protected virtual void OnTagApplied (Gtk.TextTag tag, Gtk.TextIter start_char, Gtk.TextIter end_char)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_textbuffer_base_apply_tag (Handle, tag == null ? IntPtr.Zero : tag.Handle, ref start_char, ref end_char);
		}

		[GLib.Signal("apply_tag")]
		public event Gtk.TagAppliedHandler TagApplied {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "apply_tag", typeof (Gtk.TagAppliedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "apply_tag", typeof (Gtk.TagAppliedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void TagRemovedVMDelegate (IntPtr buffer, IntPtr tag, IntPtr start_char, IntPtr end_char);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textbuffer_override_remove_tag (IntPtr gtype, TagRemovedVMDelegate cb);

		static TagRemovedVMDelegate TagRemovedVMCallback;

		static void tagremoved_cb (IntPtr buffer, IntPtr tag, IntPtr start_char, IntPtr end_char)
		{
			try {
				TextBuffer buffer_managed = GLib.Object.GetObject (buffer, false) as TextBuffer;
				buffer_managed.OnTagRemoved (GLib.Object.GetObject(tag) as Gtk.TextTag, Gtk.TextIter.New (start_char), Gtk.TextIter.New (end_char));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideTagRemoved (GLib.GType gtype)
		{
			if (TagRemovedVMCallback == null)
				TagRemovedVMCallback = new TagRemovedVMDelegate (tagremoved_cb);
			gtksharp_textbuffer_override_remove_tag (gtype.Val, TagRemovedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textbuffer_base_remove_tag (IntPtr buffer, IntPtr tag, ref Gtk.TextIter start_char, ref Gtk.TextIter end_char);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TextBuffer), ConnectionMethod="OverrideTagRemoved")]
		protected virtual void OnTagRemoved (Gtk.TextTag tag, Gtk.TextIter start_char, Gtk.TextIter end_char)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_textbuffer_base_remove_tag (Handle, tag == null ? IntPtr.Zero : tag.Handle, ref start_char, ref end_char);
		}

		[GLib.Signal("remove_tag")]
		public event Gtk.TagRemovedHandler TagRemoved {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "remove_tag", typeof (Gtk.TagRemovedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "remove_tag", typeof (Gtk.TagRemovedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void UserActionBegunVMDelegate (IntPtr buffer);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textbuffer_override_begin_user_action (IntPtr gtype, UserActionBegunVMDelegate cb);

		static UserActionBegunVMDelegate UserActionBegunVMCallback;

		static void useractionbegun_cb (IntPtr buffer)
		{
			try {
				TextBuffer buffer_managed = GLib.Object.GetObject (buffer, false) as TextBuffer;
				buffer_managed.OnUserActionBegun ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideUserActionBegun (GLib.GType gtype)
		{
			if (UserActionBegunVMCallback == null)
				UserActionBegunVMCallback = new UserActionBegunVMDelegate (useractionbegun_cb);
			gtksharp_textbuffer_override_begin_user_action (gtype.Val, UserActionBegunVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textbuffer_base_begin_user_action (IntPtr buffer);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TextBuffer), ConnectionMethod="OverrideUserActionBegun")]
		protected virtual void OnUserActionBegun ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_textbuffer_base_begin_user_action (Handle);
		}

		[GLib.Signal("begin_user_action")]
		public event System.EventHandler UserActionBegun {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "begin_user_action");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "begin_user_action");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void UserActionEndedVMDelegate (IntPtr buffer);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textbuffer_override_end_user_action (IntPtr gtype, UserActionEndedVMDelegate cb);

		static UserActionEndedVMDelegate UserActionEndedVMCallback;

		static void useractionended_cb (IntPtr buffer)
		{
			try {
				TextBuffer buffer_managed = GLib.Object.GetObject (buffer, false) as TextBuffer;
				buffer_managed.OnUserActionEnded ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideUserActionEnded (GLib.GType gtype)
		{
			if (UserActionEndedVMCallback == null)
				UserActionEndedVMCallback = new UserActionEndedVMDelegate (useractionended_cb);
			gtksharp_textbuffer_override_end_user_action (gtype.Val, UserActionEndedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_textbuffer_base_end_user_action (IntPtr buffer);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TextBuffer), ConnectionMethod="OverrideUserActionEnded")]
		protected virtual void OnUserActionEnded ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_textbuffer_base_end_user_action (Handle);
		}

		[GLib.Signal("end_user_action")]
		public event System.EventHandler UserActionEnded {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "end_user_action");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "end_user_action");
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_add_mark(IntPtr raw, IntPtr mark, ref Gtk.TextIter wh3r3);

		public void AddMark(Gtk.TextMark mark, Gtk.TextIter wh3r3) {
			Gtk.Application.AssertMainThread();
			gtk_text_buffer_add_mark(Handle, mark == null ? IntPtr.Zero : mark.Handle, ref wh3r3);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_add_selection_clipboard(IntPtr raw, IntPtr clipboard);

		public void AddSelectionClipboard(Gtk.Clipboard clipboard) {
			Gtk.Application.AssertMainThread();
			gtk_text_buffer_add_selection_clipboard(Handle, clipboard == null ? IntPtr.Zero : clipboard.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_apply_tag(IntPtr raw, IntPtr tag, ref Gtk.TextIter start, ref Gtk.TextIter end);

		public void ApplyTag(Gtk.TextTag tag, Gtk.TextIter start, Gtk.TextIter end) {
			Gtk.Application.AssertMainThread();
			gtk_text_buffer_apply_tag(Handle, tag == null ? IntPtr.Zero : tag.Handle, ref start, ref end);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_apply_tag_by_name(IntPtr raw, IntPtr name, ref Gtk.TextIter start, ref Gtk.TextIter end);

		public void ApplyTag(string name, Gtk.TextIter start, Gtk.TextIter end) {
			Gtk.Application.AssertMainThread();
			IntPtr native_name = GLib.Marshaller.StringToPtrGStrdup (name);
			gtk_text_buffer_apply_tag_by_name(Handle, native_name, ref start, ref end);
			GLib.Marshaller.Free (native_name);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_text_buffer_backspace(IntPtr raw, ref Gtk.TextIter iter, bool interactive, bool default_editable);

		public bool Backspace(ref Gtk.TextIter iter, bool interactive, bool default_editable) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_text_buffer_backspace(Handle, ref iter, interactive, default_editable);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_begin_user_action(IntPtr raw);

		public void BeginUserAction() {
			gtk_text_buffer_begin_user_action(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_copy_clipboard(IntPtr raw, IntPtr clipboard);

		public void CopyClipboard(Gtk.Clipboard clipboard) {
			Gtk.Application.AssertMainThread();
			gtk_text_buffer_copy_clipboard(Handle, clipboard == null ? IntPtr.Zero : clipboard.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_text_buffer_create_child_anchor(IntPtr raw, ref Gtk.TextIter iter);

		public Gtk.TextChildAnchor CreateChildAnchor(ref Gtk.TextIter iter) {
			Gtk.Application.AssertMainThread();
			IntPtr raw_ret = gtk_text_buffer_create_child_anchor(Handle, ref iter);
			Gtk.TextChildAnchor ret = GLib.Object.GetObject(raw_ret) as Gtk.TextChildAnchor;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_text_buffer_create_mark(IntPtr raw, IntPtr mark_name, ref Gtk.TextIter wh3r3, bool left_gravity);

		public Gtk.TextMark CreateMark(string mark_name, Gtk.TextIter wh3r3, bool left_gravity) {
			Gtk.Application.AssertMainThread();
			IntPtr native_mark_name = GLib.Marshaller.StringToPtrGStrdup (mark_name);
			IntPtr raw_ret = gtk_text_buffer_create_mark(Handle, native_mark_name, ref wh3r3, left_gravity);
			Gtk.TextMark ret = GLib.Object.GetObject(raw_ret) as Gtk.TextMark;
			GLib.Marshaller.Free (native_mark_name);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_cut_clipboard(IntPtr raw, IntPtr clipboard, bool default_editable);

		public void CutClipboard(Gtk.Clipboard clipboard, bool default_editable) {
			Gtk.Application.AssertMainThread();
			gtk_text_buffer_cut_clipboard(Handle, clipboard == null ? IntPtr.Zero : clipboard.Handle, default_editable);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_delete(IntPtr raw, ref Gtk.TextIter start, ref Gtk.TextIter end);

		public void Delete(ref Gtk.TextIter start, ref Gtk.TextIter end) {
			Gtk.Application.AssertMainThread();
			gtk_text_buffer_delete(Handle, ref start, ref end);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_text_buffer_delete_interactive(IntPtr raw, ref Gtk.TextIter start_iter, ref Gtk.TextIter end_iter, bool default_editable);

		public bool DeleteInteractive(ref Gtk.TextIter start_iter, ref Gtk.TextIter end_iter, bool default_editable) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_text_buffer_delete_interactive(Handle, ref start_iter, ref end_iter, default_editable);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_delete_mark(IntPtr raw, IntPtr mark);

		public void DeleteMark(Gtk.TextMark mark) {
			Gtk.Application.AssertMainThread();
			gtk_text_buffer_delete_mark(Handle, mark == null ? IntPtr.Zero : mark.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_delete_mark_by_name(IntPtr raw, IntPtr name);

		public void DeleteMark(string name) {
			Gtk.Application.AssertMainThread();
			IntPtr native_name = GLib.Marshaller.StringToPtrGStrdup (name);
			gtk_text_buffer_delete_mark_by_name(Handle, native_name);
			GLib.Marshaller.Free (native_name);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_text_buffer_delete_selection(IntPtr raw, bool interactive, bool default_editable);

		public bool DeleteSelection(bool interactive, bool default_editable) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_text_buffer_delete_selection(Handle, interactive, default_editable);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern unsafe bool gtk_text_buffer_deserialize(IntPtr raw, IntPtr content_buffer, IntPtr format, ref Gtk.TextIter iter, byte[] data, UIntPtr length, out IntPtr error);

		public unsafe bool Deserialize(Gtk.TextBuffer content_buffer, Gdk.Atom format, ref Gtk.TextIter iter, byte[] data, ulong length) {
			Gtk.Application.AssertMainThread();
			IntPtr error = IntPtr.Zero;
			bool raw_ret = gtk_text_buffer_deserialize(Handle, content_buffer == null ? IntPtr.Zero : content_buffer.Handle, format == null ? IntPtr.Zero : format.Handle, ref iter, data, new UIntPtr (length), out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_text_buffer_deserialize_get_can_create_tags(IntPtr raw, IntPtr format);

		public bool DeserializeGetCanCreateTags(Gdk.Atom format) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_text_buffer_deserialize_get_can_create_tags(Handle, format == null ? IntPtr.Zero : format.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_deserialize_set_can_create_tags(IntPtr raw, IntPtr format, bool can_create_tags);

		public void DeserializeSetCanCreateTags(Gdk.Atom format, bool can_create_tags) {
			Gtk.Application.AssertMainThread();
			gtk_text_buffer_deserialize_set_can_create_tags(Handle, format == null ? IntPtr.Zero : format.Handle, can_create_tags);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_end_user_action(IntPtr raw);

		public void EndUserAction() {
			gtk_text_buffer_end_user_action(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_get_bounds(IntPtr raw, ref Gtk.TextIter start, ref Gtk.TextIter end);

		public void GetBounds(out Gtk.TextIter start, out Gtk.TextIter end) {
			Gtk.Application.AssertMainThread();
			start = new Gtk.TextIter();
			end = new Gtk.TextIter();
			gtk_text_buffer_get_bounds(Handle, ref start, ref end);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_text_buffer_get_char_count(IntPtr raw);

		public int CharCount { 
			get {
				int raw_ret = gtk_text_buffer_get_char_count(Handle);
				int ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_get_end_iter(IntPtr raw, ref Gtk.TextIter iter);

		public Gtk.TextIter EndIter { 
			get {
				Gtk.TextIter iter;
				Gtk.Application.AssertMainThread();
				iter = new Gtk.TextIter();
				gtk_text_buffer_get_end_iter(Handle, ref iter);
				return iter;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_text_buffer_get_insert(IntPtr raw);

		public Gtk.TextMark InsertMark { 
			get {
				IntPtr raw_ret = gtk_text_buffer_get_insert(Handle);
				Gtk.TextMark ret = GLib.Object.GetObject(raw_ret) as Gtk.TextMark;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_get_iter_at_child_anchor(IntPtr raw, ref Gtk.TextIter iter, IntPtr anchor);

		public Gtk.TextIter GetIterAtChildAnchor(Gtk.TextChildAnchor anchor) {
			Gtk.TextIter iter;
			Gtk.Application.AssertMainThread();
			iter = new Gtk.TextIter();
			gtk_text_buffer_get_iter_at_child_anchor(Handle, ref iter, anchor == null ? IntPtr.Zero : anchor.Handle);
			return iter;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_get_iter_at_line(IntPtr raw, ref Gtk.TextIter iter, int line_number);

		public Gtk.TextIter GetIterAtLine(int line_number) {
			Gtk.TextIter iter;
			Gtk.Application.AssertMainThread();
			iter = new Gtk.TextIter();
			gtk_text_buffer_get_iter_at_line(Handle, ref iter, line_number);
			return iter;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_get_iter_at_line_index(IntPtr raw, ref Gtk.TextIter iter, int line_number, int byte_index);

		public Gtk.TextIter GetIterAtLineIndex(int line_number, int byte_index) {
			Gtk.TextIter iter;
			Gtk.Application.AssertMainThread();
			iter = new Gtk.TextIter();
			gtk_text_buffer_get_iter_at_line_index(Handle, ref iter, line_number, byte_index);
			return iter;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_get_iter_at_line_offset(IntPtr raw, ref Gtk.TextIter iter, int line_number, int char_offset);

		public Gtk.TextIter GetIterAtLineOffset(int line_number, int char_offset) {
			Gtk.TextIter iter;
			Gtk.Application.AssertMainThread();
			iter = new Gtk.TextIter();
			gtk_text_buffer_get_iter_at_line_offset(Handle, ref iter, line_number, char_offset);
			return iter;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_get_iter_at_mark(IntPtr raw, ref Gtk.TextIter iter, IntPtr mark);

		public Gtk.TextIter GetIterAtMark(Gtk.TextMark mark) {
			Gtk.TextIter iter;
			Gtk.Application.AssertMainThread();
			iter = new Gtk.TextIter();
			gtk_text_buffer_get_iter_at_mark(Handle, ref iter, mark == null ? IntPtr.Zero : mark.Handle);
			return iter;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_get_iter_at_offset(IntPtr raw, ref Gtk.TextIter iter, int char_offset);

		public Gtk.TextIter GetIterAtOffset(int char_offset) {
			Gtk.TextIter iter;
			Gtk.Application.AssertMainThread();
			iter = new Gtk.TextIter();
			gtk_text_buffer_get_iter_at_offset(Handle, ref iter, char_offset);
			return iter;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_text_buffer_get_line_count(IntPtr raw);

		public int LineCount { 
			get {
				int raw_ret = gtk_text_buffer_get_line_count(Handle);
				int ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_text_buffer_get_mark(IntPtr raw, IntPtr name);

		public Gtk.TextMark GetMark(string name) {
			Gtk.Application.AssertMainThread();
			IntPtr native_name = GLib.Marshaller.StringToPtrGStrdup (name);
			IntPtr raw_ret = gtk_text_buffer_get_mark(Handle, native_name);
			Gtk.TextMark ret = GLib.Object.GetObject(raw_ret) as Gtk.TextMark;
			GLib.Marshaller.Free (native_name);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_text_buffer_get_selection_bound(IntPtr raw);

		public Gtk.TextMark SelectionBound { 
			get {
				IntPtr raw_ret = gtk_text_buffer_get_selection_bound(Handle);
				Gtk.TextMark ret = GLib.Object.GetObject(raw_ret) as Gtk.TextMark;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_text_buffer_get_selection_bounds(IntPtr raw, ref Gtk.TextIter start, ref Gtk.TextIter end);

		public bool GetSelectionBounds(out Gtk.TextIter start, out Gtk.TextIter end) {
			Gtk.Application.AssertMainThread();
			start = new Gtk.TextIter();
			end = new Gtk.TextIter();
			bool raw_ret = gtk_text_buffer_get_selection_bounds(Handle, ref start, ref end);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_text_buffer_get_slice(IntPtr raw, ref Gtk.TextIter start, ref Gtk.TextIter end, bool include_hidden_chars);

		public string GetSlice(Gtk.TextIter start, Gtk.TextIter end, bool include_hidden_chars) {
			Gtk.Application.AssertMainThread();
			IntPtr raw_ret = gtk_text_buffer_get_slice(Handle, ref start, ref end, include_hidden_chars);
			string ret = GLib.Marshaller.PtrToStringGFree(raw_ret);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_get_start_iter(IntPtr raw, ref Gtk.TextIter iter);

		public Gtk.TextIter StartIter { 
			get {
				Gtk.TextIter iter;
				Gtk.Application.AssertMainThread();
				iter = new Gtk.TextIter();
				gtk_text_buffer_get_start_iter(Handle, ref iter);
				return iter;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_text_buffer_get_text(IntPtr raw, ref Gtk.TextIter start, ref Gtk.TextIter end, bool include_hidden_chars);

		public string GetText(Gtk.TextIter start, Gtk.TextIter end, bool include_hidden_chars) {
			Gtk.Application.AssertMainThread();
			IntPtr raw_ret = gtk_text_buffer_get_text(Handle, ref start, ref end, include_hidden_chars);
			string ret = GLib.Marshaller.PtrToStringGFree(raw_ret);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_text_buffer_get_type();

		static GLib.GType _gtype = new GLib.GType (gtk_text_buffer_get_type());
		public static new GLib.GType GType { 
			get {
								return _gtype;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_insert_child_anchor(IntPtr raw, ref Gtk.TextIter iter, IntPtr anchor);

		public void InsertChildAnchor(ref Gtk.TextIter iter, Gtk.TextChildAnchor anchor) {
			Gtk.Application.AssertMainThread();
			gtk_text_buffer_insert_child_anchor(Handle, ref iter, anchor == null ? IntPtr.Zero : anchor.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_insert_pixbuf(IntPtr raw, ref Gtk.TextIter iter, IntPtr pixbuf);

		public void InsertPixbuf(ref Gtk.TextIter iter, Gdk.Pixbuf pixbuf) {
			Gtk.Application.AssertMainThread();
			gtk_text_buffer_insert_pixbuf(Handle, ref iter, pixbuf == null ? IntPtr.Zero : pixbuf.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_insert_range(IntPtr raw, ref Gtk.TextIter iter, ref Gtk.TextIter start, ref Gtk.TextIter end);

		public void InsertRange(ref Gtk.TextIter iter, Gtk.TextIter start, Gtk.TextIter end) {
			Gtk.Application.AssertMainThread();
			gtk_text_buffer_insert_range(Handle, ref iter, ref start, ref end);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_text_buffer_insert_range_interactive(IntPtr raw, ref Gtk.TextIter iter, ref Gtk.TextIter start, ref Gtk.TextIter end, bool default_editable);

		public bool InsertRangeInteractive(ref Gtk.TextIter iter, Gtk.TextIter start, Gtk.TextIter end, bool default_editable) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_text_buffer_insert_range_interactive(Handle, ref iter, ref start, ref end, default_editable);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_move_mark(IntPtr raw, IntPtr mark, ref Gtk.TextIter wh3r3);

		public void MoveMark(Gtk.TextMark mark, Gtk.TextIter wh3r3) {
			Gtk.Application.AssertMainThread();
			gtk_text_buffer_move_mark(Handle, mark == null ? IntPtr.Zero : mark.Handle, ref wh3r3);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_move_mark_by_name(IntPtr raw, IntPtr name, ref Gtk.TextIter wh3r3);

		public void MoveMark(string name, Gtk.TextIter wh3r3) {
			Gtk.Application.AssertMainThread();
			IntPtr native_name = GLib.Marshaller.StringToPtrGStrdup (name);
			gtk_text_buffer_move_mark_by_name(Handle, native_name, ref wh3r3);
			GLib.Marshaller.Free (native_name);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_paste_clipboard(IntPtr raw, IntPtr clipboard, ref Gtk.TextIter override_location, bool default_editable);

		public void PasteClipboard(Gtk.Clipboard clipboard, ref Gtk.TextIter override_location, bool default_editable) {
			Gtk.Application.AssertMainThread();
			gtk_text_buffer_paste_clipboard(Handle, clipboard == null ? IntPtr.Zero : clipboard.Handle, ref override_location, default_editable);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_place_cursor(IntPtr raw, ref Gtk.TextIter wh3r3);

		public void PlaceCursor(Gtk.TextIter wh3r3) {
			Gtk.Application.AssertMainThread();
			gtk_text_buffer_place_cursor(Handle, ref wh3r3);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_text_buffer_register_deserialize_format(IntPtr raw, IntPtr mime_type, GtkSharp.TextBufferDeserializeFuncNative function, IntPtr user_data, GLib.DestroyNotify user_data_destroy);

		public Gdk.Atom RegisterDeserializeFormat(string mime_type, Gtk.TextBufferDeserializeFunc function) {
			Gtk.Application.AssertMainThread();
			IntPtr native_mime_type = GLib.Marshaller.StringToPtrGStrdup (mime_type);
			IntPtr user_data;
			GLib.DestroyNotify user_data_destroy;
			if (function == null) {
				user_data = IntPtr.Zero;
				user_data_destroy = null;
			} else {
				user_data = (IntPtr) GCHandle.Alloc (function);
				user_data_destroy = GLib.DestroyHelper.NotifyHandler;
			}
			IntPtr raw_ret = gtk_text_buffer_register_deserialize_format(Handle, native_mime_type, (function == null) ? null : GtkSharp.TextBufferDeserializeFuncWrapper.NativeDelegate, user_data, user_data_destroy);
			Gdk.Atom ret = raw_ret == IntPtr.Zero ? null : (Gdk.Atom) GLib.Opaque.GetOpaque (raw_ret, typeof (Gdk.Atom), false);
			GLib.Marshaller.Free (native_mime_type);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_text_buffer_register_deserialize_tagset(IntPtr raw, IntPtr tagset_name);

		public Gdk.Atom RegisterDeserializeTagset(string tagset_name) {
			Gtk.Application.AssertMainThread();
			IntPtr native_tagset_name = GLib.Marshaller.StringToPtrGStrdup (tagset_name);
			IntPtr raw_ret = gtk_text_buffer_register_deserialize_tagset(Handle, native_tagset_name);
			Gdk.Atom ret = raw_ret == IntPtr.Zero ? null : (Gdk.Atom) GLib.Opaque.GetOpaque (raw_ret, typeof (Gdk.Atom), false);
			GLib.Marshaller.Free (native_tagset_name);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_text_buffer_register_serialize_tagset(IntPtr raw, IntPtr tagset_name);

		public Gdk.Atom RegisterSerializeTagset(string tagset_name) {
			Gtk.Application.AssertMainThread();
			IntPtr native_tagset_name = GLib.Marshaller.StringToPtrGStrdup (tagset_name);
			IntPtr raw_ret = gtk_text_buffer_register_serialize_tagset(Handle, native_tagset_name);
			Gdk.Atom ret = raw_ret == IntPtr.Zero ? null : (Gdk.Atom) GLib.Opaque.GetOpaque (raw_ret, typeof (Gdk.Atom), false);
			GLib.Marshaller.Free (native_tagset_name);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_remove_all_tags(IntPtr raw, ref Gtk.TextIter start, ref Gtk.TextIter end);

		public void RemoveAllTags(Gtk.TextIter start, Gtk.TextIter end) {
			Gtk.Application.AssertMainThread();
			gtk_text_buffer_remove_all_tags(Handle, ref start, ref end);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_remove_selection_clipboard(IntPtr raw, IntPtr clipboard);

		public void RemoveSelectionClipboard(Gtk.Clipboard clipboard) {
			Gtk.Application.AssertMainThread();
			gtk_text_buffer_remove_selection_clipboard(Handle, clipboard == null ? IntPtr.Zero : clipboard.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_remove_tag(IntPtr raw, IntPtr tag, ref Gtk.TextIter start, ref Gtk.TextIter end);

		public void RemoveTag(Gtk.TextTag tag, Gtk.TextIter start, Gtk.TextIter end) {
			Gtk.Application.AssertMainThread();
			gtk_text_buffer_remove_tag(Handle, tag == null ? IntPtr.Zero : tag.Handle, ref start, ref end);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_remove_tag_by_name(IntPtr raw, IntPtr name, ref Gtk.TextIter start, ref Gtk.TextIter end);

		public void RemoveTag(string name, Gtk.TextIter start, Gtk.TextIter end) {
			Gtk.Application.AssertMainThread();
			IntPtr native_name = GLib.Marshaller.StringToPtrGStrdup (name);
			gtk_text_buffer_remove_tag_by_name(Handle, native_name, ref start, ref end);
			GLib.Marshaller.Free (native_name);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_select_range(IntPtr raw, ref Gtk.TextIter ins, ref Gtk.TextIter bound);

		public void SelectRange(Gtk.TextIter ins, Gtk.TextIter bound) {
			Gtk.Application.AssertMainThread();
			gtk_text_buffer_select_range(Handle, ref ins, ref bound);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_unregister_deserialize_format(IntPtr raw, IntPtr format);

		public void UnregisterDeserializeFormat(Gdk.Atom format) {
			Gtk.Application.AssertMainThread();
			gtk_text_buffer_unregister_deserialize_format(Handle, format == null ? IntPtr.Zero : format.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_text_buffer_unregister_serialize_format(IntPtr raw, IntPtr format);

		public void UnregisterSerializeFormat(Gdk.Atom format) {
			Gtk.Application.AssertMainThread();
			gtk_text_buffer_unregister_serialize_format(Handle, format == null ? IntPtr.Zero : format.Handle);
		}

#endregion
#region Customized extensions
#line 1 "TextBuffer.custom"
// TextBuffer.custom - customizations to Gtk.TextBuffer.
// 
// Authors:  Mike Kestner  <mkestner@ximian.com>
//
// Copyright (c) 2004-2006  Novell, Inc.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of version 2 of the Lesser GNU General 
// Public License as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this program; if not, write to the
// Free Software Foundation, Inc., 59 Temple Place - Suite 330,
// Boston, MA 02111-1307, USA.


[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
static extern void gtk_text_buffer_set_text (IntPtr raw, IntPtr text, int len);

#if !GTK_SHARP_2_8
public string Text {
	get {
		return GetText (StartIter, EndIter, false);
	}
	set {
		IntPtr native = GLib.Marshaller.StringToPtrGStrdup (value);
		gtk_text_buffer_set_text (Handle, native, -1);
		GLib.Marshaller.Free (native);
	}
}
#endif

public void Clear ()
{
	Gtk.TextIter start = StartIter, end = EndIter;
	Delete (ref start, ref end);
}

[Obsolete ("Replaced by 'ref TextIter, ref TextIter' overload")]
public void Delete (TextIter start, TextIter end )
{
	Delete (ref start, ref end);
}

[DllImport("libgtk-win32-2.0-0.dll", EntryPoint="gtk_text_buffer_paste_clipboard", CallingConvention = CallingConvention.Cdecl)]
static extern void gtk_text_buffer_paste_clipboard_ptr(IntPtr raw, IntPtr clipboard, IntPtr override_location, bool default_editable);

// overload to paste clipboard contents at cursor editable by default.
public void PasteClipboard (Gtk.Clipboard clipboard)
{
	gtk_text_buffer_paste_clipboard_ptr(Handle, clipboard.Handle, IntPtr.Zero, true);
}

[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
static extern void gtk_text_buffer_insert (IntPtr raw, ref Gtk.TextIter iter, IntPtr text, int len);

[Obsolete ("Replaced by 'ref TextIter iter' overload")]
public void Insert (TextIter iter, string text)
{
	Insert (ref iter, text);
}

public void Insert (ref Gtk.TextIter iter, string text)
{
	IntPtr native = GLib.Marshaller.StringToPtrGStrdup (text);
	gtk_text_buffer_insert (Handle, ref iter, native, -1);
	GLib.Marshaller.Free (native);
}

[Obsolete ("Replaced by 'ref TextIter iter' overload")]
public void InsertRange (TextIter iter, TextIter start, TextIter end )
{
	InsertRange (ref iter, start, end);
}

[Obsolete ("Replaced by 'ref TextIter iter' overload")]
public void InsertWithTags (TextIter iter, string text, params TextTag[] tags)
{
	InsertWithTags (ref iter, text, tags);
}

public void InsertWithTags (ref TextIter iter, string text, params TextTag[] tags)
{
	TextIter start;
	int offset = iter.Offset;
	Insert (ref iter, text);

	start = GetIterAtOffset (offset);
	iter = GetIterAtOffset (offset + text.Length);

	foreach (TextTag t in tags)
		this.ApplyTag (t, start, iter);
}

public void InsertWithTagsByName (ref TextIter iter, string text, params string[] tagnames)
{
	TextIter start;
	int offset = iter.Offset;
	Insert (ref iter, text);

	start = GetIterAtOffset (offset);
	iter = GetIterAtOffset (offset + text.Length);

	foreach (string tagname in tagnames) {
		TextTag tag = TagTable.Lookup (tagname);
		if (tag != null)
			this.ApplyTag (tag, start, iter);
	}
}

[Obsolete("Use the TextBuffer.Text property's setter")]
public void SetText (string text)
{
	Text = text;
}

[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
static extern bool gtk_text_buffer_insert_interactive(IntPtr raw, ref Gtk.TextIter iter, IntPtr text, int len, bool default_editable);

public bool InsertInteractive(ref Gtk.TextIter iter, string text, bool default_editable)
{
	IntPtr native = GLib.Marshaller.StringToPtrGStrdup (text);
	bool result = gtk_text_buffer_insert_interactive(Handle, ref iter, native, -1, default_editable);
	GLib.Marshaller.Free (native);
	return result;
}

[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
static extern bool gtk_text_buffer_insert_interactive_at_cursor(IntPtr raw, IntPtr text, int len, bool default_editable);

public bool InsertInteractiveAtCursor(string text, bool default_editable) 
{
	IntPtr native = GLib.Marshaller.StringToPtrGStrdup (text);
	bool result = gtk_text_buffer_insert_interactive_at_cursor(Handle, native, -1, default_editable);
	GLib.Marshaller.Free (native);
	return result;
}

[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
static extern void gtk_text_buffer_insert_at_cursor(IntPtr raw, IntPtr text, int len);

public void InsertAtCursor(string text) 
{
	IntPtr native = GLib.Marshaller.StringToPtrGStrdup (text);
	gtk_text_buffer_insert_at_cursor(Handle, native, -1);
	GLib.Marshaller.Free (native);
}

[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
static extern IntPtr gtk_text_buffer_serialize (IntPtr raw, IntPtr content_buffer, IntPtr format, ref Gtk.TextIter start, ref Gtk.TextIter end, out UIntPtr length);

public byte[] Serialize(Gtk.TextBuffer content_buffer, Gdk.Atom format, Gtk.TextIter start, Gtk.TextIter end) 
{
	UIntPtr length;
	IntPtr raw_ret = gtk_text_buffer_serialize (Handle, content_buffer == null ? IntPtr.Zero : content_buffer.Handle, format == null ? IntPtr.Zero : format.Handle, ref start, ref end, out length);
	if (raw_ret == IntPtr.Zero)
		return new byte [0];
	int sz = (int) (uint) length;
	byte[] ret = new byte [sz];
	Marshal.Copy (raw_ret, ret, 0, sz);
	GLib.Marshaller.Free (raw_ret);
	return ret;
}

[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
static extern IntPtr gtk_text_buffer_get_serialize_formats(IntPtr raw, out int n_formats);

[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
static extern IntPtr gtk_text_buffer_get_deserialize_formats(IntPtr raw, out int n_formats);

public Gdk.Atom[] DeserializeFormats {
	get {
		int n_formats;
		IntPtr raw_ret = gtk_text_buffer_get_deserialize_formats(Handle, out n_formats);
		Gdk.Atom[] result = new Gdk.Atom [n_formats];
		for (int i = 0; i < n_formats; i++) {
			IntPtr format = Marshal.ReadIntPtr (raw_ret, i * IntPtr.Size);
			result [i] = format == IntPtr.Zero ? null : (Gdk.Atom) GLib.Opaque.GetOpaque (format, typeof (Gdk.Atom), false);
		}
		GLib.Marshaller.Free (raw_ret);
		return result;
	}
}

public Gdk.Atom[] SerializeFormats {
	get {
		int n_formats;
		IntPtr raw_ret = gtk_text_buffer_get_serialize_formats(Handle, out n_formats);
		Gdk.Atom[] result = new Gdk.Atom [n_formats];
		for (int i = 0; i < n_formats; i++) {
			IntPtr format = Marshal.ReadIntPtr (raw_ret, i * IntPtr.Size);
			result [i] = format == IntPtr.Zero ? null : (Gdk.Atom) GLib.Opaque.GetOpaque (format, typeof (Gdk.Atom), false);
		}
		GLib.Marshaller.Free (raw_ret);
		return result;
	}
}

// This is directly copied from the old generated/TextBuffer.cs
// It is no longer generated due to the manual implementation of TextBufferSerializeFunc
// See https://bugzilla.novell.com/show_bug.cgi?id=555495 and textbuffer-serializefunc.patch
[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
static extern IntPtr gtk_text_buffer_register_serialize_format(IntPtr raw, IntPtr mime_type, GtkSharp.TextBufferSerializeFuncNative function, IntPtr user_data, GLib.DestroyNotify user_data_destroy);

public Gdk.Atom RegisterSerializeFormat(string mime_type, Gtk.TextBufferSerializeFunc function) {
	IntPtr native_mime_type = GLib.Marshaller.StringToPtrGStrdup (mime_type);
	IntPtr user_data;
	GLib.DestroyNotify user_data_destroy;
	if (function == null) {
		user_data = IntPtr.Zero;
		user_data_destroy = null;
	} else {
		user_data = (IntPtr) GCHandle.Alloc (function);
		user_data_destroy = GLib.DestroyHelper.NotifyHandler;
	}
	IntPtr raw_ret = gtk_text_buffer_register_serialize_format(Handle, native_mime_type, GtkSharp.TextBufferSerializeFuncWrapper.NativeDelegate, user_data, user_data_destroy);
	Gdk.Atom ret = raw_ret == IntPtr.Zero ? null : (Gdk.Atom) GLib.Opaque.GetOpaque (raw_ret, typeof (Gdk.Atom), false);
	GLib.Marshaller.Free (native_mime_type);
	return ret;
}


#endregion
	}

	internal class TextBufferAttribute : GLib.GTypeTypeAttribute {
		[DllImport ("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_text_buffer_get_type ();

		private static GLib.GType _gtype = new GLib.GType (gtk_text_buffer_get_type ());
		public static GLib.GType GType { get { return _gtype; } }
		public override GLib.GType Type { get { return _gtype; } }

	}
}
