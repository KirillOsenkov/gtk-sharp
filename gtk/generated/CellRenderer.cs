// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gtk {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	[CellRenderer]
	public class CellRenderer : Gtk.Object {

		[Obsolete]
		protected CellRenderer(GLib.GType gtype) : base(gtype) {}
		public CellRenderer(IntPtr raw) : base(raw) {}

		protected CellRenderer() : base(IntPtr.Zero)
		{
			CreateNativeObject (Array.Empty<IntPtr> (), Array.Empty<GLib.Value> (), 0);
		}

		[GLib.Property ("mode")]
		public Gtk.CellRendererMode Mode {
			get {
				using (GLib.Value val = GetProperty ("mode")) {
					Gtk.CellRendererMode ret = (Gtk.CellRendererMode) (Enum) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value((Enum) value)) {
					SetProperty("mode", val);
				}
			}
		}

		[GLib.Property ("visible")]
		public bool Visible {
			get {
				using (GLib.Value val = GetProperty ("visible")) {
					bool ret = (bool) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("visible", val);
				}
			}
		}

		[GLib.Property ("sensitive")]
		public bool Sensitive {
			get {
				using (GLib.Value val = GetProperty ("sensitive")) {
					bool ret = (bool) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("sensitive", val);
				}
			}
		}

		[GLib.Property ("xalign")]
		public float Xalign {
			get {
				using (GLib.Value val = GetProperty ("xalign")) {
					float ret = (float) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("xalign", val);
				}
			}
		}

		[GLib.Property ("yalign")]
		public float Yalign {
			get {
				using (GLib.Value val = GetProperty ("yalign")) {
					float ret = (float) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("yalign", val);
				}
			}
		}

		[GLib.Property ("xpad")]
		public uint Xpad {
			get {
				using (GLib.Value val = GetProperty ("xpad")) {
					uint ret = (uint) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("xpad", val);
				}
			}
		}

		[GLib.Property ("ypad")]
		public uint Ypad {
			get {
				using (GLib.Value val = GetProperty ("ypad")) {
					uint ret = (uint) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("ypad", val);
				}
			}
		}

		[GLib.Property ("width")]
		public int Width {
			get {
				using (GLib.Value val = GetProperty ("width")) {
					int ret = (int) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("width", val);
				}
			}
		}

		[GLib.Property ("height")]
		public int Height {
			get {
				using (GLib.Value val = GetProperty ("height")) {
					int ret = (int) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("height", val);
				}
			}
		}

		[GLib.Property ("is-expander")]
		public bool IsExpander {
			get {
				using (GLib.Value val = GetProperty ("is-expander")) {
					bool ret = (bool) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("is-expander", val);
				}
			}
		}

		[GLib.Property ("is-expanded")]
		public bool IsExpanded {
			get {
				using (GLib.Value val = GetProperty ("is-expanded")) {
					bool ret = (bool) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("is-expanded", val);
				}
			}
		}

		[GLib.Property ("cell-background")]
		public string CellBackground {
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("cell-background", val);
				}
			}
		}

		[GLib.Property ("cell-background-gdk")]
		public Gdk.Color CellBackgroundGdk {
			get {
				using (GLib.Value val = GetProperty ("cell-background-gdk")) {
					Gdk.Color ret = (Gdk.Color) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = (GLib.Value) value) {
					SetProperty("cell-background-gdk", val);
				}
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void EditingCanceledVMDelegate (IntPtr cell);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_cellrenderer_override_editing_canceled (IntPtr gtype, EditingCanceledVMDelegate cb);

		static EditingCanceledVMDelegate EditingCanceledVMCallback;

		static void editingcanceled_cb (IntPtr cell)
		{
			try {
				CellRenderer cell_managed = GLib.Object.GetObject (cell, false) as CellRenderer;
				cell_managed.OnEditingCanceled ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideEditingCanceled (GLib.GType gtype)
		{
			if (EditingCanceledVMCallback == null)
				EditingCanceledVMCallback = new EditingCanceledVMDelegate (editingcanceled_cb);
			gtksharp_cellrenderer_override_editing_canceled (gtype.Val, EditingCanceledVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_cellrenderer_base_editing_canceled (IntPtr cell);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.CellRenderer), ConnectionMethod="OverrideEditingCanceled")]
		protected virtual void OnEditingCanceled ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_cellrenderer_base_editing_canceled (Handle);
		}

		[GLib.Signal("editing-canceled")]
		public event System.EventHandler EditingCanceled {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "editing-canceled");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "editing-canceled");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void EditingStartedVMDelegate (IntPtr cell, IntPtr editable, IntPtr path);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_cellrenderer_override_editing_started (IntPtr gtype, EditingStartedVMDelegate cb);

		static EditingStartedVMDelegate EditingStartedVMCallback;

		static void editingstarted_cb (IntPtr cell, IntPtr editable, IntPtr path)
		{
			try {
				CellRenderer cell_managed = GLib.Object.GetObject (cell, false) as CellRenderer;
				cell_managed.OnEditingStarted (Gtk.CellEditableAdapter.GetObject (editable, false), GLib.Marshaller.Utf8PtrToString (path));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideEditingStarted (GLib.GType gtype)
		{
			if (EditingStartedVMCallback == null)
				EditingStartedVMCallback = new EditingStartedVMDelegate (editingstarted_cb);
			gtksharp_cellrenderer_override_editing_started (gtype.Val, EditingStartedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_cellrenderer_base_editing_started (IntPtr cell, IntPtr editable, IntPtr path);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.CellRenderer), ConnectionMethod="OverrideEditingStarted")]
		protected virtual void OnEditingStarted (Gtk.CellEditable editable, string path)
		{
			Gtk.Application.AssertMainThread();
			IntPtr native_path = GLib.Marshaller.StringToPtrGStrdup (path);
			gtksharp_cellrenderer_base_editing_started (Handle, editable == null ? IntPtr.Zero : editable.Handle, native_path);
			GLib.Marshaller.Free (native_path);
		}

		[GLib.Signal("editing-started")]
		public event Gtk.EditingStartedHandler EditingStarted {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "editing-started", typeof (Gtk.EditingStartedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "editing-started", typeof (Gtk.EditingStartedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_cell_renderer_activate(IntPtr raw, IntPtr evnt, IntPtr widget, IntPtr path, ref Gdk.Rectangle background_area, ref Gdk.Rectangle cell_area, int flags);

		public bool Activate(Gdk.Event evnt, Gtk.Widget widget, string path, Gdk.Rectangle background_area, Gdk.Rectangle cell_area, Gtk.CellRendererState flags) {
			Gtk.Application.AssertMainThread();
			IntPtr native_path = GLib.Marshaller.StringToPtrGStrdup (path);
			bool raw_ret = gtk_cell_renderer_activate(Handle, evnt == null ? IntPtr.Zero : evnt.Handle, widget == null ? IntPtr.Zero : widget.Handle, native_path, ref background_area, ref cell_area, (int) flags);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_path);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_cell_renderer_editing_canceled(IntPtr raw);

		[Obsolete]
		public void CancelEditing() {
			gtk_cell_renderer_editing_canceled(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_cell_renderer_get_fixed_size(IntPtr raw, out int width, out int height);

		public void GetFixedSize(out int width, out int height) {
			Gtk.Application.AssertMainThread();
			gtk_cell_renderer_get_fixed_size(Handle, out width, out height);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_cell_renderer_get_type();

		static GLib.GType _gtype = new GLib.GType (gtk_cell_renderer_get_type());
		public static new GLib.GType GType { 
			get {
								return _gtype;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_cell_renderer_render(IntPtr raw, IntPtr window, IntPtr widget, ref Gdk.Rectangle background_area, ref Gdk.Rectangle cell_area, ref Gdk.Rectangle expose_area, int flags);

		public void Render(Gdk.Window window, Gtk.Widget widget, Gdk.Rectangle background_area, Gdk.Rectangle cell_area, Gdk.Rectangle expose_area, Gtk.CellRendererState flags) {
			Gtk.Application.AssertMainThread();
			gtk_cell_renderer_render(Handle, window == null ? IntPtr.Zero : window.Handle, widget == null ? IntPtr.Zero : widget.Handle, ref background_area, ref cell_area, ref expose_area, (int) flags);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_cell_renderer_set_fixed_size(IntPtr raw, int width, int height);

		public void SetFixedSize(int width, int height) {
			Gtk.Application.AssertMainThread();
			gtk_cell_renderer_set_fixed_size(Handle, width, height);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_cell_renderer_stop_editing(IntPtr raw, bool canceled);

		public void StopEditing(bool canceled) {
			Gtk.Application.AssertMainThread();
			gtk_cell_renderer_stop_editing(Handle, canceled);
		}

#endregion
#region Customized extensions
#line 1 "CellRenderer.custom"
//
// CellRenderer.custom - Gtk CellRenderer class customizations
//
// Author: Todd Berman <tberman@sevenl.net>,
//         Peter Johanson <peter@peterjohanson.com>
//
// Copyright (C) 2004 Todd Berman
// Copyright (C) 2007 Peter Johanson
//
// This code is inserted after the automatically generated code.
//
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of version 2 of the Lesser GNU General
// Public License as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this program; if not, write to the
// Free Software Foundation, Inc., 59 Temple Place - Suite 330,
// Boston, MA 02111-1307, USA.


		[DllImport("gtksharpglue-2", CallingConvention=CallingConvention.Cdecl)]
		static extern void gtksharp_cellrenderer_base_get_size (IntPtr handle, IntPtr widget, ref Gdk.Rectangle cell_area, out int x_offset, out int y_offset, out int width, out int height);

		[DllImport("gtksharpglue-2", CallingConvention=CallingConvention.Cdecl)]
		static extern void gtksharp_cellrenderer_override_get_size (IntPtr gtype, GetSizeDelegate cb);

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void GetSizeDelegate (IntPtr item, IntPtr widget, IntPtr cell_area_ptr, IntPtr x_offset, IntPtr y_offset, IntPtr width, IntPtr height);

		static GetSizeDelegate GetSizeCallback;

		static void GetSize_cb (IntPtr item, IntPtr widget, IntPtr cell_area_ptr, IntPtr x_offset, IntPtr y_offset, IntPtr width, IntPtr height)
		{
			try {
				CellRenderer obj = GLib.Object.GetObject (item, false) as CellRenderer;
				Gtk.Widget widg = GLib.Object.GetObject (widget, false) as Gtk.Widget;
				Gdk.Rectangle cell_area = Gdk.Rectangle.New (cell_area_ptr);
				int a, b, c, d;

				obj.GetSize (widg, ref cell_area, out a, out b, out c, out d);
				if (x_offset != IntPtr.Zero)
					Marshal.WriteInt32 (x_offset, a);
				if (y_offset != IntPtr.Zero)
					Marshal.WriteInt32 (y_offset, b);
				if (width != IntPtr.Zero)
					Marshal.WriteInt32 (width, c);
				if (height != IntPtr.Zero)
					Marshal.WriteInt32 (height, d);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		static void OverrideGetSize (GLib.GType gtype)
		{
			if (GetSizeCallback == null)
				GetSizeCallback = new GetSizeDelegate (GetSize_cb);
			gtksharp_cellrenderer_override_get_size (gtype.Val, GetSizeCallback);
		}

		[GLib.DefaultSignalHandler (Type=typeof(Gtk.CellRenderer), ConnectionMethod="OverrideGetSize")]
		public virtual void GetSize(Gtk.Widget widget, ref Gdk.Rectangle cell_area, out int x_offset, out int y_offset, out int width, out int height)
		{
			gtksharp_cellrenderer_base_get_size(Handle, widget.Handle, ref cell_area, out x_offset, out y_offset, out width, out height);
		}

		[DllImport("gtksharpglue-2", CallingConvention=CallingConvention.Cdecl)]
		static extern void gtksharp_cellrenderer_invoke_get_size (IntPtr gtype, IntPtr handle, IntPtr widget, ref Gdk.Rectangle cell_area, out int x_offset, out int y_offset, out int width, out int height);

		internal static void InternalGetSize (GLib.GType gtype, Gtk.CellRenderer cell, Gtk.Widget widget, ref Gdk.Rectangle cell_area, out int x_offset, out int y_offset, out int width, out int height)
		{
			gtksharp_cellrenderer_invoke_get_size (gtype.Val, cell.Handle, widget.Handle, ref cell_area, out x_offset, out y_offset, out width, out height);
		}

		[DllImport("gtksharpglue-2", CallingConvention=CallingConvention.Cdecl)]
		static extern void gtksharp_cellrenderer_base_render (IntPtr handle, IntPtr window, IntPtr widget, ref Gdk.Rectangle background_area, ref Gdk.Rectangle cell_area, ref Gdk.Rectangle expose_area, Gtk.CellRendererState flags);

		[DllImport("gtksharpglue-2", CallingConvention=CallingConvention.Cdecl)]
		static extern void gtksharp_cellrenderer_override_render (IntPtr gtype, RenderDelegate cb);

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void RenderDelegate (IntPtr item, IntPtr window, IntPtr widget, ref Gdk.Rectangle background_area, ref Gdk.Rectangle cell_area, ref Gdk.Rectangle expose_area, Gtk.CellRendererState flags);

		static RenderDelegate RenderCallback;

		static void Render_cb (IntPtr item, IntPtr window, IntPtr widget, ref Gdk.Rectangle background_area, ref Gdk.Rectangle cell_area, ref Gdk.Rectangle expose_area, Gtk.CellRendererState flags)
		{
			try {
				CellRenderer obj = GLib.Object.GetObject (item, false) as CellRenderer;
				Gdk.Drawable wind = GLib.Object.GetObject (window, false) as Gdk.Drawable;
				Gtk.Widget widg = GLib.Object.GetObject (widget, false) as Gtk.Widget;
				obj.Render (wind, widg, background_area, cell_area, expose_area, flags);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		static void OverrideRender (GLib.GType gtype)
		{
			if (RenderCallback == null)
				RenderCallback = new RenderDelegate (Render_cb);
			gtksharp_cellrenderer_override_render (gtype.Val, RenderCallback);
		}

		[GLib.DefaultSignalHandler (Type=typeof(Gtk.CellRenderer), ConnectionMethod="OverrideRender")]
		protected virtual void Render (Gdk.Drawable window, Gtk.Widget widget, Gdk.Rectangle background_area, Gdk.Rectangle cell_area, Gdk.Rectangle expose_area, Gtk.CellRendererState flags)
		{
			gtksharp_cellrenderer_base_render (Handle, window.Handle, widget.Handle, ref background_area, ref cell_area, ref expose_area, flags);
		}

		[DllImport("gtksharpglue-2", CallingConvention=CallingConvention.Cdecl)]
		static extern void gtksharp_cellrenderer_invoke_render (IntPtr gtype, IntPtr handle, IntPtr window, IntPtr widget, ref Gdk.Rectangle background_area, ref Gdk.Rectangle cell_area, ref Gdk.Rectangle expose_area, Gtk.CellRendererState flags);

		internal static void InternalRender (GLib.GType gtype, Gtk.CellRenderer cell, Gdk.Drawable window, Gtk.Widget widget, Gdk.Rectangle background_area, Gdk.Rectangle cell_area, Gdk.Rectangle expose_area, Gtk.CellRendererState flags)
		{
			gtksharp_cellrenderer_invoke_render (gtype.Val, cell.Handle, window.Handle, widget.Handle, ref background_area, ref cell_area, ref expose_area, flags);
		}

		[DllImport("gtksharpglue-2", CallingConvention=CallingConvention.Cdecl)]
		static extern void gtksharp_cellrenderer_override_start_editing (IntPtr gtype, StartEditingDelegate cb);

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr StartEditingDelegate (IntPtr raw, IntPtr evnt, IntPtr widget, IntPtr path, ref Gdk.Rectangle background_area, ref Gdk.Rectangle cell_area, Gtk.CellRendererState flags);

		static StartEditingDelegate StartEditingCallback;

		static IntPtr StartEditing_cb (IntPtr raw, IntPtr evnt, IntPtr widget, IntPtr path, ref Gdk.Rectangle background_area, ref Gdk.Rectangle cell_area, Gtk.CellRendererState flags)
		{
			try {
				CellRenderer obj = GLib.Object.GetObject (raw, false) as CellRenderer;
				Gdk.Event _event = evnt != IntPtr.Zero ? new Gdk.Event (evnt) : null;
				Widget widg = GLib.Object.GetObject (widget, false) as Gtk.Widget;
				CellEditable retval = obj.StartEditing (_event, widg, GLib.Marshaller.Utf8PtrToString (path), background_area, cell_area, flags);
				if (retval == null)
					return IntPtr.Zero;
				return retval.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}

			return IntPtr.Zero;
		}

		static void OverrideStartEditing (GLib.GType gtype)
		{
			if (StartEditingCallback == null)
				StartEditingCallback = new StartEditingDelegate (StartEditing_cb);
			gtksharp_cellrenderer_override_start_editing (gtype.Val, StartEditingCallback);
		}

		[DllImport("gtksharpglue-2", CallingConvention=CallingConvention.Cdecl)]
		static extern IntPtr gtksharp_cellrenderer_base_start_editing(IntPtr raw, IntPtr evnt, IntPtr widget, IntPtr path, ref Gdk.Rectangle background_area, ref Gdk.Rectangle cell_area, int flags);

		[GLib.DefaultSignalHandler (Type=typeof(Gtk.CellRenderer), ConnectionMethod="OverrideStartEditing")]
		public virtual Gtk.CellEditable StartEditing(Gdk.Event evnt, Gtk.Widget widget, string path, Gdk.Rectangle background_area, Gdk.Rectangle cell_area, Gtk.CellRendererState flags) {
			IntPtr native = GLib.Marshaller.StringToPtrGStrdup (path);
			IntPtr raw_ret = gtksharp_cellrenderer_base_start_editing(Handle, evnt != null ? evnt.Handle : IntPtr.Zero, widget.Handle, native, ref background_area, ref cell_area, (int) flags);
			GLib.Marshaller.Free (native);
			Gtk.CellEditable ret = (Gtk.CellEditable) GLib.Object.GetObject(raw_ret);
			return ret;
		}

		[DllImport("gtksharpglue-2", CallingConvention=CallingConvention.Cdecl)]
		static extern IntPtr gtksharp_cellrenderer_invoke_start_editing(IntPtr gtype, IntPtr raw, IntPtr evnt, IntPtr widget, IntPtr path, ref Gdk.Rectangle background_area, ref Gdk.Rectangle cell_area, int flags);

		internal static Gtk.CellEditable InternalStartEditing(GLib.GType gtype, Gtk.CellRenderer cell, Gdk.Event evnt, Gtk.Widget widget, string path, ref Gdk.Rectangle background_area, ref Gdk.Rectangle cell_area, Gtk.CellRendererState flags)
		{
			IntPtr native = GLib.Marshaller.StringToPtrGStrdup (path);
			IntPtr raw_ret = gtksharp_cellrenderer_invoke_start_editing(gtype.Val, cell.Handle, evnt.Handle, widget.Handle, native, ref background_area, ref cell_area, (int) flags);
			GLib.Marshaller.Free (native);
			Gtk.CellEditable ret = GLib.Object.GetObject(raw_ret) as Gtk.CellEditable;
			return ret;
		}

#endregion
	}

	internal class CellRendererAttribute : GLib.GTypeTypeAttribute {
		[DllImport ("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_cell_renderer_get_type ();

		private static GLib.GType _gtype = new GLib.GType (gtk_cell_renderer_get_type ());
		public static GLib.GType GType { get { return _gtype; } }
		public override GLib.GType Type { get { return _gtype; } }

	}
}
