// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gtk {

	using System;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public class CellLayoutAdapter : GLib.GInterfaceAdapter, Gtk.CellLayout {

		static CellLayoutIface iface;

		struct CellLayoutIface {
			public IntPtr gtype;
			public IntPtr itype;

			public PackStartDelegate pack_start;
			public PackEndDelegate pack_end;
			public ClearDelegate clear;
			public AddAttributeDelegate add_attribute;
			public SetCellDataFuncDelegate set_cell_data_func;
			public ClearAttributesDelegate clear_attributes;
			public ReorderDelegate reorder;
			public GetCellsDelegate get_cells;
		}

		static CellLayoutAdapter ()
		{
			GLib.GType.Register (_gtype, typeof(CellLayoutAdapter));
			iface.pack_start = new PackStartDelegate (PackStartCallback);
			iface.pack_end = new PackEndDelegate (PackEndCallback);
			iface.clear = new ClearDelegate (ClearCallback);
			iface.add_attribute = new AddAttributeDelegate (AddAttributeCallback);
			iface.set_cell_data_func = new SetCellDataFuncDelegate (SetCellDataFuncCallback);
			iface.clear_attributes = new ClearAttributesDelegate (ClearAttributesCallback);
			iface.reorder = new ReorderDelegate (ReorderCallback);
			iface.get_cells = new GetCellsDelegate (GetCellsCallback);
		}


		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void PackStartDelegate (IntPtr cell_layout, IntPtr cell, bool expand);

		static void PackStartCallback (IntPtr cell_layout, IntPtr cell, bool expand)
		{
			try {
				Gtk.CellLayoutImplementor __obj = GLib.Object.GetObject (cell_layout, false) as Gtk.CellLayoutImplementor;
				__obj.PackStart (GLib.Object.GetObject(cell) as Gtk.CellRenderer, expand);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void PackEndDelegate (IntPtr cell_layout, IntPtr cell, bool expand);

		static void PackEndCallback (IntPtr cell_layout, IntPtr cell, bool expand)
		{
			try {
				Gtk.CellLayoutImplementor __obj = GLib.Object.GetObject (cell_layout, false) as Gtk.CellLayoutImplementor;
				__obj.PackEnd (GLib.Object.GetObject(cell) as Gtk.CellRenderer, expand);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ClearDelegate (IntPtr cell_layout);

		static void ClearCallback (IntPtr cell_layout)
		{
			try {
				Gtk.CellLayoutImplementor __obj = GLib.Object.GetObject (cell_layout, false) as Gtk.CellLayoutImplementor;
				__obj.Clear ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void AddAttributeDelegate (IntPtr cell_layout, IntPtr cell, IntPtr attribute, int column);

		static void AddAttributeCallback (IntPtr cell_layout, IntPtr cell, IntPtr attribute, int column)
		{
			try {
				Gtk.CellLayoutImplementor __obj = GLib.Object.GetObject (cell_layout, false) as Gtk.CellLayoutImplementor;
				__obj.AddAttribute (GLib.Object.GetObject(cell) as Gtk.CellRenderer, GLib.Marshaller.Utf8PtrToString (attribute), column);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void SetCellDataFuncDelegate (IntPtr cell_layout, IntPtr cell, GtkSharp.CellLayoutDataFuncNative func, IntPtr func_data, GLib.DestroyNotify destroy);

		static void SetCellDataFuncCallback (IntPtr cell_layout, IntPtr cell, GtkSharp.CellLayoutDataFuncNative func, IntPtr func_data, GLib.DestroyNotify destroy)
		{
			try {
				Gtk.CellLayoutImplementor __obj = GLib.Object.GetObject (cell_layout, false) as Gtk.CellLayoutImplementor;
				GtkSharp.CellLayoutDataFuncInvoker func_invoker = new GtkSharp.CellLayoutDataFuncInvoker (func, func_data, destroy);
				__obj.SetCellDataFunc (GLib.Object.GetObject(cell) as Gtk.CellRenderer, func_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ClearAttributesDelegate (IntPtr cell_layout, IntPtr cell);

		static void ClearAttributesCallback (IntPtr cell_layout, IntPtr cell)
		{
			try {
				Gtk.CellLayoutImplementor __obj = GLib.Object.GetObject (cell_layout, false) as Gtk.CellLayoutImplementor;
				__obj.ClearAttributes (GLib.Object.GetObject(cell) as Gtk.CellRenderer);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ReorderDelegate (IntPtr cell_layout, IntPtr cell, int position);

		static void ReorderCallback (IntPtr cell_layout, IntPtr cell, int position)
		{
			try {
				Gtk.CellLayoutImplementor __obj = GLib.Object.GetObject (cell_layout, false) as Gtk.CellLayoutImplementor;
				__obj.Reorder (GLib.Object.GetObject(cell) as Gtk.CellRenderer, position);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr GetCellsDelegate (IntPtr cell_layout);

		static IntPtr GetCellsCallback (IntPtr cell_layout)
		{
			try {
				Gtk.CellLayoutImplementor __obj = GLib.Object.GetObject (cell_layout, false) as Gtk.CellLayoutImplementor;
				Gtk.CellRenderer[] __result = __obj.Cells;
				return new GLib.List(__result, typeof (Gtk.CellRenderer), true, false) == null ? IntPtr.Zero : new GLib.List(__result, typeof (Gtk.CellRenderer), true, false).Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}
		static void Initialize (IntPtr ifaceptr, IntPtr data)
		{
			CellLayoutIface native_iface = Marshal.PtrToStructure<CellLayoutIface> (ifaceptr);
			native_iface.pack_start = iface.pack_start;
			native_iface.pack_end = iface.pack_end;
			native_iface.clear = iface.clear;
			native_iface.add_attribute = iface.add_attribute;
			native_iface.set_cell_data_func = iface.set_cell_data_func;
			native_iface.clear_attributes = iface.clear_attributes;
			native_iface.reorder = iface.reorder;
			native_iface.get_cells = iface.get_cells;
			Marshal.StructureToPtr<CellLayoutIface> (native_iface, ifaceptr, false);
			GCHandle gch = (GCHandle) data;
			gch.Free ();
		}

		public CellLayoutAdapter ()
		{
			InitHandler = new GLib.GInterfaceInitHandler (Initialize);
		}

		CellLayoutImplementor implementor;

		public CellLayoutAdapter (CellLayoutImplementor implementor)
		{
			if (implementor == null)
				throw new ArgumentNullException ("implementor");
			this.implementor = implementor;
		}

		public CellLayoutAdapter (IntPtr handle)
		{
			this.handle = handle;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_cell_layout_get_type();

		private static GLib.GType _gtype = new GLib.GType (gtk_cell_layout_get_type ());

		public override GLib.GType GType {
			get {
				return _gtype;
			}
		}

		IntPtr handle;
		public override IntPtr Handle {
			get {
				if (handle != IntPtr.Zero)
					return handle;
				return implementor == null ? IntPtr.Zero : implementor.Handle;
			}
		}

		public static CellLayout GetObject (IntPtr handle, bool owned)
		{
			GLib.Object obj = GLib.Object.GetObject (handle, owned);
			return GetObject (obj);
		}

		public static CellLayout GetObject (GLib.Object obj)
		{
			if (obj == null)
				return null;
			else if (obj is CellLayoutImplementor)
				return new CellLayoutAdapter (obj as CellLayoutImplementor);
			else if (obj as CellLayout == null)
				return new CellLayoutAdapter (obj.Handle);
			else
				return obj as CellLayout;
		}

		public CellLayoutImplementor Implementor {
			get {
				return implementor;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_cell_layout_add_attribute(IntPtr raw, IntPtr cell, IntPtr attribute, int column);

		public void AddAttribute(Gtk.CellRenderer cell, string attribute, int column) {
			Gtk.Application.AssertMainThread();
			IntPtr native_attribute = GLib.Marshaller.StringToPtrGStrdup (attribute);
			gtk_cell_layout_add_attribute(Handle, cell == null ? IntPtr.Zero : cell.Handle, native_attribute, column);
			GLib.Marshaller.Free (native_attribute);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_cell_layout_clear(IntPtr raw);

		public void Clear() {
			gtk_cell_layout_clear(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_cell_layout_clear_attributes(IntPtr raw, IntPtr cell);

		public void ClearAttributes(Gtk.CellRenderer cell) {
			Gtk.Application.AssertMainThread();
			gtk_cell_layout_clear_attributes(Handle, cell == null ? IntPtr.Zero : cell.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_cell_layout_get_cells(IntPtr raw);

		public Gtk.CellRenderer[] Cells { 
			get {
				IntPtr raw_ret = gtk_cell_layout_get_cells(Handle);
				Gtk.CellRenderer[] ret = GLib.Marshaller.ListPtrToArray<Gtk.CellRenderer> (raw_ret, typeof(GLib.List), true, false);
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_cell_layout_pack_end(IntPtr raw, IntPtr cell, bool expand);

		public void PackEnd(Gtk.CellRenderer cell, bool expand) {
			Gtk.Application.AssertMainThread();
			gtk_cell_layout_pack_end(Handle, cell == null ? IntPtr.Zero : cell.Handle, expand);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_cell_layout_pack_start(IntPtr raw, IntPtr cell, bool expand);

		public void PackStart(Gtk.CellRenderer cell, bool expand) {
			Gtk.Application.AssertMainThread();
			gtk_cell_layout_pack_start(Handle, cell == null ? IntPtr.Zero : cell.Handle, expand);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_cell_layout_reorder(IntPtr raw, IntPtr cell, int position);

		public void Reorder(Gtk.CellRenderer cell, int position) {
			Gtk.Application.AssertMainThread();
			gtk_cell_layout_reorder(Handle, cell == null ? IntPtr.Zero : cell.Handle, position);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_cell_layout_set_cell_data_func(IntPtr raw, IntPtr cell, GtkSharp.CellLayoutDataFuncNative func, IntPtr func_data, GLib.DestroyNotify destroy);

		public void SetCellDataFunc(Gtk.CellRenderer cell, Gtk.CellLayoutDataFunc func) {
			Gtk.Application.AssertMainThread();
			IntPtr func_data;
			GLib.DestroyNotify destroy;
			if (func == null) {
				func_data = IntPtr.Zero;
				destroy = null;
			} else {
				func_data = (IntPtr) GCHandle.Alloc (func);
				destroy = GLib.DestroyHelper.NotifyHandler;
			}
			gtk_cell_layout_set_cell_data_func(Handle, cell == null ? IntPtr.Zero : cell.Handle, (func == null) ? null : GtkSharp.CellLayoutDataFuncWrapper.NativeDelegate, func_data, destroy);
		}

#endregion
#region Customized extensions
#line 1 "CellLayoutAdapter.custom"
//  Gtk.CellLayoutAdaptor.custom - Gtk CellLayoutAdaptor customizations
//
//  Authors:  Mike Kestner  <mkestner@novell.com>
//
//  Copyright (c) 2007 Novell, Inc.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of version 2 of the Lesser GNU General
// Public License as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this program; if not, write to the
// Free Software Foundation, Inc., 59 Temple Place - Suite 330,
// Boston, MA 02111-1307, USA.


		public void SetAttributes (CellRenderer cell, params object[] attrs)
		{
			if (attrs.Length % 2 != 0)
				throw new ArgumentException ("attrs should contain pairs of attribute/col");

			ClearAttributes (cell);
			for (int i = 0; i < attrs.Length - 1; i += 2) {
				AddAttribute (cell, (string) attrs [i], (int) attrs [i + 1]);
			}
		}

#endregion
	}
}
