// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gtk {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	[Toolbar]
	public class Toolbar : Gtk.Container {

		[Obsolete]
		protected Toolbar(GLib.GType gtype) : base(gtype) {}
		public Toolbar(IntPtr raw) : base(raw) {}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_toolbar_new();

		public Toolbar () : base (IntPtr.Zero)
		{
			if (GetType () != typeof (Toolbar)) {
				Gtk.Application.AssertMainThread();
				CreateNativeObject (Array.Empty<IntPtr> (), Array.Empty<GLib.Value> (), 0);
				return;
			}
			owned = true;
			Raw = gtk_toolbar_new();
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_toolbar_get_orientation(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_toolbar_set_orientation(IntPtr raw, int orientation);

		[GLib.Property ("orientation")]
		public Gtk.Orientation Orientation {
			get  {
				int raw_ret = gtk_toolbar_get_orientation(Handle);
				Gtk.Orientation ret = (Gtk.Orientation) raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_toolbar_set_orientation(Handle, (int) value);
			}
		}

		[GLib.Property ("toolbar-style")]
		public Gtk.ToolbarStyle ToolbarStyle {
			get {
				using (GLib.Value val = GetProperty ("toolbar-style")) {
					Gtk.ToolbarStyle ret = (Gtk.ToolbarStyle) (Enum) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value((Enum) value)) {
					SetProperty("toolbar-style", val);
				}
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_toolbar_get_show_arrow(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_toolbar_set_show_arrow(IntPtr raw, bool show_arrow);

		[GLib.Property ("show-arrow")]
		public bool ShowArrow {
			get  {
				bool raw_ret = gtk_toolbar_get_show_arrow(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_toolbar_set_show_arrow(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_toolbar_get_tooltips(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_toolbar_set_tooltips(IntPtr raw, bool enable);

		[GLib.Property ("tooltips")]
		public bool Tooltips {
			get  {
				bool raw_ret = gtk_toolbar_get_tooltips(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_toolbar_set_tooltips(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_toolbar_get_icon_size(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_toolbar_set_icon_size(IntPtr raw, int icon_size);

		[GLib.Property ("icon-size")]
		public Gtk.IconSize IconSize {
			get  {
				int raw_ret = gtk_toolbar_get_icon_size(Handle);
				Gtk.IconSize ret = (Gtk.IconSize) raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_toolbar_set_icon_size(Handle, (int) value);
			}
		}

		[GLib.Property ("icon-size-set")]
		public bool IconSizeSet {
			get {
				using (GLib.Value val = GetProperty ("icon-size-set")) {
					bool ret = (bool) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("icon-size-set", val);
				}
			}
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		extern static uint gtksharp_gtk_toolbar_get_num_children_offset ();

		static uint num_children_offset = gtksharp_gtk_toolbar_get_num_children_offset ();
		public int NumChildren {
			get {
				unsafe {
					int* raw_ptr = (int*)(((byte*)Handle) + num_children_offset);
					return (*raw_ptr);
				}
			}
		}

		public class ToolbarChild : Gtk.Container.ContainerChild {
			protected internal ToolbarChild (Gtk.Container parent, Gtk.Widget child) : base (parent, child) {}

			[Gtk.ChildProperty ("expand")]
			public bool Expand {
				get {
					using (GLib.Value val = parent.ChildGetProperty (child, "expand")) {
						bool ret = (bool) val;
						return ret;
					}
				}
				set {
					using (GLib.Value val = new GLib.Value(value)) {
						parent.ChildSetProperty(child, "expand", val);
					}
				}
			}

			[Gtk.ChildProperty ("homogeneous")]
			public bool Homogeneous {
				get {
					using (GLib.Value val = parent.ChildGetProperty (child, "homogeneous")) {
						bool ret = (bool) val;
						return ret;
					}
				}
				set {
					using (GLib.Value val = new GLib.Value(value)) {
						parent.ChildSetProperty(child, "homogeneous", val);
					}
				}
			}

		}

		public override Gtk.Container.ContainerChild this [Gtk.Widget child] {
			get {
				return new ToolbarChild (this, child);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void OrientationChangedVMDelegate (IntPtr toolbar, int orientation);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_toolbar_override_orientation_changed (IntPtr gtype, OrientationChangedVMDelegate cb);

		static OrientationChangedVMDelegate OrientationChangedVMCallback;

		static void orientationchanged_cb (IntPtr toolbar, int orientation)
		{
			try {
				Toolbar toolbar_managed = GLib.Object.GetObject (toolbar, false) as Toolbar;
				toolbar_managed.OnOrientationChanged ((Gtk.Orientation) orientation);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideOrientationChanged (GLib.GType gtype)
		{
			if (OrientationChangedVMCallback == null)
				OrientationChangedVMCallback = new OrientationChangedVMDelegate (orientationchanged_cb);
			gtksharp_toolbar_override_orientation_changed (gtype.Val, OrientationChangedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_toolbar_base_orientation_changed (IntPtr toolbar, int orientation);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Toolbar), ConnectionMethod="OverrideOrientationChanged")]
		protected virtual void OnOrientationChanged (Gtk.Orientation orientation)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_toolbar_base_orientation_changed (Handle, (int) orientation);
		}

		[GLib.Signal("orientation-changed")]
		public event Gtk.OrientationChangedHandler OrientationChanged {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "orientation-changed", typeof (Gtk.OrientationChangedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "orientation-changed", typeof (Gtk.OrientationChangedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void StyleChangedVMDelegate (IntPtr toolbar, int style);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_toolbar_override_style_changed (IntPtr gtype, StyleChangedVMDelegate cb);

		static StyleChangedVMDelegate StyleChangedVMCallback;

		static void stylechanged_cb (IntPtr toolbar, int style)
		{
			try {
				Toolbar toolbar_managed = GLib.Object.GetObject (toolbar, false) as Toolbar;
				toolbar_managed.OnStyleChanged ((Gtk.ToolbarStyle) style);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideStyleChanged (GLib.GType gtype)
		{
			if (StyleChangedVMCallback == null)
				StyleChangedVMCallback = new StyleChangedVMDelegate (stylechanged_cb);
			gtksharp_toolbar_override_style_changed (gtype.Val, StyleChangedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_toolbar_base_style_changed (IntPtr toolbar, int style);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Toolbar), ConnectionMethod="OverrideStyleChanged")]
		protected virtual void OnStyleChanged (Gtk.ToolbarStyle style)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_toolbar_base_style_changed (Handle, (int) style);
		}

		[GLib.Signal("style-changed")]
		public event Gtk.StyleChangedHandler StyleChanged {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "style-changed", typeof (Gtk.StyleChangedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "style-changed", typeof (Gtk.StyleChangedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool PopupContextMenuVMDelegate (IntPtr toolbar, int x, int y, int button_number);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_toolbar_override_popup_context_menu (IntPtr gtype, PopupContextMenuVMDelegate cb);

		static PopupContextMenuVMDelegate PopupContextMenuVMCallback;

		static bool popupcontextmenu_cb (IntPtr toolbar, int x, int y, int button_number)
		{
			try {
				Toolbar toolbar_managed = GLib.Object.GetObject (toolbar, false) as Toolbar;
				return toolbar_managed.OnPopupContextMenu (x, y, button_number);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverridePopupContextMenu (GLib.GType gtype)
		{
			if (PopupContextMenuVMCallback == null)
				PopupContextMenuVMCallback = new PopupContextMenuVMDelegate (popupcontextmenu_cb);
			gtksharp_toolbar_override_popup_context_menu (gtype.Val, PopupContextMenuVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_toolbar_base_popup_context_menu (IntPtr toolbar, int x, int y, int button_number);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Toolbar), ConnectionMethod="OverridePopupContextMenu")]
		protected virtual bool OnPopupContextMenu (int x, int y, int button_number)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_toolbar_base_popup_context_menu (Handle, x, y, button_number);
			return __ret;
		}

		[GLib.Signal("popup_context_menu")]
		public event Gtk.PopupContextMenuHandler PopupContextMenu {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "popup_context_menu", typeof (Gtk.PopupContextMenuArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "popup_context_menu", typeof (Gtk.PopupContextMenuArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool FocusHomeOrEndVMDelegate (IntPtr inst, bool p0);

		static FocusHomeOrEndVMDelegate FocusHomeOrEndVMCallback;

		static bool focushomeorend_cb (IntPtr inst, bool p0)
		{
			try {
				Toolbar inst_managed = GLib.Object.GetObject (inst, false) as Toolbar;
				return inst_managed.OnFocusHomeOrEnd (p0);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideFocusHomeOrEnd (GLib.GType gtype)
		{
			if (FocusHomeOrEndVMCallback == null)
				FocusHomeOrEndVMCallback = new FocusHomeOrEndVMDelegate (focushomeorend_cb);
			OverrideVirtualMethod (gtype, "focus_home_or_end", FocusHomeOrEndVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Toolbar), ConnectionMethod="OverrideFocusHomeOrEnd")]
		protected virtual bool OnFocusHomeOrEnd (bool p0)
		{
			GLib.Value ret = new GLib		.Value (GLib.GType.Boolean);
			unsafe {
				GLib.Value* inst_and_params = stackalloc GLib.Value [2];
				using (inst_and_params[0] = new GLib.Value (this)) {
					using (inst_and_params [1] = new GLib.Value (p0)) {
						g_signal_chain_from_overridden (inst_and_params, ref ret);
					}
				}
			}
			bool result = (bool) ret;
			ret.Dispose ();
			return result;
		}

		[GLib.Signal("focus_home_or_end")]
		public event Gtk.FocusHomeOrEndHandler FocusHomeOrEnd {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "focus_home_or_end", typeof (Gtk.FocusHomeOrEndArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "focus_home_or_end", typeof (Gtk.FocusHomeOrEndArgs));
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_toolbar_append_space(IntPtr raw);

		[Obsolete]
		public void AppendSpace() {
			gtk_toolbar_append_space(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_toolbar_append_widget(IntPtr raw, IntPtr widget, IntPtr tooltip_text, IntPtr tooltip_private_text);

		[Obsolete]
		public void AppendWidget(Gtk.Widget widget, string tooltip_text, string tooltip_private_text) {
			Gtk.Application.AssertMainThread();
			IntPtr native_tooltip_text = GLib.Marshaller.StringToPtrGStrdup (tooltip_text);
			IntPtr native_tooltip_private_text = GLib.Marshaller.StringToPtrGStrdup (tooltip_private_text);
			gtk_toolbar_append_widget(Handle, widget == null ? IntPtr.Zero : widget.Handle, native_tooltip_text, native_tooltip_private_text);
			GLib.Marshaller.Free (native_tooltip_text);
			GLib.Marshaller.Free (native_tooltip_private_text);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_toolbar_get_drop_index(IntPtr raw, int x, int y);

		public int GetDropIndex(int x, int y) {
			Gtk.Application.AssertMainThread();
			int raw_ret = gtk_toolbar_get_drop_index(Handle, x, y);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_toolbar_get_item_index(IntPtr raw, IntPtr item);

		public int GetItemIndex(Gtk.ToolItem item) {
			Gtk.Application.AssertMainThread();
			int raw_ret = gtk_toolbar_get_item_index(Handle, item == null ? IntPtr.Zero : item.Handle);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_toolbar_get_n_items(IntPtr raw);

		public int NItems { 
			get {
				int raw_ret = gtk_toolbar_get_n_items(Handle);
				int ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_toolbar_get_nth_item(IntPtr raw, int n);

		public Gtk.ToolItem GetNthItem(int n) {
			Gtk.Application.AssertMainThread();
			IntPtr raw_ret = gtk_toolbar_get_nth_item(Handle, n);
			Gtk.ToolItem ret = GLib.Object.GetObject(raw_ret) as Gtk.ToolItem;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_toolbar_get_relief_style(IntPtr raw);

		public Gtk.ReliefStyle ReliefStyle { 
			get {
				int raw_ret = gtk_toolbar_get_relief_style(Handle);
				Gtk.ReliefStyle ret = (Gtk.ReliefStyle) raw_ret;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_toolbar_get_type();

		static GLib.GType _gtype = new GLib.GType (gtk_toolbar_get_type());
		public static new GLib.GType GType { 
			get {
								return _gtype;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_toolbar_insert(IntPtr raw, IntPtr item, int pos);

		public void Insert(Gtk.ToolItem item, int pos) {
			Gtk.Application.AssertMainThread();
			gtk_toolbar_insert(Handle, item == null ? IntPtr.Zero : item.Handle, pos);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_toolbar_insert_space(IntPtr raw, int position);

		[Obsolete]
		public void InsertSpace(int position) {
			Gtk.Application.AssertMainThread();
			gtk_toolbar_insert_space(Handle, position);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_toolbar_insert_widget(IntPtr raw, IntPtr widget, IntPtr tooltip_text, IntPtr tooltip_private_text, int position);

		[Obsolete]
		public void InsertWidget(Gtk.Widget widget, string tooltip_text, string tooltip_private_text, int position) {
			Gtk.Application.AssertMainThread();
			IntPtr native_tooltip_text = GLib.Marshaller.StringToPtrGStrdup (tooltip_text);
			IntPtr native_tooltip_private_text = GLib.Marshaller.StringToPtrGStrdup (tooltip_private_text);
			gtk_toolbar_insert_widget(Handle, widget == null ? IntPtr.Zero : widget.Handle, native_tooltip_text, native_tooltip_private_text, position);
			GLib.Marshaller.Free (native_tooltip_text);
			GLib.Marshaller.Free (native_tooltip_private_text);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_toolbar_prepend_space(IntPtr raw);

		[Obsolete]
		public void PrependSpace() {
			gtk_toolbar_prepend_space(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_toolbar_prepend_widget(IntPtr raw, IntPtr widget, IntPtr tooltip_text, IntPtr tooltip_private_text);

		[Obsolete]
		public void PrependWidget(Gtk.Widget widget, string tooltip_text, string tooltip_private_text) {
			Gtk.Application.AssertMainThread();
			IntPtr native_tooltip_text = GLib.Marshaller.StringToPtrGStrdup (tooltip_text);
			IntPtr native_tooltip_private_text = GLib.Marshaller.StringToPtrGStrdup (tooltip_private_text);
			gtk_toolbar_prepend_widget(Handle, widget == null ? IntPtr.Zero : widget.Handle, native_tooltip_text, native_tooltip_private_text);
			GLib.Marshaller.Free (native_tooltip_text);
			GLib.Marshaller.Free (native_tooltip_private_text);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_toolbar_remove_space(IntPtr raw, int position);

		[Obsolete]
		public void RemoveSpace(int position) {
			Gtk.Application.AssertMainThread();
			gtk_toolbar_remove_space(Handle, position);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_toolbar_set_drop_highlight_item(IntPtr raw, IntPtr tool_item, int index_);

		public void SetDropHighlightItem(Gtk.ToolItem tool_item, int index_) {
			Gtk.Application.AssertMainThread();
			gtk_toolbar_set_drop_highlight_item(Handle, tool_item == null ? IntPtr.Zero : tool_item.Handle, index_);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_toolbar_unset_icon_size(IntPtr raw);

		public void UnsetIconSize() {
			gtk_toolbar_unset_icon_size(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_toolbar_unset_style(IntPtr raw);

		public void UnsetStyle() {
			gtk_toolbar_unset_style(Handle);
		}

#endregion
#region Customized extensions
#line 1 "Toolbar.custom"
// Gtk.Toolbar.custom - Gtk Toolbar class customizations
//
// Author: Mike Kestner <mkestner@novell.com>
//
// Copyright (C) 2005 Novell, Inc.
//
// This code is inserted after the automatically generated code.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of version 2 of the Lesser GNU General
// Public License as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this program; if not, write to the
// Free Software Foundation, Inc., 59 Temple Place - Suite 330,
// Boston, MA 02111-1307, USA.

		[DllImport("libgobject-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
		static extern void g_object_weak_ref (IntPtr raw, WeakNotify cb, IntPtr data);

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void WeakNotify (IntPtr handle, IntPtr obj);

		static void ReleaseDelegateCB (IntPtr handle, IntPtr obj)
		{
			GCHandle gch = (GCHandle) handle;
			gch.Free ();
		}

		static WeakNotify on_weak_notify;
		static WeakNotify OnWeakNotify {
			get {
				if (on_weak_notify == null)
					on_weak_notify = new WeakNotify (ReleaseDelegateCB);
				return on_weak_notify;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
		static extern IntPtr gtk_toolbar_append_element (IntPtr raw, int type, IntPtr widget, IntPtr text, IntPtr tooltip_text, IntPtr tooltip_private_text, IntPtr icon, GtkSharp.SignalFuncNative cb, IntPtr user_data);

		[Obsolete ("Replaced by ToolItem API")]
		public Gtk.Widget AppendElement (Gtk.ToolbarChildType type, Gtk.Widget widget, string text, string tooltip_text, string tooltip_private_text, Gtk.Widget icon, Gtk.SignalFunc cb)
		{
			GtkSharp.SignalFuncWrapper cb_wrapper = new GtkSharp.SignalFuncWrapper (cb);
			IntPtr ntext = GLib.Marshaller.StringToPtrGStrdup (text);
			IntPtr ntiptext = GLib.Marshaller.StringToPtrGStrdup (tooltip_text);
			IntPtr ntipprivtext = GLib.Marshaller.StringToPtrGStrdup (tooltip_private_text);
			IntPtr raw_ret = gtk_toolbar_append_element (Handle, (int) type, widget == null ? IntPtr.Zero : widget.Handle, ntext, ntiptext, ntipprivtext, icon == null ? IntPtr.Zero : icon.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
			GLib.Marshaller.Free (ntext);
			GLib.Marshaller.Free (ntiptext);
			GLib.Marshaller.Free (ntipprivtext);
			Gtk.Widget ret;
			if (raw_ret == IntPtr.Zero)
				ret = null;
			else {
				ret = (Gtk.Widget) GLib.Object.GetObject (raw_ret);
				g_object_weak_ref (raw_ret, OnWeakNotify, (IntPtr) GCHandle.Alloc (cb_wrapper));
			}
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
		static extern IntPtr gtk_toolbar_insert_element (IntPtr raw, int type, IntPtr widget, IntPtr text, IntPtr tooltip_text, IntPtr tooltip_private_text, IntPtr icon, GtkSharp.SignalFuncNative cb, IntPtr user_data, int position);

		[Obsolete ("Replaced by ToolItem API")]
		public Gtk.Widget InsertElement (Gtk.ToolbarChildType type, Gtk.Widget widget, string text, string tooltip_text, string tooltip_private_text, Gtk.Widget icon, Gtk.SignalFunc cb, IntPtr user_data, int position)
		{
			GtkSharp.SignalFuncWrapper cb_wrapper = new GtkSharp.SignalFuncWrapper (cb);
			IntPtr ntext = GLib.Marshaller.StringToPtrGStrdup (text);
			IntPtr ntiptext = GLib.Marshaller.StringToPtrGStrdup (tooltip_text);
			IntPtr ntipprivtext = GLib.Marshaller.StringToPtrGStrdup (tooltip_private_text);
			IntPtr raw_ret = gtk_toolbar_insert_element (Handle, (int) type, widget == null ? IntPtr.Zero : widget.Handle, ntext, ntiptext, ntipprivtext, icon == null ? IntPtr.Zero : icon.Handle, cb_wrapper.NativeDelegate, user_data, position);
			GLib.Marshaller.Free (ntext);
			GLib.Marshaller.Free (ntiptext);
			GLib.Marshaller.Free (ntipprivtext);
			Gtk.Widget ret;
			if (raw_ret == IntPtr.Zero)
				ret = null;
			else {
				ret = (Gtk.Widget) GLib.Object.GetObject (raw_ret);
				g_object_weak_ref (raw_ret, OnWeakNotify, (IntPtr) GCHandle.Alloc (cb_wrapper));
			}

			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
		static extern IntPtr gtk_toolbar_prepend_element (IntPtr raw, int type, IntPtr widget, IntPtr text, IntPtr tooltip_text, IntPtr tooltip_private_text, IntPtr icon, GtkSharp.SignalFuncNative cb, IntPtr user_data);

		[Obsolete ("Replaced by ToolItem API")]
		public Gtk.Widget PrependElement (Gtk.ToolbarChildType type, Gtk.Widget widget, string text, string tooltip_text, string tooltip_private_text, Gtk.Widget icon, Gtk.SignalFunc cb)
		{
			GtkSharp.SignalFuncWrapper cb_wrapper = new GtkSharp.SignalFuncWrapper (cb);
			IntPtr ntext = GLib.Marshaller.StringToPtrGStrdup (text);
			IntPtr ntiptext = GLib.Marshaller.StringToPtrGStrdup (tooltip_text);
			IntPtr ntipprivtext = GLib.Marshaller.StringToPtrGStrdup (tooltip_private_text);
			IntPtr raw_ret = gtk_toolbar_prepend_element (Handle, (int) type, widget == null ? IntPtr.Zero : widget.Handle, ntext, ntiptext, ntipprivtext, icon == null ? IntPtr.Zero : icon.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
			GLib.Marshaller.Free (ntext);
			GLib.Marshaller.Free (ntiptext);
			GLib.Marshaller.Free (ntipprivtext);
			Gtk.Widget ret;
			if (raw_ret == IntPtr.Zero)
				ret = null;
			else {
				ret = (Gtk.Widget) GLib.Object.GetObject (raw_ret);
				g_object_weak_ref (raw_ret, OnWeakNotify, (IntPtr) GCHandle.Alloc (cb_wrapper));
			}
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
		static extern IntPtr gtk_toolbar_append_item (IntPtr raw, IntPtr text, IntPtr tooltip_text, IntPtr tooltip_private_text, IntPtr icon, GtkSharp.SignalFuncNative cb, IntPtr user_data);

		[Obsolete ("Replaced by ToolItem API")]
		public Gtk.Widget AppendItem (string text, string tooltip_text, string tooltip_private_text, Gtk.Widget icon, Gtk.SignalFunc cb)
		{
			GtkSharp.SignalFuncWrapper cb_wrapper = new GtkSharp.SignalFuncWrapper (cb);
			IntPtr ntext = GLib.Marshaller.StringToPtrGStrdup (text);
			IntPtr ntiptext = GLib.Marshaller.StringToPtrGStrdup (tooltip_text);
			IntPtr ntipprivtext = GLib.Marshaller.StringToPtrGStrdup (tooltip_private_text);
			IntPtr raw_ret = gtk_toolbar_append_item (Handle, ntext, ntiptext, ntipprivtext, icon == null ? IntPtr.Zero : icon.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
			GLib.Marshaller.Free (ntext);
			GLib.Marshaller.Free (ntiptext);
			GLib.Marshaller.Free (ntipprivtext);
			Gtk.Widget ret;
			if (raw_ret == IntPtr.Zero)
				ret = null;
			else {
				ret = (Gtk.Widget) GLib.Object.GetObject(raw_ret);
				g_object_weak_ref (raw_ret, OnWeakNotify, (IntPtr) GCHandle.Alloc (cb_wrapper));
			}
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
		static extern IntPtr gtk_toolbar_insert_item (IntPtr raw, IntPtr text, IntPtr tooltip_text, IntPtr tooltip_private_text, IntPtr icon, GtkSharp.SignalFuncNative cb, IntPtr user_data, int position);

		[Obsolete ("Replaced by ToolItem API")]
		public Gtk.Widget InsertItem (string text, string tooltip_text, string tooltip_private_text, Gtk.Widget icon, Gtk.SignalFunc cb, IntPtr user_data, int position)
		{
			GtkSharp.SignalFuncWrapper cb_wrapper = new GtkSharp.SignalFuncWrapper (cb);
			IntPtr ntext = GLib.Marshaller.StringToPtrGStrdup (text);
			IntPtr ntiptext = GLib.Marshaller.StringToPtrGStrdup (tooltip_text);
			IntPtr ntipprivtext = GLib.Marshaller.StringToPtrGStrdup (tooltip_private_text);
			IntPtr raw_ret = gtk_toolbar_insert_item (Handle, ntext, ntiptext, ntipprivtext, icon == null ? IntPtr.Zero : icon.Handle, cb_wrapper.NativeDelegate, user_data, position);
			GLib.Marshaller.Free (ntext);
			GLib.Marshaller.Free (ntiptext);
			GLib.Marshaller.Free (ntipprivtext);
			Gtk.Widget ret;
			if (raw_ret == IntPtr.Zero)
				ret = null;
			else {
				ret = (Gtk.Widget) GLib.Object.GetObject(raw_ret);
				g_object_weak_ref (raw_ret, OnWeakNotify, (IntPtr) GCHandle.Alloc (cb_wrapper));
			}
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
		static extern IntPtr gtk_toolbar_prepend_item (IntPtr raw, IntPtr text, IntPtr tooltip_text, IntPtr tooltip_private_text, IntPtr icon, GtkSharp.SignalFuncNative cb, IntPtr user_data);

		[Obsolete ("Replaced by ToolItem API")]
		public Gtk.Widget PrependItem (string text, string tooltip_text, string tooltip_private_text, Gtk.Widget icon, Gtk.SignalFunc cb)
		{
			GtkSharp.SignalFuncWrapper cb_wrapper = new GtkSharp.SignalFuncWrapper (cb);
			IntPtr ntext = GLib.Marshaller.StringToPtrGStrdup (text);
			IntPtr ntiptext = GLib.Marshaller.StringToPtrGStrdup (tooltip_text);
			IntPtr ntipprivtext = GLib.Marshaller.StringToPtrGStrdup (tooltip_private_text);
			IntPtr raw_ret = gtk_toolbar_prepend_item (Handle, ntext, ntiptext, ntipprivtext, icon == null ? IntPtr.Zero : icon.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
			GLib.Marshaller.Free (ntext);
			GLib.Marshaller.Free (ntiptext);
			GLib.Marshaller.Free (ntipprivtext);
			Gtk.Widget ret;
			if (raw_ret == IntPtr.Zero)
				ret = null;
			else {
				ret = (Gtk.Widget) GLib.Object.GetObject(raw_ret);
				g_object_weak_ref (raw_ret, OnWeakNotify, (IntPtr) GCHandle.Alloc (cb_wrapper));
			}
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
		static extern IntPtr gtk_toolbar_insert_stock (IntPtr raw, IntPtr stock_id, IntPtr tooltip_text, IntPtr tooltip_private_text, GtkSharp.SignalFuncNative cb, IntPtr user_data, int position);

		[Obsolete ("Replaced by ToolItem API")]
		public Gtk.Widget InsertStock (string stock_id, string tooltip_text, string tooltip_private_text, Gtk.SignalFunc cb, int position)
		{
			return InsertStock (stock_id, tooltip_text, tooltip_private_text, cb, IntPtr.Zero, position);
		}

		[Obsolete ("Replaced by ToolItem API")]
		public Gtk.Widget InsertStock (string stock_id, string tooltip_text, string tooltip_private_text, Gtk.SignalFunc cb, IntPtr user_data, int position)
		{
			GtkSharp.SignalFuncWrapper cb_wrapper = new GtkSharp.SignalFuncWrapper (cb);
			IntPtr nstock = GLib.Marshaller.StringToPtrGStrdup (stock_id);
			IntPtr ntiptext = GLib.Marshaller.StringToPtrGStrdup (tooltip_text);
			IntPtr ntipprivtext = GLib.Marshaller.StringToPtrGStrdup (tooltip_private_text);
			IntPtr raw_ret = gtk_toolbar_insert_stock (Handle, nstock, ntiptext, ntipprivtext, cb_wrapper.NativeDelegate, user_data, position);
			GLib.Marshaller.Free (nstock);
			GLib.Marshaller.Free (ntiptext);
			GLib.Marshaller.Free (ntipprivtext);
			Gtk.Widget ret;
			if (raw_ret == IntPtr.Zero)
				ret = null;
			else {
				ret = (Gtk.Widget) GLib.Object.GetObject (raw_ret);
				g_object_weak_ref (raw_ret, OnWeakNotify, (IntPtr) GCHandle.Alloc (cb_wrapper));
			}
			return ret;
		}

#endregion
	}

	internal class ToolbarAttribute : GLib.GTypeTypeAttribute {
		[DllImport ("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_toolbar_get_type ();

		private static GLib.GType _gtype = new GLib.GType (gtk_toolbar_get_type ());
		public static GLib.GType GType { get { return _gtype; } }
		public override GLib.GType Type { get { return _gtype; } }

	}
}
