// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gtk {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	[Container]
	public class Container : Gtk.Widget, IEnumerable {

		[Obsolete]
		protected Container(GLib.GType gtype) : base(gtype) {}
		public Container(IntPtr raw) : base(raw) {}

		protected Container() : base(IntPtr.Zero)
		{
			CreateNativeObject (Array.Empty<IntPtr> (), Array.Empty<GLib.Value> (), 0);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_container_get_resize_mode(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_container_set_resize_mode(IntPtr raw, int resize_mode);

		[GLib.Property ("resize-mode")]
		public Gtk.ResizeMode ResizeMode {
			get  {
				int raw_ret = gtk_container_get_resize_mode(Handle);
				Gtk.ResizeMode ret = (Gtk.ResizeMode) raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_container_set_resize_mode(Handle, (int) value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern uint gtk_container_get_border_width(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_container_set_border_width(IntPtr raw, uint border_width);

		[GLib.Property ("border-width")]
		public uint BorderWidth {
			get  {
				uint raw_ret = gtk_container_get_border_width(Handle);
				uint ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_container_set_border_width(Handle, value);
			}
		}

		[GLib.Property ("child")]
		public Gtk.Widget Child {
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("child", val);
				}
			}
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		extern static uint gtksharp_gtk_container_get_focus_child_offset ();

		static uint focus_child_offset = gtksharp_gtk_container_get_focus_child_offset ();
		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_container_set_focus_child(IntPtr raw, IntPtr child);

		public Gtk.Widget FocusChild {
			get {
				unsafe {
					IntPtr* raw_ptr = (IntPtr*)(((byte*)Handle) + focus_child_offset);
					return GLib.Object.GetObject((*raw_ptr)) as Gtk.Widget;
				}
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_container_set_focus_child(Handle, value == null ? IntPtr.Zero : value.Handle);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_container_set_reallocate_redraws(IntPtr raw, bool needs_redraws);

		public bool ReallocateRedraws {
			set  {
				Gtk.Application.AssertMainThread();
				gtk_container_set_reallocate_redraws(Handle, value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void AddedVMDelegate (IntPtr container, IntPtr widget);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_container_override_add (IntPtr gtype, AddedVMDelegate cb);

		static AddedVMDelegate AddedVMCallback;

		static void added_cb (IntPtr container, IntPtr widget)
		{
			try {
				Container container_managed = GLib.Object.GetObject (container, false) as Container;
				container_managed.OnAdded (GLib.Object.GetObject(widget) as Gtk.Widget);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideAdded (GLib.GType gtype)
		{
			if (AddedVMCallback == null)
				AddedVMCallback = new AddedVMDelegate (added_cb);
			gtksharp_container_override_add (gtype.Val, AddedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_container_base_add (IntPtr container, IntPtr widget);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Container), ConnectionMethod="OverrideAdded")]
		protected virtual void OnAdded (Gtk.Widget widget)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_container_base_add (Handle, widget == null ? IntPtr.Zero : widget.Handle);
		}

		[GLib.Signal("add")]
		public event Gtk.AddedHandler Added {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "add", typeof (Gtk.AddedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "add", typeof (Gtk.AddedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void RemovedVMDelegate (IntPtr container, IntPtr widget);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_container_override_remove (IntPtr gtype, RemovedVMDelegate cb);

		static RemovedVMDelegate RemovedVMCallback;

		static void removed_cb (IntPtr container, IntPtr widget)
		{
			try {
				Container container_managed = GLib.Object.GetObject (container, false) as Container;
				container_managed.OnRemoved (GLib.Object.GetObject(widget) as Gtk.Widget);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideRemoved (GLib.GType gtype)
		{
			if (RemovedVMCallback == null)
				RemovedVMCallback = new RemovedVMDelegate (removed_cb);
			gtksharp_container_override_remove (gtype.Val, RemovedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_container_base_remove (IntPtr container, IntPtr widget);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Container), ConnectionMethod="OverrideRemoved")]
		protected virtual void OnRemoved (Gtk.Widget widget)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_container_base_remove (Handle, widget == null ? IntPtr.Zero : widget.Handle);
		}

		[GLib.Signal("remove")]
		public event Gtk.RemovedHandler Removed {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "remove", typeof (Gtk.RemovedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "remove", typeof (Gtk.RemovedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ResizeCheckedVMDelegate (IntPtr container);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_container_override_check_resize (IntPtr gtype, ResizeCheckedVMDelegate cb);

		static ResizeCheckedVMDelegate ResizeCheckedVMCallback;

		static void resizechecked_cb (IntPtr container)
		{
			try {
				Container container_managed = GLib.Object.GetObject (container, false) as Container;
				container_managed.OnResizeChecked ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideResizeChecked (GLib.GType gtype)
		{
			if (ResizeCheckedVMCallback == null)
				ResizeCheckedVMCallback = new ResizeCheckedVMDelegate (resizechecked_cb);
			gtksharp_container_override_check_resize (gtype.Val, ResizeCheckedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_container_base_check_resize (IntPtr container);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Container), ConnectionMethod="OverrideResizeChecked")]
		protected virtual void OnResizeChecked ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_container_base_check_resize (Handle);
		}

		[GLib.Signal("check_resize")]
		public event System.EventHandler ResizeChecked {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "check_resize");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "check_resize");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void FocusChildSetVMDelegate (IntPtr container, IntPtr widget);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_container_override_set_focus_child (IntPtr gtype, FocusChildSetVMDelegate cb);

		static FocusChildSetVMDelegate FocusChildSetVMCallback;

		static void focuschildset_cb (IntPtr container, IntPtr widget)
		{
			try {
				Container container_managed = GLib.Object.GetObject (container, false) as Container;
				container_managed.OnFocusChildSet (GLib.Object.GetObject(widget) as Gtk.Widget);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideFocusChildSet (GLib.GType gtype)
		{
			if (FocusChildSetVMCallback == null)
				FocusChildSetVMCallback = new FocusChildSetVMDelegate (focuschildset_cb);
			gtksharp_container_override_set_focus_child (gtype.Val, FocusChildSetVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_container_base_set_focus_child (IntPtr container, IntPtr widget);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Container), ConnectionMethod="OverrideFocusChildSet")]
		protected virtual void OnFocusChildSet (Gtk.Widget widget)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_container_base_set_focus_child (Handle, widget == null ? IntPtr.Zero : widget.Handle);
		}

		[GLib.Signal("set-focus-child")]
		public event Gtk.FocusChildSetHandler FocusChildSet {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "set-focus-child", typeof (Gtk.FocusChildSetArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "set-focus-child", typeof (Gtk.FocusChildSetArgs));
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_container_add(IntPtr raw, IntPtr widget);

		public void Add(Gtk.Widget widget) {
			Gtk.Application.AssertMainThread();
			gtk_container_add(Handle, widget == null ? IntPtr.Zero : widget.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_container_check_resize(IntPtr raw);

		public void CheckResize() {
			gtk_container_check_resize(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_container_child_get_valist(IntPtr raw, IntPtr child, IntPtr first_property_name, IntPtr var_args);

		public void ChildGetValist(Gtk.Widget child, string first_property_name, IntPtr var_args) {
			Gtk.Application.AssertMainThread();
			IntPtr native_first_property_name = GLib.Marshaller.StringToPtrGStrdup (first_property_name);
			gtk_container_child_get_valist(Handle, child == null ? IntPtr.Zero : child.Handle, native_first_property_name, var_args);
			GLib.Marshaller.Free (native_first_property_name);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_container_child_set_property(IntPtr raw, IntPtr child, IntPtr property_name, ref GLib.Value value);

		public void ChildSetProperty(Gtk.Widget child, string property_name, GLib.Value value) {
			Gtk.Application.AssertMainThread();
			IntPtr native_property_name = GLib.Marshaller.StringToPtrGStrdup (property_name);
			gtk_container_child_set_property(Handle, child == null ? IntPtr.Zero : child.Handle, native_property_name, ref value);
			GLib.Marshaller.Free (native_property_name);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_container_child_set_valist(IntPtr raw, IntPtr child, IntPtr first_property_name, IntPtr var_args);

		public void ChildSetValist(Gtk.Widget child, string first_property_name, IntPtr var_args) {
			Gtk.Application.AssertMainThread();
			IntPtr native_first_property_name = GLib.Marshaller.StringToPtrGStrdup (first_property_name);
			gtk_container_child_set_valist(Handle, child == null ? IntPtr.Zero : child.Handle, native_first_property_name, var_args);
			GLib.Marshaller.Free (native_first_property_name);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_container_forall(IntPtr raw, GtkSharp.CallbackNative cb, IntPtr callback_data);

		public void Forall(Gtk.Callback cb) {
			Gtk.Application.AssertMainThread();
			GCHandle gch = GCHandle.Alloc (cb);
			gtk_container_forall(Handle, (cb == null) ? null : GtkSharp.CallbackWrapper.NativeDelegate, (IntPtr)gch);
			gch.Free();
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_container_foreach(IntPtr raw, GtkSharp.CallbackNative cb, IntPtr callback_data);

		public void Foreach(Gtk.Callback cb) {
			Gtk.Application.AssertMainThread();
			GCHandle gch = GCHandle.Alloc (cb);
			gtk_container_foreach(Handle, (cb == null) ? null : GtkSharp.CallbackWrapper.NativeDelegate, (IntPtr)gch);
			gch.Free();
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_container_get_children(IntPtr raw);

		public Gtk.Widget[] Children { 
			get {
				IntPtr raw_ret = gtk_container_get_children(Handle);
				Gtk.Widget[] ret = GLib.Marshaller.ListPtrToArray<Gtk.Widget> (raw_ret, typeof(GLib.List), true, false);
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_container_get_focus_hadjustment(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_container_set_focus_hadjustment(IntPtr raw, IntPtr adjustment);

		public Gtk.Adjustment FocusHadjustment { 
			get {
				IntPtr raw_ret = gtk_container_get_focus_hadjustment(Handle);
				Gtk.Adjustment ret = GLib.Object.GetObject(raw_ret) as Gtk.Adjustment;
				return ret;
			}
			set {
				Gtk.Application.AssertMainThread();
				gtk_container_set_focus_hadjustment(Handle, value == null ? IntPtr.Zero : value.Handle);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_container_get_focus_vadjustment(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_container_set_focus_vadjustment(IntPtr raw, IntPtr adjustment);

		public Gtk.Adjustment FocusVadjustment { 
			get {
				IntPtr raw_ret = gtk_container_get_focus_vadjustment(Handle);
				Gtk.Adjustment ret = GLib.Object.GetObject(raw_ret) as Gtk.Adjustment;
				return ret;
			}
			set {
				Gtk.Application.AssertMainThread();
				gtk_container_set_focus_vadjustment(Handle, value == null ? IntPtr.Zero : value.Handle);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_container_get_type();

		static GLib.GType _gtype = new GLib.GType (gtk_container_get_type());
		public static new GLib.GType GType { 
			get {
								return _gtype;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_container_propagate_expose(IntPtr raw, IntPtr child, IntPtr evnt);

		public void PropagateExpose(Gtk.Widget child, Gdk.EventExpose evnt) {
			Gtk.Application.AssertMainThread();
			gtk_container_propagate_expose(Handle, child == null ? IntPtr.Zero : child.Handle, evnt == null ? IntPtr.Zero : evnt.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_container_remove(IntPtr raw, IntPtr widget);

		public void Remove(Gtk.Widget widget) {
			Gtk.Application.AssertMainThread();
			gtk_container_remove(Handle, widget == null ? IntPtr.Zero : widget.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_container_resize_children(IntPtr raw);

		public void ResizeChildren() {
			gtk_container_resize_children(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_container_unset_focus_chain(IntPtr raw);

		public void UnsetFocusChain() {
			gtk_container_unset_focus_chain(Handle);
		}

#endregion
#region Customized extensions
#line 1 "Container.custom"
// Container.custom - customizations to Gtk.Container
//
// Authors: Mike Kestner  <mkestner@ximian.com>
//
// Copyright (c) 2004 Novell, Inc.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of version 2 of the Lesser GNU General
// Public License as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this program; if not, write to the
// Free Software Foundation, Inc., 59 Temple Place - Suite 330,
// Boston, MA 02111-1307, USA.


[DllImport("gtksharpglue-2", CallingConvention=CallingConvention.Cdecl)]
static extern void gtksharp_container_child_get_property (IntPtr container, IntPtr child, IntPtr property, ref GLib.Value value);

public GLib.Value ChildGetProperty (Gtk.Widget child, string property_name) {
	GLib.Value value = new GLib.Value ();

	IntPtr native = GLib.Marshaller.StringToPtrGStrdup (property_name);
	gtksharp_container_child_get_property (Handle, child.Handle, native, ref value);
	GLib.Marshaller.Free (native);
	return value;
}

public IEnumerator GetEnumerator ()
{
	return Children.GetEnumerator ();
}

class ChildAccumulator {
	public ArrayList Children = new ArrayList ();

	public void Add (Gtk.Widget widget)
	{
		Children.Add (widget);
	}
}

public IEnumerable AllChildren {
	get {
		ChildAccumulator acc = new ChildAccumulator ();
		Forall (new Gtk.Callback (acc.Add));
		return acc.Children;
	}
}

[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
static extern bool gtk_container_get_focus_chain (IntPtr raw, out IntPtr list_ptr);

[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
static extern void gtk_container_set_focus_chain (IntPtr raw, IntPtr list_ptr);

public Widget[] FocusChain {
	get {
		IntPtr list_ptr;
		bool success = gtk_container_get_focus_chain (Handle, out list_ptr);
		if (!success)
			return new Widget [0];

		return GLib.Marshaller.ListPtrToArray<Widget> (list_ptr, typeof(GLib.List), true, false);
	}
	set {
		GLib.List list = new GLib.List (IntPtr.Zero, typeof(Widget), true, false);
		foreach (Widget val in value)
			list.Append (val.Handle);
		gtk_container_set_focus_chain (Handle, list.Handle);
	}

}

[DllImport("gtksharpglue-2", CallingConvention=CallingConvention.Cdecl)]
static extern void gtksharp_container_base_forall (IntPtr handle, bool include_internals, IntPtr cb, IntPtr data);

[DllImport("gtksharpglue-2", CallingConvention=CallingConvention.Cdecl)]
static extern void gtksharp_container_override_forall (IntPtr gtype, ForallDelegate cb);

[DllImport("gtksharpglue-2", CallingConvention=CallingConvention.Cdecl)]
static extern void gtksharp_container_invoke_gtk_callback (IntPtr cb, IntPtr handle, IntPtr data);

[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
delegate void ForallDelegate (IntPtr container, bool include_internals, IntPtr cb, IntPtr data);

static ForallDelegate ForallOldCallback;
static ForallDelegate ForallCallback;

public struct CallbackInvoker {
	IntPtr cb;
	IntPtr data;

	internal CallbackInvoker (IntPtr cb, IntPtr data)
	{
		this.cb = cb;
		this.data = data;
	}

	internal IntPtr Data {
		get {
			return data;
		}
	}

	internal IntPtr Callback {
		get {
			return cb;
		}
	}

	public void Invoke (Widget w)
	{
		gtksharp_container_invoke_gtk_callback (cb, w.Handle, data);
	}
}

static void ForallOld_cb (IntPtr container, bool include_internals, IntPtr cb, IntPtr data)
{
	try {
		//GtkContainer's unmanaged dispose calls forall, but by that time the managed object is gone
		//so it couldn't do anything useful, and resurrecting it would cause a resurrection cycle.
		//In that case, just chain to the native base in case it can do something.
		Container obj = (Container) GLib.Object.TryGetObject (container);
		if (obj != null) {
			CallbackInvoker invoker = new CallbackInvoker (cb, data);
			obj.ForAll (include_internals, invoker);
		} else {
			gtksharp_container_base_forall (container, include_internals, cb, data);
		}
	} catch (Exception e) {
		GLib.ExceptionManager.RaiseUnhandledException (e, false);
	}
}

static void OverrideForallOld (GLib.GType gtype)
{
	if (ForallOldCallback == null)
		ForallOldCallback = new ForallDelegate (ForallOld_cb);
	gtksharp_container_override_forall (gtype.Val, ForallOldCallback);
}

[Obsolete ("Override the ForAll(bool,Gtk.Callback) method instead")]
[GLib.DefaultSignalHandler (Type=typeof(Gtk.Container), ConnectionMethod="OverrideForallOld")]
protected virtual void ForAll (bool include_internals, CallbackInvoker invoker)
{
	gtksharp_container_base_forall (Handle, include_internals, invoker.Callback, invoker.Data);
}

static void Forall_cb (IntPtr container, bool include_internals, IntPtr cb, IntPtr data)
{
	try {
		//GtkContainer's unmanaged dispose calls forall, but by that time the managed object is gone
		//so it couldn't do anything useful, and resurrecting it would cause a resurrection cycle.
		//In that case, just chain to the native base in case it can do something.
		Container obj = (Container) GLib.Object.TryGetObject (container);
		if (obj != null) {
			CallbackInvoker invoker = new CallbackInvoker (cb, data);
			obj.ForAll (include_internals, new Gtk.Callback (invoker.Invoke));
		} else {
			gtksharp_container_base_forall (container, include_internals, cb, data);
		}
	} catch (Exception e) {
		GLib.ExceptionManager.RaiseUnhandledException (e, false);
	}
}

static void OverrideForall (GLib.GType gtype)
{
	if (ForallCallback == null)
		ForallCallback = new ForallDelegate (Forall_cb);
	gtksharp_container_override_forall (gtype.Val, ForallCallback);
}

[GLib.DefaultSignalHandler (Type=typeof(Gtk.Container), ConnectionMethod="OverrideForall")]
protected virtual void ForAll (bool include_internals, Gtk.Callback callback)
{
	CallbackInvoker invoker;
	try {
		invoker = (CallbackInvoker)callback.Target;
	} catch {
		throw new ApplicationException ("ForAll can only be called as \"base.ForAll()\". Use Forall() or Foreach().");
	}
	gtksharp_container_base_forall (Handle, include_internals, invoker.Callback, invoker.Data);
}

[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
static extern IntPtr gtk_container_child_type(IntPtr raw);

[DllImport("gtksharpglue-2", CallingConvention=CallingConvention.Cdecl)]
static extern void gtksharp_container_override_child_type (IntPtr type, ChildTypeDelegate cb);

[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
delegate IntPtr ChildTypeDelegate (IntPtr raw);

static ChildTypeDelegate ChildTypeCallback;

static IntPtr ChildType_cb (IntPtr raw)
{
	try {
		Container obj = GLib.Object.GetObject (raw, false) as Container;
		GLib.GType gtype = obj.ChildType ();
		return gtype.Val;
	} catch (Exception e) {
		GLib.ExceptionManager.RaiseUnhandledException (e, false);
	}

	return GLib.GType.Invalid.Val;
}

static void OverrideChildType (GLib.GType gtype)
{
	if (ChildTypeCallback == null)
		ChildTypeCallback = new ChildTypeDelegate (ChildType_cb);
	gtksharp_container_override_child_type (gtype.Val, ChildTypeCallback);
}

[GLib.DefaultSignalHandler (Type=typeof(Gtk.Container), ConnectionMethod="OverrideChildType")]
public virtual GLib.GType ChildType() {
	IntPtr raw_ret = gtk_container_child_type(Handle);
	GLib.GType ret = new GLib.GType(raw_ret);
	return ret;
}

public class ContainerChild {
	protected Container parent;
	protected Widget child;

	public ContainerChild (Container parent, Widget child)
	{
		this.parent = parent;
		this.child = child;
	}

	public Container Parent {
		get {
			return parent;
		}
	}

	public Widget Child {
		get {
			return child;
		}
	}
}

public virtual ContainerChild this [Widget w] {
	get {
		return new ContainerChild (this, w);
	}
}

#endregion
	}

	internal class ContainerAttribute : GLib.GTypeTypeAttribute {
		[DllImport ("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_container_get_type ();

		private static GLib.GType _gtype = new GLib.GType (gtk_container_get_type ());
		public static GLib.GType GType { get { return _gtype; } }
		public override GLib.GType Type { get { return _gtype; } }

	}
}
