// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gtk {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	[IMContext]
	public class IMContext : GLib.Object {

		[Obsolete]
		protected IMContext(GLib.GType gtype) : base(gtype) {}
		public IMContext(IntPtr raw) : base(raw) {}

		protected IMContext() : base(IntPtr.Zero)
		{
			CreateNativeObject (Array.Empty<IntPtr> (), Array.Empty<GLib.Value> (), 0);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void PreeditStartVMDelegate (IntPtr context);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_imcontext_override_preedit_start (IntPtr gtype, PreeditStartVMDelegate cb);

		static PreeditStartVMDelegate PreeditStartVMCallback;

		static void preeditstart_cb (IntPtr context)
		{
			try {
				IMContext context_managed = GLib.Object.GetObject (context, false) as IMContext;
				context_managed.OnPreeditStart ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverridePreeditStart (GLib.GType gtype)
		{
			if (PreeditStartVMCallback == null)
				PreeditStartVMCallback = new PreeditStartVMDelegate (preeditstart_cb);
			gtksharp_imcontext_override_preedit_start (gtype.Val, PreeditStartVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_imcontext_base_preedit_start (IntPtr context);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.IMContext), ConnectionMethod="OverridePreeditStart")]
		protected virtual void OnPreeditStart ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_imcontext_base_preedit_start (Handle);
		}

		[GLib.Signal("preedit_start")]
		public event System.EventHandler PreeditStart {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "preedit_start");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "preedit_start");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void PreeditEndVMDelegate (IntPtr context);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_imcontext_override_preedit_end (IntPtr gtype, PreeditEndVMDelegate cb);

		static PreeditEndVMDelegate PreeditEndVMCallback;

		static void preeditend_cb (IntPtr context)
		{
			try {
				IMContext context_managed = GLib.Object.GetObject (context, false) as IMContext;
				context_managed.OnPreeditEnd ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverridePreeditEnd (GLib.GType gtype)
		{
			if (PreeditEndVMCallback == null)
				PreeditEndVMCallback = new PreeditEndVMDelegate (preeditend_cb);
			gtksharp_imcontext_override_preedit_end (gtype.Val, PreeditEndVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_imcontext_base_preedit_end (IntPtr context);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.IMContext), ConnectionMethod="OverridePreeditEnd")]
		protected virtual void OnPreeditEnd ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_imcontext_base_preedit_end (Handle);
		}

		[GLib.Signal("preedit_end")]
		public event System.EventHandler PreeditEnd {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "preedit_end");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "preedit_end");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void PreeditChangedVMDelegate (IntPtr context);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_imcontext_override_preedit_changed (IntPtr gtype, PreeditChangedVMDelegate cb);

		static PreeditChangedVMDelegate PreeditChangedVMCallback;

		static void preeditchanged_cb (IntPtr context)
		{
			try {
				IMContext context_managed = GLib.Object.GetObject (context, false) as IMContext;
				context_managed.OnPreeditChanged ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverridePreeditChanged (GLib.GType gtype)
		{
			if (PreeditChangedVMCallback == null)
				PreeditChangedVMCallback = new PreeditChangedVMDelegate (preeditchanged_cb);
			gtksharp_imcontext_override_preedit_changed (gtype.Val, PreeditChangedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_imcontext_base_preedit_changed (IntPtr context);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.IMContext), ConnectionMethod="OverridePreeditChanged")]
		protected virtual void OnPreeditChanged ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_imcontext_base_preedit_changed (Handle);
		}

		[GLib.Signal("preedit_changed")]
		public event System.EventHandler PreeditChanged {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "preedit_changed");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "preedit_changed");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void CommitVMDelegate (IntPtr context, IntPtr str);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_imcontext_override_commit (IntPtr gtype, CommitVMDelegate cb);

		static CommitVMDelegate CommitVMCallback;

		static void commit_cb (IntPtr context, IntPtr str)
		{
			try {
				IMContext context_managed = GLib.Object.GetObject (context, false) as IMContext;
				context_managed.OnCommit (GLib.Marshaller.Utf8PtrToString (str));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideCommit (GLib.GType gtype)
		{
			if (CommitVMCallback == null)
				CommitVMCallback = new CommitVMDelegate (commit_cb);
			gtksharp_imcontext_override_commit (gtype.Val, CommitVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_imcontext_base_commit (IntPtr context, IntPtr str);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.IMContext), ConnectionMethod="OverrideCommit")]
		protected virtual void OnCommit (string str)
		{
			Gtk.Application.AssertMainThread();
			IntPtr native_str = GLib.Marshaller.StringToPtrGStrdup (str);
			gtksharp_imcontext_base_commit (Handle, native_str);
			GLib.Marshaller.Free (native_str);
		}

		[GLib.Signal("commit")]
		public event Gtk.CommitHandler Commit {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "commit", typeof (Gtk.CommitArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "commit", typeof (Gtk.CommitArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool RetrieveSurroundingVMDelegate (IntPtr context);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_imcontext_override_retrieve_surrounding (IntPtr gtype, RetrieveSurroundingVMDelegate cb);

		static RetrieveSurroundingVMDelegate RetrieveSurroundingVMCallback;

		static bool retrievesurrounding_cb (IntPtr context)
		{
			try {
				IMContext context_managed = GLib.Object.GetObject (context, false) as IMContext;
				return context_managed.OnRetrieveSurrounding ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideRetrieveSurrounding (GLib.GType gtype)
		{
			if (RetrieveSurroundingVMCallback == null)
				RetrieveSurroundingVMCallback = new RetrieveSurroundingVMDelegate (retrievesurrounding_cb);
			gtksharp_imcontext_override_retrieve_surrounding (gtype.Val, RetrieveSurroundingVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_imcontext_base_retrieve_surrounding (IntPtr context);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.IMContext), ConnectionMethod="OverrideRetrieveSurrounding")]
		protected virtual bool OnRetrieveSurrounding ()
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_imcontext_base_retrieve_surrounding (Handle);
			return __ret;
		}

		[GLib.Signal("retrieve_surrounding")]
		public event Gtk.RetrieveSurroundingHandler RetrieveSurrounding {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "retrieve_surrounding", typeof (Gtk.RetrieveSurroundingArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "retrieve_surrounding", typeof (Gtk.RetrieveSurroundingArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool SurroundingDeletedVMDelegate (IntPtr context, int offset, int n_chars);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_imcontext_override_delete_surrounding (IntPtr gtype, SurroundingDeletedVMDelegate cb);

		static SurroundingDeletedVMDelegate SurroundingDeletedVMCallback;

		static bool surroundingdeleted_cb (IntPtr context, int offset, int n_chars)
		{
			try {
				IMContext context_managed = GLib.Object.GetObject (context, false) as IMContext;
				return context_managed.OnSurroundingDeleted (offset, n_chars);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideSurroundingDeleted (GLib.GType gtype)
		{
			if (SurroundingDeletedVMCallback == null)
				SurroundingDeletedVMCallback = new SurroundingDeletedVMDelegate (surroundingdeleted_cb);
			gtksharp_imcontext_override_delete_surrounding (gtype.Val, SurroundingDeletedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_imcontext_base_delete_surrounding (IntPtr context, int offset, int n_chars);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.IMContext), ConnectionMethod="OverrideSurroundingDeleted")]
		protected virtual bool OnSurroundingDeleted (int offset, int n_chars)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_imcontext_base_delete_surrounding (Handle, offset, n_chars);
			return __ret;
		}

		[GLib.Signal("delete_surrounding")]
		public event Gtk.SurroundingDeletedHandler SurroundingDeleted {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "delete_surrounding", typeof (Gtk.SurroundingDeletedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "delete_surrounding", typeof (Gtk.SurroundingDeletedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_im_context_delete_surrounding(IntPtr raw, int offset, int n_chars);

		public bool DeleteSurrounding(int offset, int n_chars) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_im_context_delete_surrounding(Handle, offset, n_chars);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_im_context_filter_keypress(IntPtr raw, IntPtr evnt);

		public bool FilterKeypress(Gdk.EventKey evnt) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_im_context_filter_keypress(Handle, evnt == null ? IntPtr.Zero : evnt.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_im_context_focus_in(IntPtr raw);

		public void FocusIn() {
			gtk_im_context_focus_in(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_im_context_focus_out(IntPtr raw);

		public void FocusOut() {
			gtk_im_context_focus_out(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_im_context_get_preedit_string(IntPtr raw, out IntPtr str, out IntPtr attrs, out int cursor_pos);

		public void GetPreeditString(out string str, out Pango.AttrList attrs, out int cursor_pos) {
			Gtk.Application.AssertMainThread();
			IntPtr native_str;
			IntPtr native_attrs;
			gtk_im_context_get_preedit_string(Handle, out native_str, out native_attrs, out cursor_pos);
			str = GLib.Marshaller.PtrToStringGFree(native_str);
			attrs = native_attrs == IntPtr.Zero ? null : (Pango.AttrList) GLib.Opaque.GetOpaque (native_attrs, typeof (Pango.AttrList), true);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_im_context_get_surrounding(IntPtr raw, out IntPtr text, out int cursor_index);

		public bool GetSurrounding(out string text, out int cursor_index) {
			Gtk.Application.AssertMainThread();
			IntPtr native_text;
			bool raw_ret = gtk_im_context_get_surrounding(Handle, out native_text, out cursor_index);
			bool ret = raw_ret;
			text = GLib.Marshaller.PtrToStringGFree(native_text);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_im_context_get_type();

		static GLib.GType _gtype = new GLib.GType (gtk_im_context_get_type());
		public static new GLib.GType GType { 
			get {
								return _gtype;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_im_context_reset(IntPtr raw);

		public void Reset() {
			gtk_im_context_reset(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_im_context_set_client_window(IntPtr raw, IntPtr window);

		public Gdk.Window ClientWindow { 
			set {
				Gtk.Application.AssertMainThread();
				gtk_im_context_set_client_window(Handle, value == null ? IntPtr.Zero : value.Handle);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_im_context_set_cursor_location(IntPtr raw, ref Gdk.Rectangle value);

		public Gdk.Rectangle CursorLocation { 
			set {
				Gtk.Application.AssertMainThread();
				gtk_im_context_set_cursor_location(Handle, ref value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_im_context_set_surrounding(IntPtr raw, IntPtr text, int len, int cursor_index);

		public void SetSurrounding(string text, int cursor_index) {
			Gtk.Application.AssertMainThread();
			IntPtr native_text = GLib.Marshaller.StringToPtrGStrdup (text);
			gtk_im_context_set_surrounding(Handle, native_text, System.Text.Encoding.UTF8.GetByteCount (text), cursor_index);
			GLib.Marshaller.Free (native_text);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_im_context_set_use_preedit(IntPtr raw, bool use_preedit);

		public bool UsePreedit { 
			set {
				Gtk.Application.AssertMainThread();
				gtk_im_context_set_use_preedit(Handle, value);
			}
		}

#endregion
	}

	internal class IMContextAttribute : GLib.GTypeTypeAttribute {
		[DllImport ("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_im_context_get_type ();

		private static GLib.GType _gtype = new GLib.GType (gtk_im_context_get_type ());
		public static GLib.GType GType { get { return _gtype; } }
		public override GLib.GType Type { get { return _gtype; } }

	}
}
