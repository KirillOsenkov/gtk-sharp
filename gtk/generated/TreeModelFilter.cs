// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gtk {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	[TreeModelFilter]
	public class TreeModelFilter : GLib.Object, Gtk.TreeModel, Gtk.TreeDragSource {

		[Obsolete]
		protected TreeModelFilter(GLib.GType gtype) : base(gtype) {}
		public TreeModelFilter(IntPtr raw) : base(raw) {}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_tree_model_filter_new(IntPtr child_model, IntPtr root);

		public TreeModelFilter (Gtk.TreeModel child_model, Gtk.TreePath root) : base (IntPtr.Zero)
		{
			if (GetType () != typeof (TreeModelFilter)) {
				Gtk.Application.AssertMainThread();
				unsafe {
					var vals = stackalloc GLib.Value[2];
					var names = stackalloc IntPtr[2];
					var param_count = 0;
					if (child_model != null) {
						names[param_count] = GLib.Marshaller.StringToPtrGStrdup ("child_model");
						vals[param_count++] = new GLib.Value (child_model);
					}
					if (root != null) {
						names[param_count] = GLib.Marshaller.StringToPtrGStrdup ("virtual-root");
						vals[param_count++] = new GLib.Value (root);
					}
					CreateNativeObject (names, vals, param_count);
				}
				return;
			}
			Gtk.Application.AssertMainThread();
			owned = true;
			Raw = gtk_tree_model_filter_new(child_model == null ? IntPtr.Zero : child_model.Handle, root == null ? IntPtr.Zero : root.Handle);
		}

		[GLib.Property ("child-model")]
		public Gtk.TreeModel ChildModel {
			get {
				using (GLib.Value val = GetProperty ("child-model")) {
					Gtk.TreeModel ret = Gtk.TreeModelAdapter.GetObject ((GLib.Object) val);
					return ret;
				}
			}
		}

		[GLib.Property ("virtual-root")]
		public Gtk.TreePath VirtualRoot {
			get {
				using (GLib.Value val = GetProperty ("virtual-root")) {
					Gtk.TreePath ret = (Gtk.TreePath) val;
					return ret;
				}
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_model_filter_clear_cache(IntPtr raw);

		public void ClearCache() {
			gtk_tree_model_filter_clear_cache(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_tree_model_filter_convert_child_path_to_path(IntPtr raw, IntPtr child_path);

		public Gtk.TreePath ConvertChildPathToPath(Gtk.TreePath child_path) {
			Gtk.Application.AssertMainThread();
			IntPtr raw_ret = gtk_tree_model_filter_convert_child_path_to_path(Handle, child_path == null ? IntPtr.Zero : child_path.Handle);
			Gtk.TreePath ret = raw_ret == IntPtr.Zero ? null : (Gtk.TreePath) GLib.Opaque.GetOpaque (raw_ret, typeof (Gtk.TreePath), true);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_model_filter_convert_iter_to_child_iter(IntPtr raw, ref Gtk.TreeIter child_iter, ref Gtk.TreeIter filter_iter);

		public Gtk.TreeIter ConvertIterToChildIter(Gtk.TreeIter filter_iter) {
			Gtk.TreeIter child_iter;
			Gtk.Application.AssertMainThread();
			child_iter = new Gtk.TreeIter();
			gtk_tree_model_filter_convert_iter_to_child_iter(Handle, ref child_iter, ref filter_iter);
			return child_iter;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_tree_model_filter_convert_path_to_child_path(IntPtr raw, IntPtr filter_path);

		public Gtk.TreePath ConvertPathToChildPath(Gtk.TreePath filter_path) {
			Gtk.Application.AssertMainThread();
			IntPtr raw_ret = gtk_tree_model_filter_convert_path_to_child_path(Handle, filter_path == null ? IntPtr.Zero : filter_path.Handle);
			Gtk.TreePath ret = raw_ret == IntPtr.Zero ? null : (Gtk.TreePath) GLib.Opaque.GetOpaque (raw_ret, typeof (Gtk.TreePath), true);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_tree_model_filter_get_model(IntPtr raw);

		public Gtk.TreeModel Model { 
			get {
				IntPtr raw_ret = gtk_tree_model_filter_get_model(Handle);
				Gtk.TreeModel ret = Gtk.TreeModelAdapter.GetObject (raw_ret, false);
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_tree_model_filter_get_type();

		static GLib.GType _gtype = new GLib.GType (gtk_tree_model_filter_get_type());
		public static new GLib.GType GType { 
			get {
								return _gtype;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_model_filter_refilter(IntPtr raw);

		public void Refilter() {
			gtk_tree_model_filter_refilter(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_model_filter_set_visible_column(IntPtr raw, int column);

		public int VisibleColumn { 
			set {
				Gtk.Application.AssertMainThread();
				gtk_tree_model_filter_set_visible_column(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_model_filter_set_visible_func(IntPtr raw, GtkSharp.TreeModelFilterVisibleFuncNative func, IntPtr data, GLib.DestroyNotify destroy);

		public Gtk.TreeModelFilterVisibleFunc VisibleFunc { 
			set {
				Gtk.Application.AssertMainThread();
				IntPtr data;
				GLib.DestroyNotify destroy;
				if (value == null) {
					data = IntPtr.Zero;
					destroy = null;
				} else {
					data = (IntPtr) GCHandle.Alloc (value);
					destroy = GLib.DestroyHelper.NotifyHandler;
				}
				gtk_tree_model_filter_set_visible_func(Handle, (value == null) ? null : GtkSharp.TreeModelFilterVisibleFuncWrapper.NativeDelegate, data, destroy);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_model_foreach(IntPtr raw, GtkSharp.TreeModelForeachFuncNative func, IntPtr user_data);

		public void Foreach(Gtk.TreeModelForeachFunc func) {
			Gtk.Application.AssertMainThread();
			GCHandle gch = GCHandle.Alloc (func);
			gtk_tree_model_foreach(Handle, (func == null) ? null : GtkSharp.TreeModelForeachFuncWrapper.NativeDelegate, (IntPtr)gch);
			gch.Free();
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_tree_model_get_column_type(IntPtr raw, int index_);

		public GLib.GType GetColumnType(int index_) {
			Gtk.Application.AssertMainThread();
			IntPtr raw_ret = gtk_tree_model_get_column_type(Handle, index_);
			GLib.GType ret = new GLib.GType(raw_ret);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_tree_model_get_flags(IntPtr raw);

		public Gtk.TreeModelFlags Flags { 
			get {
				int raw_ret = gtk_tree_model_get_flags(Handle);
				Gtk.TreeModelFlags ret = (Gtk.TreeModelFlags) raw_ret;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_model_get_iter(IntPtr raw, ref Gtk.TreeIter iter, IntPtr path);

		public bool GetIter(out Gtk.TreeIter iter, Gtk.TreePath path) {
			Gtk.Application.AssertMainThread();
			iter = new Gtk.TreeIter();
			bool raw_ret = gtk_tree_model_get_iter(Handle, ref iter, path == null ? IntPtr.Zero : path.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_model_get_iter_first(IntPtr raw, ref Gtk.TreeIter iter);

		public bool GetIterFirst(out Gtk.TreeIter iter) {
			Gtk.Application.AssertMainThread();
			iter = new Gtk.TreeIter();
			bool raw_ret = gtk_tree_model_get_iter_first(Handle, ref iter);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_model_get_iter_from_string(IntPtr raw, ref Gtk.TreeIter iter, IntPtr path_string);

		public bool GetIterFromString(out Gtk.TreeIter iter, string path_string) {
			Gtk.Application.AssertMainThread();
			iter = new Gtk.TreeIter();
			IntPtr native_path_string = GLib.Marshaller.StringToPtrGStrdup (path_string);
			bool raw_ret = gtk_tree_model_get_iter_from_string(Handle, ref iter, native_path_string);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_path_string);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_tree_model_get_n_columns(IntPtr raw);

		public int NColumns { 
			get {
				int raw_ret = gtk_tree_model_get_n_columns(Handle);
				int ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_tree_model_get_path(IntPtr raw, ref Gtk.TreeIter iter);

		public Gtk.TreePath GetPath(Gtk.TreeIter iter) {
			Gtk.Application.AssertMainThread();
			IntPtr raw_ret = gtk_tree_model_get_path(Handle, ref iter);
			Gtk.TreePath ret = raw_ret == IntPtr.Zero ? null : (Gtk.TreePath) GLib.Opaque.GetOpaque (raw_ret, typeof (Gtk.TreePath), true);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_tree_model_get_string_from_iter(IntPtr raw, ref Gtk.TreeIter iter);

		public string GetStringFromIter(Gtk.TreeIter iter) {
			Gtk.Application.AssertMainThread();
			IntPtr raw_ret = gtk_tree_model_get_string_from_iter(Handle, ref iter);
			string ret = GLib.Marshaller.PtrToStringGFree(raw_ret);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_model_get_valist(IntPtr raw, ref Gtk.TreeIter iter, IntPtr var_args);

		public void GetValist(Gtk.TreeIter iter, IntPtr var_args) {
			Gtk.Application.AssertMainThread();
			gtk_tree_model_get_valist(Handle, ref iter, var_args);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_model_get_value(IntPtr raw, ref Gtk.TreeIter iter, int column, ref GLib.Value value);

		public void GetValue(Gtk.TreeIter iter, int column, ref GLib.Value value) {
			Gtk.Application.AssertMainThread();
			gtk_tree_model_get_value(Handle, ref iter, column, ref value);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_model_iter_children(IntPtr raw, ref Gtk.TreeIter iter, ref Gtk.TreeIter parent);

		public bool IterChildren(out Gtk.TreeIter iter, Gtk.TreeIter parent) {
			Gtk.Application.AssertMainThread();
			iter = new Gtk.TreeIter();
			bool raw_ret = gtk_tree_model_iter_children(Handle, ref iter, ref parent);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_model_iter_has_child(IntPtr raw, ref Gtk.TreeIter iter);

		public bool IterHasChild(Gtk.TreeIter iter) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_tree_model_iter_has_child(Handle, ref iter);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_tree_model_iter_n_children(IntPtr raw, ref Gtk.TreeIter iter);

		public int IterNChildren(Gtk.TreeIter iter) {
			Gtk.Application.AssertMainThread();
			int raw_ret = gtk_tree_model_iter_n_children(Handle, ref iter);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_model_iter_next(IntPtr raw, ref Gtk.TreeIter iter);

		public bool IterNext(ref Gtk.TreeIter iter) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_tree_model_iter_next(Handle, ref iter);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_model_iter_nth_child(IntPtr raw, ref Gtk.TreeIter iter, ref Gtk.TreeIter parent, int n);

		public bool IterNthChild(out Gtk.TreeIter iter, Gtk.TreeIter parent, int n) {
			Gtk.Application.AssertMainThread();
			iter = new Gtk.TreeIter();
			bool raw_ret = gtk_tree_model_iter_nth_child(Handle, ref iter, ref parent, n);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_model_iter_parent(IntPtr raw, ref Gtk.TreeIter iter, ref Gtk.TreeIter child);

		public bool IterParent(out Gtk.TreeIter iter, Gtk.TreeIter child) {
			Gtk.Application.AssertMainThread();
			iter = new Gtk.TreeIter();
			bool raw_ret = gtk_tree_model_iter_parent(Handle, ref iter, ref child);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_model_ref_node(IntPtr raw, ref Gtk.TreeIter iter);

		public void RefNode(Gtk.TreeIter iter) {
			Gtk.Application.AssertMainThread();
			gtk_tree_model_ref_node(Handle, ref iter);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_model_row_changed(IntPtr raw, IntPtr path, ref Gtk.TreeIter iter);

		public void EmitRowChanged(Gtk.TreePath path, Gtk.TreeIter iter) {
			Gtk.Application.AssertMainThread();
			gtk_tree_model_row_changed(Handle, path == null ? IntPtr.Zero : path.Handle, ref iter);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_model_row_deleted(IntPtr raw, IntPtr path);

		public void EmitRowDeleted(Gtk.TreePath path) {
			Gtk.Application.AssertMainThread();
			gtk_tree_model_row_deleted(Handle, path == null ? IntPtr.Zero : path.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_model_row_has_child_toggled(IntPtr raw, IntPtr path, ref Gtk.TreeIter iter);

		public void EmitRowHasChildToggled(Gtk.TreePath path, Gtk.TreeIter iter) {
			Gtk.Application.AssertMainThread();
			gtk_tree_model_row_has_child_toggled(Handle, path == null ? IntPtr.Zero : path.Handle, ref iter);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_model_row_inserted(IntPtr raw, IntPtr path, ref Gtk.TreeIter iter);

		public void EmitRowInserted(Gtk.TreePath path, Gtk.TreeIter iter) {
			Gtk.Application.AssertMainThread();
			gtk_tree_model_row_inserted(Handle, path == null ? IntPtr.Zero : path.Handle, ref iter);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_model_rows_reordered(IntPtr raw, IntPtr path, ref Gtk.TreeIter iter, int[] new_order);

		public void EmitRowsReordered(Gtk.TreePath path, Gtk.TreeIter iter, int[] new_order) {
			Gtk.Application.AssertMainThread();
			gtk_tree_model_rows_reordered(Handle, path == null ? IntPtr.Zero : path.Handle, ref iter, new_order);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_tree_model_unref_node(IntPtr raw, ref Gtk.TreeIter iter);

		public void UnrefNode(Gtk.TreeIter iter) {
			Gtk.Application.AssertMainThread();
			gtk_tree_model_unref_node(Handle, ref iter);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void RowChangedVMDelegate (IntPtr tree_model, IntPtr path, IntPtr iter);

		static RowChangedVMDelegate RowChangedVMCallback;

		static void rowchanged_cb (IntPtr tree_model, IntPtr path, IntPtr iter)
		{
			try {
				TreeModelFilter tree_model_managed = GLib.Object.GetObject (tree_model, false) as TreeModelFilter;
				tree_model_managed.OnRowChanged (path == IntPtr.Zero ? null : (Gtk.TreePath) GLib.Opaque.GetOpaque (path, typeof (Gtk.TreePath), false), Gtk.TreeIter.New (iter));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideRowChanged (GLib.GType gtype)
		{
			if (RowChangedVMCallback == null)
				RowChangedVMCallback = new RowChangedVMDelegate (rowchanged_cb);
			OverrideVirtualMethod (gtype, "row_changed", RowChangedVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TreeModelFilter), ConnectionMethod="OverrideRowChanged")]
		protected virtual void OnRowChanged (Gtk.TreePath path, Gtk.TreeIter iter)
		{
			GLib.Value ret = GLib.Value.Empty;
			unsafe {
				GLib.Value* inst_and_params = stackalloc GLib.Value [3];
				using (inst_and_params[0] = new GLib.Value (this)) {
					using (inst_and_params [1] = new GLib.Value (path)) {
						using (inst_and_params [2] = new GLib.Value (iter)) {
							g_signal_chain_from_overridden (inst_and_params, ref ret);
						}
					}
				}
			}
		}

		[GLib.Signal("row_changed")]
		public event Gtk.RowChangedHandler RowChanged {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "row_changed", typeof (Gtk.RowChangedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "row_changed", typeof (Gtk.RowChangedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void RowInsertedVMDelegate (IntPtr tree_model, IntPtr path, IntPtr iter);

		static RowInsertedVMDelegate RowInsertedVMCallback;

		static void rowinserted_cb (IntPtr tree_model, IntPtr path, IntPtr iter)
		{
			try {
				TreeModelFilter tree_model_managed = GLib.Object.GetObject (tree_model, false) as TreeModelFilter;
				tree_model_managed.OnRowInserted (path == IntPtr.Zero ? null : (Gtk.TreePath) GLib.Opaque.GetOpaque (path, typeof (Gtk.TreePath), false), Gtk.TreeIter.New (iter));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideRowInserted (GLib.GType gtype)
		{
			if (RowInsertedVMCallback == null)
				RowInsertedVMCallback = new RowInsertedVMDelegate (rowinserted_cb);
			OverrideVirtualMethod (gtype, "row_inserted", RowInsertedVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TreeModelFilter), ConnectionMethod="OverrideRowInserted")]
		protected virtual void OnRowInserted (Gtk.TreePath path, Gtk.TreeIter iter)
		{
			GLib.Value ret = GLib.Value.Empty;
			unsafe {
				GLib.Value* inst_and_params = stackalloc GLib.Value [3];
				using (inst_and_params[0] = new GLib.Value (this)) {
					using (inst_and_params [1] = new GLib.Value (path)) {
						using (inst_and_params [2] = new GLib.Value (iter)) {
							g_signal_chain_from_overridden (inst_and_params, ref ret);
						}
					}
				}
			}
		}

		[GLib.Signal("row_inserted")]
		public event Gtk.RowInsertedHandler RowInserted {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "row_inserted", typeof (Gtk.RowInsertedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "row_inserted", typeof (Gtk.RowInsertedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void RowHasChildToggledVMDelegate (IntPtr tree_model, IntPtr path, IntPtr iter);

		static RowHasChildToggledVMDelegate RowHasChildToggledVMCallback;

		static void rowhaschildtoggled_cb (IntPtr tree_model, IntPtr path, IntPtr iter)
		{
			try {
				TreeModelFilter tree_model_managed = GLib.Object.GetObject (tree_model, false) as TreeModelFilter;
				tree_model_managed.OnRowHasChildToggled (path == IntPtr.Zero ? null : (Gtk.TreePath) GLib.Opaque.GetOpaque (path, typeof (Gtk.TreePath), false), Gtk.TreeIter.New (iter));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideRowHasChildToggled (GLib.GType gtype)
		{
			if (RowHasChildToggledVMCallback == null)
				RowHasChildToggledVMCallback = new RowHasChildToggledVMDelegate (rowhaschildtoggled_cb);
			OverrideVirtualMethod (gtype, "row_has_child_toggled", RowHasChildToggledVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TreeModelFilter), ConnectionMethod="OverrideRowHasChildToggled")]
		protected virtual void OnRowHasChildToggled (Gtk.TreePath path, Gtk.TreeIter iter)
		{
			GLib.Value ret = GLib.Value.Empty;
			unsafe {
				GLib.Value* inst_and_params = stackalloc GLib.Value [3];
				using (inst_and_params[0] = new GLib.Value (this)) {
					using (inst_and_params [1] = new GLib.Value (path)) {
						using (inst_and_params [2] = new GLib.Value (iter)) {
							g_signal_chain_from_overridden (inst_and_params, ref ret);
						}
					}
				}
			}
		}

		[GLib.Signal("row_has_child_toggled")]
		public event Gtk.RowHasChildToggledHandler RowHasChildToggled {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "row_has_child_toggled", typeof (Gtk.RowHasChildToggledArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "row_has_child_toggled", typeof (Gtk.RowHasChildToggledArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void RowDeletedVMDelegate (IntPtr tree_model, IntPtr path);

		static RowDeletedVMDelegate RowDeletedVMCallback;

		static void rowdeleted_cb (IntPtr tree_model, IntPtr path)
		{
			try {
				TreeModelFilter tree_model_managed = GLib.Object.GetObject (tree_model, false) as TreeModelFilter;
				tree_model_managed.OnRowDeleted (path == IntPtr.Zero ? null : (Gtk.TreePath) GLib.Opaque.GetOpaque (path, typeof (Gtk.TreePath), false));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideRowDeleted (GLib.GType gtype)
		{
			if (RowDeletedVMCallback == null)
				RowDeletedVMCallback = new RowDeletedVMDelegate (rowdeleted_cb);
			OverrideVirtualMethod (gtype, "row_deleted", RowDeletedVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TreeModelFilter), ConnectionMethod="OverrideRowDeleted")]
		protected virtual void OnRowDeleted (Gtk.TreePath path)
		{
			GLib.Value ret = GLib.Value.Empty;
			unsafe {
				GLib.Value* inst_and_params = stackalloc GLib.Value [2];
				using (inst_and_params[0] = new GLib.Value (this)) {
					using (inst_and_params [1] = new GLib.Value (path)) {
						g_signal_chain_from_overridden (inst_and_params, ref ret);
					}
				}
			}
		}

		[GLib.Signal("row_deleted")]
		public event Gtk.RowDeletedHandler RowDeleted {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "row_deleted", typeof (Gtk.RowDeletedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "row_deleted", typeof (Gtk.RowDeletedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_drag_source_drag_data_delete(IntPtr raw, IntPtr path);

		public bool DragDataDelete(Gtk.TreePath path) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_tree_drag_source_drag_data_delete(Handle, path == null ? IntPtr.Zero : path.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_drag_source_drag_data_get(IntPtr raw, IntPtr path, IntPtr selection_data);

		public bool DragDataGet(Gtk.TreePath path, Gtk.SelectionData selection_data) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_tree_drag_source_drag_data_get(Handle, path == null ? IntPtr.Zero : path.Handle, selection_data == null ? IntPtr.Zero : selection_data.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_tree_drag_source_row_draggable(IntPtr raw, IntPtr path);

		public bool RowDraggable(Gtk.TreePath path) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_tree_drag_source_row_draggable(Handle, path == null ? IntPtr.Zero : path.Handle);
			bool ret = raw_ret;
			return ret;
		}

#endregion
#region Customized extensions
#line 1 "TreeModelFilter.custom"
		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
		static extern bool gtk_tree_model_iter_children (IntPtr raw, out Gtk.TreeIter iter, IntPtr parent);
		public bool IterChildren (out Gtk.TreeIter iter) {
			bool raw_ret = gtk_tree_model_iter_children (Handle, out iter, IntPtr.Zero);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", EntryPoint="gtk_tree_model_iter_n_children", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_tree_model_iter_n_children_ptr(IntPtr raw, IntPtr iter);

		public int IterNChildren ()
		{
			int raw_ret = gtk_tree_model_iter_n_children_ptr (Handle, IntPtr.Zero);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
		static extern bool gtk_tree_model_iter_nth_child (IntPtr raw, out Gtk.TreeIter iter, IntPtr parent, int n);
		public bool IterNthChild (out Gtk.TreeIter iter, int n) {
			bool raw_ret = gtk_tree_model_iter_nth_child (Handle, out iter, IntPtr.Zero, n);
			bool ret = raw_ret;
			return ret;
		}

		public void SetValue (Gtk.TreeIter iter, int column, bool value) {
			throw new NotImplementedException ();
		}

		public void SetValue (Gtk.TreeIter iter, int column, double value) {
			throw new NotImplementedException ();
		}

		public void SetValue (Gtk.TreeIter iter, int column, int value) {
			throw new NotImplementedException ();
		}

		public void SetValue (Gtk.TreeIter iter, int column, string value) {
			throw new NotImplementedException ();
		}

		public void SetValue (Gtk.TreeIter iter, int column, float value) {
			throw new NotImplementedException ();
		}

		public void SetValue (Gtk.TreeIter iter, int column, uint value) {
			throw new NotImplementedException ();
		}

		public void SetValue (Gtk.TreeIter iter, int column, object value) {
			throw new NotImplementedException ();
		}

		public object GetValue (Gtk.TreeIter iter, int column) {
			GLib.Value val = GLib.Value.Empty;
			GetValue (iter, column, ref val);
			object ret = val.Val;
			val.Dispose ();
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
		static extern void gtk_tree_model_filter_set_modify_func(IntPtr raw, int n_columns, IntPtr[] types, GtkSharp.TreeModelFilterModifyFuncNative func, IntPtr data, GLib.DestroyNotify destroy);

		public void SetModifyFunc (int n_columns, GLib.GType[] types, TreeModelFilterModifyFunc func)
		{
			IntPtr[] native_types = new IntPtr [types.Length];
			for (int i = 0; i < types.Length; i++)
				native_types [i] = types [i].Val;
			IntPtr data;
			GLib.DestroyNotify destroy;
			if (func == null) {
				data = IntPtr.Zero;
				destroy = null;
			} else {
				data = (IntPtr)GCHandle.Alloc (func);
				destroy = GLib.DestroyHelper.NotifyHandler;
			}

			gtk_tree_model_filter_set_modify_func (Handle, n_columns, native_types, GtkSharp.TreeModelFilterModifyFuncWrapper.NativeDelegate, data, destroy);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
		static extern bool gtk_tree_model_filter_convert_child_iter_to_iter (IntPtr raw, out Gtk.TreeIter filter_iter, ref Gtk.TreeIter child_iter);

		public TreeIter ConvertChildIterToIter (Gtk.TreeIter child_iter)
		{
			TreeIter filter_iter;
			if (gtk_tree_model_filter_convert_child_iter_to_iter(Handle, out filter_iter, ref child_iter))
				return filter_iter;
			else
				return TreeIter.Zero;
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void RowsReorderedSignalDelegate (IntPtr arg0, IntPtr arg1, IntPtr arg2, IntPtr arg3, IntPtr gch);

		static void RowsReorderedSignalCallback (IntPtr arg0, IntPtr arg1, IntPtr arg2, IntPtr arg3, IntPtr gch)
		{
			Gtk.RowsReorderedArgs args = new Gtk.RowsReorderedArgs ();
			try {
				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
				if (sig == null)
					throw new Exception("Unknown signal GC handle received " + gch);

				TreeModelFilter sender = GLib.Object.GetObject (arg0) as TreeModelFilter;
				args.Args = new object[3];
				args.Args[0] = arg1 == IntPtr.Zero ? null : (Gtk.TreePath) GLib.Opaque.GetOpaque (arg1, typeof (Gtk.TreePath), false);
				args.Args[1] = Gtk.TreeIter.New (arg2);
				int child_cnt = arg2 == IntPtr.Zero ? sender.IterNChildren () : sender.IterNChildren ((TreeIter)args.Args[1]);
				int[] new_order = new int [child_cnt];
				Marshal.Copy (arg3, new_order, 0, child_cnt);
				args.Args[2] = new_order;
				Gtk.RowsReorderedHandler handler = (Gtk.RowsReorderedHandler) sig.Handler;
				handler (sender, args);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void RowsReorderedVMDelegate (IntPtr tree_model, IntPtr path, IntPtr iter, IntPtr new_order);

		static RowsReorderedVMDelegate RowsReorderedVMCallback;

		static void rowsreordered_cb (IntPtr tree_model, IntPtr path_ptr, IntPtr iter_ptr, IntPtr new_order)
		{
			try {
				TreeModelFilter store = GLib.Object.GetObject (tree_model, false) as TreeModelFilter;
				TreePath path = GLib.Opaque.GetOpaque (path_ptr, typeof (TreePath), false) as TreePath;
				TreeIter iter = TreeIter.New (iter_ptr);
				int child_cnt = store.IterNChildren (iter);
				int[] child_order = new int [child_cnt];
				Marshal.Copy (new_order, child_order, 0, child_cnt);
				store.OnRowsReordered (path, iter, child_order);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideRowsReordered (GLib.GType gtype)
		{
			if (RowsReorderedVMCallback == null)
				RowsReorderedVMCallback = new RowsReorderedVMDelegate (rowsreordered_cb);
			OverrideVirtualMethod (gtype, "rows_reordered", RowsReorderedVMCallback);
		}

		[Obsolete ("Replaced by int[] new_order overload.")]
		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TreeModelFilter), ConnectionMethod="OverrideRowsReordered")]
		protected virtual void OnRowsReordered (Gtk.TreePath path, Gtk.TreeIter iter, out int new_order)
		{
			new_order = -1;
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.TreeModelFilter), ConnectionMethod="OverrideRowsReordered")]
		protected virtual void OnRowsReordered (Gtk.TreePath path, Gtk.TreeIter iter, int[] new_order)
		{
			int dummy;
			OnRowsReordered (path, iter, out dummy);
			GLib.Value ret = GLib.Value.Empty;
			unsafe {
				GLib.Value* inst_and_params = stackalloc GLib.Value [4];
				using (inst_and_params [0] = new GLib.Value (this)) {
					using (inst_and_params [1] = new GLib.Value (path)) {
						using (inst_and_params [2] = new GLib.Value (iter)) {

							int cnt = IterNChildren (iter);
							IntPtr new_order_ptr = Marshal.AllocHGlobal (sizeof (int) * cnt);
							Marshal.Copy (new_order, 0, new_order_ptr, cnt);
							using (inst_and_params [3] = new GLib.Value (new_order_ptr)) {
								g_signal_chain_from_overridden (inst_and_params, ref ret);
								Marshal.FreeHGlobal (new_order_ptr);
							}
						}
					}
				}
			}
		}

		[GLib.Signal("rows_reordered")]
		public event Gtk.RowsReorderedHandler RowsReordered {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "rows_reordered", new RowsReorderedSignalDelegate(RowsReorderedSignalCallback));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "rows_reordered", new RowsReorderedSignalDelegate(RowsReorderedSignalCallback));
				sig.RemoveDelegate (value);
			}
		}

#endregion
	}

	internal class TreeModelFilterAttribute : GLib.GTypeTypeAttribute {
		[DllImport ("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_tree_model_filter_get_type ();

		private static GLib.GType _gtype = new GLib.GType (gtk_tree_model_filter_get_type ());
		public static GLib.GType GType { get { return _gtype; } }
		public override GLib.GType Type { get { return _gtype; } }

	}
}
