// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gtk {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	[GLib.TypeInitializer (typeof (Gtk.Widget), "ClassInit")]
	[Widget]
	public class Widget : Gtk.Object, Atk.Implementor {

		public Widget(IntPtr raw) : base(raw) {}

		protected Widget() : base(IntPtr.Zero)
		{
			CreateNativeObject (Array.Empty<IntPtr> (), Array.Empty<GLib.Value> (), 0);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_get_name(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_set_name(IntPtr raw, IntPtr name);

		[GLib.Property ("name")]
		public string Name {
			get  {
				IntPtr raw_ret = gtk_widget_get_name(Handle);
				string ret = GLib.Marshaller.Utf8PtrToString (raw_ret);
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				IntPtr native_value = GLib.Marshaller.StringToPtrGStrdup (value);
				gtk_widget_set_name(Handle, native_value);
				GLib.Marshaller.Free (native_value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_get_parent(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_set_parent(IntPtr raw, IntPtr parent);

		[GLib.Property ("parent")]
		public Gtk.Widget Parent {
			get  {
				IntPtr raw_ret = gtk_widget_get_parent(Handle);
				Gtk.Widget ret = GLib.Object.GetObject(raw_ret) as Gtk.Widget;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_widget_set_parent(Handle, value == null ? IntPtr.Zero : value.Handle);
			}
		}

		[GLib.Property ("width-request")]
		public int WidthRequest {
			get {
				using (GLib.Value val = GetProperty ("width-request")) {
					int ret = (int) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("width-request", val);
				}
			}
		}

		[GLib.Property ("height-request")]
		public int HeightRequest {
			get {
				using (GLib.Value val = GetProperty ("height-request")) {
					int ret = (int) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("height-request", val);
				}
			}
		}

		[GLib.Property ("visible")]
		public bool Visible {
			get {
				using (GLib.Value val = GetProperty ("visible")) {
					bool ret = (bool) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("visible", val);
				}
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_set_sensitive(IntPtr raw, bool sensitive);

		[GLib.Property ("sensitive")]
		public bool Sensitive {
			get {
				using (GLib.Value val = GetProperty ("sensitive")) {
					bool ret = (bool) val;
					return ret;
				}
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_widget_set_sensitive(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_set_app_paintable(IntPtr raw, bool app_paintable);

		[GLib.Property ("app-paintable")]
		public bool AppPaintable {
			get {
				using (GLib.Value val = GetProperty ("app-paintable")) {
					bool ret = (bool) val;
					return ret;
				}
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_widget_set_app_paintable(Handle, value);
			}
		}

		[GLib.Property ("can-focus")]
		public bool CanFocus {
			get {
				using (GLib.Value val = GetProperty ("can-focus")) {
					bool ret = (bool) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("can-focus", val);
				}
			}
		}

		[GLib.Property ("has-focus")]
		public bool HasFocus {
			get {
				using (GLib.Value val = GetProperty ("has-focus")) {
					bool ret = (bool) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("has-focus", val);
				}
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_widget_is_focus(IntPtr raw);

		[GLib.Property ("is-focus")]
		public bool IsFocus {
			get  {
				bool raw_ret = gtk_widget_is_focus(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("is-focus", val);
				}
			}
		}

		[GLib.Property ("can-default")]
		public bool CanDefault {
			get {
				using (GLib.Value val = GetProperty ("can-default")) {
					bool ret = (bool) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("can-default", val);
				}
			}
		}

		[GLib.Property ("has-default")]
		public bool HasDefault {
			get {
				using (GLib.Value val = GetProperty ("has-default")) {
					bool ret = (bool) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("has-default", val);
				}
			}
		}

		[GLib.Property ("receives-default")]
		public bool ReceivesDefault {
			get {
				using (GLib.Value val = GetProperty ("receives-default")) {
					bool ret = (bool) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("receives-default", val);
				}
			}
		}

		[GLib.Property ("composite-child")]
		public bool CompositeChild {
			get {
				using (GLib.Value val = GetProperty ("composite-child")) {
					bool ret = (bool) val;
					return ret;
				}
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_get_style(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_set_style(IntPtr raw, IntPtr style);

		[GLib.Property ("style")]
		public Gtk.Style Style {
			get  {
				IntPtr raw_ret = gtk_widget_get_style(Handle);
				Gtk.Style ret = GLib.Object.GetObject(raw_ret) as Gtk.Style;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_widget_set_style(Handle, value == null ? IntPtr.Zero : value.Handle);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_widget_get_events(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_set_events(IntPtr raw, int events);

		[GLib.Property ("events")]
		public Gdk.EventMask Events {
			get  {
				int raw_ret = gtk_widget_get_events(Handle);
				Gdk.EventMask ret = (Gdk.EventMask) raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_widget_set_events(Handle, (int) value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_widget_get_extension_events(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_set_extension_events(IntPtr raw, int mode);

		[GLib.Property ("extension-events")]
		public Gdk.ExtensionMode ExtensionEvents {
			get  {
				int raw_ret = gtk_widget_get_extension_events(Handle);
				Gdk.ExtensionMode ret = (Gdk.ExtensionMode) raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_widget_set_extension_events(Handle, (int) value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_widget_get_no_show_all(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_set_no_show_all(IntPtr raw, bool no_show_all);

		[GLib.Property ("no-show-all")]
		public bool NoShowAll {
			get  {
				bool raw_ret = gtk_widget_get_no_show_all(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_widget_set_no_show_all(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_widget_get_has_tooltip(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_set_has_tooltip(IntPtr raw, bool has_tooltip);

		[GLib.Property ("has-tooltip")]
		public bool HasTooltip {
			get  {
				bool raw_ret = gtk_widget_get_has_tooltip(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_widget_set_has_tooltip(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_get_tooltip_text(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_set_tooltip_text(IntPtr raw, IntPtr text);

		[GLib.Property ("tooltip-text")]
		public string TooltipText {
			get  {
				IntPtr raw_ret = gtk_widget_get_tooltip_text(Handle);
				string ret = GLib.Marshaller.PtrToStringGFree(raw_ret);
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				IntPtr native_value = GLib.Marshaller.StringToPtrGStrdup (value);
				gtk_widget_set_tooltip_text(Handle, native_value);
				GLib.Marshaller.Free (native_value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_get_tooltip_markup(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_set_tooltip_markup(IntPtr raw, IntPtr markup);

		[GLib.Property ("tooltip-markup")]
		public string TooltipMarkup {
			get  {
				IntPtr raw_ret = gtk_widget_get_tooltip_markup(Handle);
				string ret = GLib.Marshaller.PtrToStringGFree(raw_ret);
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				IntPtr native_value = GLib.Marshaller.StringToPtrGStrdup (value);
				gtk_widget_set_tooltip_markup(Handle, native_value);
				GLib.Marshaller.Free (native_value);
			}
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		extern static uint gtksharp_gtk_widget_get_requisition_offset ();

		static uint requisition_offset = gtksharp_gtk_widget_get_requisition_offset ();
		public Gtk.Requisition Requisition {
			get {
				unsafe {
					Gtk.Requisition* raw_ptr = (Gtk.Requisition*)(((byte*)Handle) + requisition_offset);
					return *raw_ptr;
				}
			}
			set {
				unsafe {
					Gtk.Requisition* raw_ptr = (Gtk.Requisition*)(((byte*)Handle) + requisition_offset);
					*raw_ptr = value;
				}
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ShownVMDelegate (IntPtr widget);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_show (IntPtr gtype, ShownVMDelegate cb);

		static ShownVMDelegate ShownVMCallback;

		static void shown_cb (IntPtr widget)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				widget_managed.OnShown ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideShown (GLib.GType gtype)
		{
			if (ShownVMCallback == null)
				ShownVMCallback = new ShownVMDelegate (shown_cb);
			gtksharp_widget_override_show (gtype.Val, ShownVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_base_show (IntPtr widget);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideShown")]
		protected virtual void OnShown ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_widget_base_show (Handle);
		}

		[GLib.Signal("show")]
		public event System.EventHandler Shown {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "show");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "show");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void HiddenVMDelegate (IntPtr widget);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_hide (IntPtr gtype, HiddenVMDelegate cb);

		static HiddenVMDelegate HiddenVMCallback;

		static void hidden_cb (IntPtr widget)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				widget_managed.OnHidden ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideHidden (GLib.GType gtype)
		{
			if (HiddenVMCallback == null)
				HiddenVMCallback = new HiddenVMDelegate (hidden_cb);
			gtksharp_widget_override_hide (gtype.Val, HiddenVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_base_hide (IntPtr widget);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideHidden")]
		protected virtual void OnHidden ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_widget_base_hide (Handle);
		}

		[GLib.Signal("hide")]
		public event System.EventHandler Hidden {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "hide");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "hide");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void MappedVMDelegate (IntPtr widget);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_map (IntPtr gtype, MappedVMDelegate cb);

		static MappedVMDelegate MappedVMCallback;

		static void mapped_cb (IntPtr widget)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				widget_managed.OnMapped ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideMapped (GLib.GType gtype)
		{
			if (MappedVMCallback == null)
				MappedVMCallback = new MappedVMDelegate (mapped_cb);
			gtksharp_widget_override_map (gtype.Val, MappedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_base_map (IntPtr widget);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideMapped")]
		protected virtual void OnMapped ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_widget_base_map (Handle);
		}

		[GLib.Signal("map")]
		public event System.EventHandler Mapped {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "map");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "map");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void UnmappedVMDelegate (IntPtr widget);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_unmap (IntPtr gtype, UnmappedVMDelegate cb);

		static UnmappedVMDelegate UnmappedVMCallback;

		static void unmapped_cb (IntPtr widget)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				widget_managed.OnUnmapped ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideUnmapped (GLib.GType gtype)
		{
			if (UnmappedVMCallback == null)
				UnmappedVMCallback = new UnmappedVMDelegate (unmapped_cb);
			gtksharp_widget_override_unmap (gtype.Val, UnmappedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_base_unmap (IntPtr widget);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideUnmapped")]
		protected virtual void OnUnmapped ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_widget_base_unmap (Handle);
		}

		[GLib.Signal("unmap")]
		public event System.EventHandler Unmapped {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "unmap");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "unmap");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void RealizedVMDelegate (IntPtr widget);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_realize (IntPtr gtype, RealizedVMDelegate cb);

		static RealizedVMDelegate RealizedVMCallback;

		static void realized_cb (IntPtr widget)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				widget_managed.OnRealized ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideRealized (GLib.GType gtype)
		{
			if (RealizedVMCallback == null)
				RealizedVMCallback = new RealizedVMDelegate (realized_cb);
			gtksharp_widget_override_realize (gtype.Val, RealizedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_base_realize (IntPtr widget);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideRealized")]
		protected virtual void OnRealized ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_widget_base_realize (Handle);
		}

		[GLib.Signal("realize")]
		public event System.EventHandler Realized {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "realize");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "realize");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void UnrealizedVMDelegate (IntPtr widget);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_unrealize (IntPtr gtype, UnrealizedVMDelegate cb);

		static UnrealizedVMDelegate UnrealizedVMCallback;

		static void unrealized_cb (IntPtr widget)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				widget_managed.OnUnrealized ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideUnrealized (GLib.GType gtype)
		{
			if (UnrealizedVMCallback == null)
				UnrealizedVMCallback = new UnrealizedVMDelegate (unrealized_cb);
			gtksharp_widget_override_unrealize (gtype.Val, UnrealizedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_base_unrealize (IntPtr widget);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideUnrealized")]
		protected virtual void OnUnrealized ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_widget_base_unrealize (Handle);
		}

		[GLib.Signal("unrealize")]
		public event System.EventHandler Unrealized {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "unrealize");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "unrealize");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void SizeRequestedVMDelegate (IntPtr widget, IntPtr requisition);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_size_request (IntPtr gtype, SizeRequestedVMDelegate cb);

		static SizeRequestedVMDelegate SizeRequestedVMCallback;

		static void sizerequested_cb (IntPtr widget, IntPtr requisition)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				Gtk.Requisition myrequisition = Gtk.Requisition.New (requisition);
				widget_managed.OnSizeRequested (ref myrequisition);
				unsafe { if (requisition != IntPtr.Zero) *(Gtk.Requisition*)requisition = myrequisition; }
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideSizeRequested (GLib.GType gtype)
		{
			if (SizeRequestedVMCallback == null)
				SizeRequestedVMCallback = new SizeRequestedVMDelegate (sizerequested_cb);
			gtksharp_widget_override_size_request (gtype.Val, SizeRequestedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_base_size_request (IntPtr widget, ref Gtk.Requisition requisition);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideSizeRequested")]
		protected virtual void OnSizeRequested (ref Gtk.Requisition requisition)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_widget_base_size_request (Handle, ref requisition);
		}

		[GLib.Signal("size_request")]
		public event Gtk.SizeRequestedHandler SizeRequested {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "size_request", typeof (Gtk.SizeRequestedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "size_request", typeof (Gtk.SizeRequestedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void SizeAllocatedVMDelegate (IntPtr widget, IntPtr allocation);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_size_allocate (IntPtr gtype, SizeAllocatedVMDelegate cb);

		static SizeAllocatedVMDelegate SizeAllocatedVMCallback;

		static void sizeallocated_cb (IntPtr widget, IntPtr allocation)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				widget_managed.OnSizeAllocated (Gdk.Rectangle.New (allocation));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideSizeAllocated (GLib.GType gtype)
		{
			if (SizeAllocatedVMCallback == null)
				SizeAllocatedVMCallback = new SizeAllocatedVMDelegate (sizeallocated_cb);
			gtksharp_widget_override_size_allocate (gtype.Val, SizeAllocatedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_base_size_allocate (IntPtr widget, ref Gdk.Rectangle allocation);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideSizeAllocated")]
		protected virtual void OnSizeAllocated (Gdk.Rectangle allocation)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_widget_base_size_allocate (Handle, ref allocation);
		}

		[GLib.Signal("size_allocate")]
		public event Gtk.SizeAllocatedHandler SizeAllocated {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "size_allocate", typeof (Gtk.SizeAllocatedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "size_allocate", typeof (Gtk.SizeAllocatedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void StateChangedVMDelegate (IntPtr widget, int previous_state);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_state_changed (IntPtr gtype, StateChangedVMDelegate cb);

		static StateChangedVMDelegate StateChangedVMCallback;

		static void statechanged_cb (IntPtr widget, int previous_state)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				widget_managed.OnStateChanged ((Gtk.StateType) previous_state);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideStateChanged (GLib.GType gtype)
		{
			if (StateChangedVMCallback == null)
				StateChangedVMCallback = new StateChangedVMDelegate (statechanged_cb);
			gtksharp_widget_override_state_changed (gtype.Val, StateChangedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_base_state_changed (IntPtr widget, int previous_state);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideStateChanged")]
		protected virtual void OnStateChanged (Gtk.StateType previous_state)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_widget_base_state_changed (Handle, (int) previous_state);
		}

		[GLib.Signal("state_changed")]
		public event Gtk.StateChangedHandler StateChanged {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "state_changed", typeof (Gtk.StateChangedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "state_changed", typeof (Gtk.StateChangedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ParentSetVMDelegate (IntPtr widget, IntPtr previous_parent);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_parent_set (IntPtr gtype, ParentSetVMDelegate cb);

		static ParentSetVMDelegate ParentSetVMCallback;

		static void parentset_cb (IntPtr widget, IntPtr previous_parent)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				widget_managed.OnParentSet (GLib.Object.GetObject(previous_parent) as Gtk.Widget);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideParentSet (GLib.GType gtype)
		{
			if (ParentSetVMCallback == null)
				ParentSetVMCallback = new ParentSetVMDelegate (parentset_cb);
			gtksharp_widget_override_parent_set (gtype.Val, ParentSetVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_base_parent_set (IntPtr widget, IntPtr previous_parent);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideParentSet")]
		protected virtual void OnParentSet (Gtk.Widget previous_parent)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_widget_base_parent_set (Handle, previous_parent == null ? IntPtr.Zero : previous_parent.Handle);
		}

		[GLib.Signal("parent_set")]
		public event Gtk.ParentSetHandler ParentSet {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "parent_set", typeof (Gtk.ParentSetArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "parent_set", typeof (Gtk.ParentSetArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void HierarchyChangedVMDelegate (IntPtr widget, IntPtr previous_toplevel);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_hierarchy_changed (IntPtr gtype, HierarchyChangedVMDelegate cb);

		static HierarchyChangedVMDelegate HierarchyChangedVMCallback;

		static void hierarchychanged_cb (IntPtr widget, IntPtr previous_toplevel)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				widget_managed.OnHierarchyChanged (GLib.Object.GetObject(previous_toplevel) as Gtk.Widget);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideHierarchyChanged (GLib.GType gtype)
		{
			if (HierarchyChangedVMCallback == null)
				HierarchyChangedVMCallback = new HierarchyChangedVMDelegate (hierarchychanged_cb);
			gtksharp_widget_override_hierarchy_changed (gtype.Val, HierarchyChangedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_base_hierarchy_changed (IntPtr widget, IntPtr previous_toplevel);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideHierarchyChanged")]
		protected virtual void OnHierarchyChanged (Gtk.Widget previous_toplevel)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_widget_base_hierarchy_changed (Handle, previous_toplevel == null ? IntPtr.Zero : previous_toplevel.Handle);
		}

		[GLib.Signal("hierarchy_changed")]
		public event Gtk.HierarchyChangedHandler HierarchyChanged {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "hierarchy_changed", typeof (Gtk.HierarchyChangedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "hierarchy_changed", typeof (Gtk.HierarchyChangedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void StyleSetVMDelegate (IntPtr widget, IntPtr previous_style);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_style_set (IntPtr gtype, StyleSetVMDelegate cb);

		static StyleSetVMDelegate StyleSetVMCallback;

		static void styleset_cb (IntPtr widget, IntPtr previous_style)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				widget_managed.OnStyleSet (GLib.Object.GetObject(previous_style) as Gtk.Style);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideStyleSet (GLib.GType gtype)
		{
			if (StyleSetVMCallback == null)
				StyleSetVMCallback = new StyleSetVMDelegate (styleset_cb);
			gtksharp_widget_override_style_set (gtype.Val, StyleSetVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_base_style_set (IntPtr widget, IntPtr previous_style);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideStyleSet")]
		protected virtual void OnStyleSet (Gtk.Style previous_style)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_widget_base_style_set (Handle, previous_style == null ? IntPtr.Zero : previous_style.Handle);
		}

		[GLib.Signal("style_set")]
		public event Gtk.StyleSetHandler StyleSet {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "style_set", typeof (Gtk.StyleSetArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "style_set", typeof (Gtk.StyleSetArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DirectionChangedVMDelegate (IntPtr widget, int previous_direction);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_direction_changed (IntPtr gtype, DirectionChangedVMDelegate cb);

		static DirectionChangedVMDelegate DirectionChangedVMCallback;

		static void directionchanged_cb (IntPtr widget, int previous_direction)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				widget_managed.OnDirectionChanged ((Gtk.TextDirection) previous_direction);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideDirectionChanged (GLib.GType gtype)
		{
			if (DirectionChangedVMCallback == null)
				DirectionChangedVMCallback = new DirectionChangedVMDelegate (directionchanged_cb);
			gtksharp_widget_override_direction_changed (gtype.Val, DirectionChangedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_base_direction_changed (IntPtr widget, int previous_direction);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideDirectionChanged")]
		protected virtual void OnDirectionChanged (Gtk.TextDirection previous_direction)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_widget_base_direction_changed (Handle, (int) previous_direction);
		}

		[GLib.Signal("direction_changed")]
		public event Gtk.DirectionChangedHandler DirectionChanged {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "direction_changed", typeof (Gtk.DirectionChangedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "direction_changed", typeof (Gtk.DirectionChangedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void GrabNotifyVMDelegate (IntPtr widget, bool was_grabbed);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_grab_notify (IntPtr gtype, GrabNotifyVMDelegate cb);

		static GrabNotifyVMDelegate GrabNotifyVMCallback;

		static void grabnotify_cb (IntPtr widget, bool was_grabbed)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				widget_managed.OnGrabNotify (was_grabbed);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideGrabNotify (GLib.GType gtype)
		{
			if (GrabNotifyVMCallback == null)
				GrabNotifyVMCallback = new GrabNotifyVMDelegate (grabnotify_cb);
			gtksharp_widget_override_grab_notify (gtype.Val, GrabNotifyVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_base_grab_notify (IntPtr widget, bool was_grabbed);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideGrabNotify")]
		protected virtual void OnGrabNotify (bool was_grabbed)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_widget_base_grab_notify (Handle, was_grabbed);
		}

		[GLib.Signal("grab_notify")]
		public event Gtk.GrabNotifyHandler GrabNotify {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "grab_notify", typeof (Gtk.GrabNotifyArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "grab_notify", typeof (Gtk.GrabNotifyArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ChildNotifiedVMDelegate (IntPtr widget, IntPtr pspec);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_child_notify (IntPtr gtype, ChildNotifiedVMDelegate cb);

		static ChildNotifiedVMDelegate ChildNotifiedVMCallback;

		static void childnotified_cb (IntPtr widget, IntPtr pspec)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				widget_managed.OnChildNotified (pspec);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideChildNotified (GLib.GType gtype)
		{
			if (ChildNotifiedVMCallback == null)
				ChildNotifiedVMCallback = new ChildNotifiedVMDelegate (childnotified_cb);
			gtksharp_widget_override_child_notify (gtype.Val, ChildNotifiedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_base_child_notify (IntPtr widget, IntPtr pspec);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideChildNotified")]
		protected virtual void OnChildNotified (IntPtr pspec)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_widget_base_child_notify (Handle, pspec);
		}

		[GLib.Signal("child_notify")]
		public event Gtk.ChildNotifiedHandler ChildNotified {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "child_notify", typeof (Gtk.ChildNotifiedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "child_notify", typeof (Gtk.ChildNotifiedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool MnemonicActivatedVMDelegate (IntPtr widget, bool group_cycling);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_mnemonic_activate (IntPtr gtype, MnemonicActivatedVMDelegate cb);

		static MnemonicActivatedVMDelegate MnemonicActivatedVMCallback;

		static bool mnemonicactivated_cb (IntPtr widget, bool group_cycling)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnMnemonicActivated (group_cycling);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideMnemonicActivated (GLib.GType gtype)
		{
			if (MnemonicActivatedVMCallback == null)
				MnemonicActivatedVMCallback = new MnemonicActivatedVMDelegate (mnemonicactivated_cb);
			gtksharp_widget_override_mnemonic_activate (gtype.Val, MnemonicActivatedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_mnemonic_activate (IntPtr widget, bool group_cycling);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideMnemonicActivated")]
		protected virtual bool OnMnemonicActivated (bool group_cycling)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_mnemonic_activate (Handle, group_cycling);
			return __ret;
		}

		[GLib.Signal("mnemonic_activate")]
		public event Gtk.MnemonicActivatedHandler MnemonicActivated {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "mnemonic_activate", typeof (Gtk.MnemonicActivatedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "mnemonic_activate", typeof (Gtk.MnemonicActivatedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void FocusGrabbedVMDelegate (IntPtr widget);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_grab_focus (IntPtr gtype, FocusGrabbedVMDelegate cb);

		static FocusGrabbedVMDelegate FocusGrabbedVMCallback;

		static void focusgrabbed_cb (IntPtr widget)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				widget_managed.OnFocusGrabbed ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideFocusGrabbed (GLib.GType gtype)
		{
			if (FocusGrabbedVMCallback == null)
				FocusGrabbedVMCallback = new FocusGrabbedVMDelegate (focusgrabbed_cb);
			gtksharp_widget_override_grab_focus (gtype.Val, FocusGrabbedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_base_grab_focus (IntPtr widget);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideFocusGrabbed")]
		protected virtual void OnFocusGrabbed ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_widget_base_grab_focus (Handle);
		}

		[GLib.Signal("grab_focus")]
		public event System.EventHandler FocusGrabbed {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "grab_focus");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "grab_focus");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool FocusedVMDelegate (IntPtr widget, int direction);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_focus (IntPtr gtype, FocusedVMDelegate cb);

		static FocusedVMDelegate FocusedVMCallback;

		static bool focused_cb (IntPtr widget, int direction)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnFocused ((Gtk.DirectionType) direction);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideFocused (GLib.GType gtype)
		{
			if (FocusedVMCallback == null)
				FocusedVMCallback = new FocusedVMDelegate (focused_cb);
			gtksharp_widget_override_focus (gtype.Val, FocusedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_focus (IntPtr widget, int direction);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideFocused")]
		protected virtual bool OnFocused (Gtk.DirectionType direction)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_focus (Handle, (int) direction);
			return __ret;
		}

		[GLib.Signal("focus")]
		public event Gtk.FocusedHandler Focused {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "focus", typeof (Gtk.FocusedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "focus", typeof (Gtk.FocusedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void FocusMovedVMDelegate (IntPtr inst, int p0);

		static FocusMovedVMDelegate FocusMovedVMCallback;

		static void focusmoved_cb (IntPtr inst, int p0)
		{
			try {
				Widget inst_managed = GLib.Object.GetObject (inst, false) as Widget;
				inst_managed.OnFocusMoved ((Gtk.DirectionType) p0);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideFocusMoved (GLib.GType gtype)
		{
			if (FocusMovedVMCallback == null)
				FocusMovedVMCallback = new FocusMovedVMDelegate (focusmoved_cb);
			OverrideVirtualMethod (gtype, "move_focus", FocusMovedVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideFocusMoved")]
		protected virtual void OnFocusMoved (Gtk.DirectionType p0)
		{
			GLib.Value ret = GLib.Value.Empty;
			unsafe {
				GLib.Value* inst_and_params = stackalloc GLib.Value [2];
				using (inst_and_params[0] = new GLib.Value (this)) {
					using (inst_and_params [1] = new GLib.Value (p0)) {
						g_signal_chain_from_overridden (inst_and_params, ref ret);
					}
				}
			}
		}

		[GLib.Signal("move_focus")]
		public event Gtk.FocusMovedHandler FocusMoved {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "move_focus", typeof (Gtk.FocusMovedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "move_focus", typeof (Gtk.FocusMovedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool WidgetEventVMDelegate (IntPtr widget, IntPtr evnt);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_event (IntPtr gtype, WidgetEventVMDelegate cb);

		static WidgetEventVMDelegate WidgetEventVMCallback;

		static bool widgetevent_cb (IntPtr widget, IntPtr evnt)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnWidgetEvent (Gdk.Event.GetEvent (evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideWidgetEvent (GLib.GType gtype)
		{
			if (WidgetEventVMCallback == null)
				WidgetEventVMCallback = new WidgetEventVMDelegate (widgetevent_cb);
			gtksharp_widget_override_event (gtype.Val, WidgetEventVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_event (IntPtr widget, IntPtr evnt);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideWidgetEvent")]
		protected virtual bool OnWidgetEvent (Gdk.Event evnt)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_event (Handle, evnt == null ? IntPtr.Zero : evnt.Handle);
			return __ret;
		}

		[GLib.Signal("event")]
		public event Gtk.WidgetEventHandler WidgetEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "event", typeof (Gtk.WidgetEventArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "event", typeof (Gtk.WidgetEventArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void WidgetEventAfterVMDelegate (IntPtr widget, IntPtr evnt);

		static WidgetEventAfterVMDelegate WidgetEventAfterVMCallback;

		static void widgeteventafter_cb (IntPtr widget, IntPtr evnt)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				widget_managed.OnWidgetEventAfter (Gdk.Event.GetEvent (evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideWidgetEventAfter (GLib.GType gtype)
		{
			if (WidgetEventAfterVMCallback == null)
				WidgetEventAfterVMCallback = new WidgetEventAfterVMDelegate (widgeteventafter_cb);
			OverrideVirtualMethod (gtype, "event_after", WidgetEventAfterVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideWidgetEventAfter")]
		protected virtual void OnWidgetEventAfter (Gdk.Event evnt)
		{
			GLib.Value ret = GLib.Value.Empty;
			unsafe {
				GLib.Value* inst_and_params = stackalloc GLib.Value [2];
				using (inst_and_params[0] = new GLib.Value (this)) {
					using (inst_and_params [1] = new GLib.Value (evnt)) {
						g_signal_chain_from_overridden (inst_and_params, ref ret);
					}
				}
			}
		}

		[GLib.Signal("event_after")]
		public event Gtk.WidgetEventAfterHandler WidgetEventAfter {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "event_after", typeof (Gtk.WidgetEventAfterArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "event_after", typeof (Gtk.WidgetEventAfterArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool ButtonPressEventVMDelegate (IntPtr widget, IntPtr evnt);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_button_press_event (IntPtr gtype, ButtonPressEventVMDelegate cb);

		static ButtonPressEventVMDelegate ButtonPressEventVMCallback;

		static bool buttonpressevent_cb (IntPtr widget, IntPtr evnt)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnButtonPressEvent (new Gdk.EventButton(evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideButtonPressEvent (GLib.GType gtype)
		{
			if (ButtonPressEventVMCallback == null)
				ButtonPressEventVMCallback = new ButtonPressEventVMDelegate (buttonpressevent_cb);
			gtksharp_widget_override_button_press_event (gtype.Val, ButtonPressEventVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_button_press_event (IntPtr widget, IntPtr evnt);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideButtonPressEvent")]
		protected virtual bool OnButtonPressEvent (Gdk.EventButton evnt)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_button_press_event (Handle, evnt == null ? IntPtr.Zero : evnt.Handle);
			return __ret;
		}

		[GLib.Signal("button_press_event")]
		public event Gtk.ButtonPressEventHandler ButtonPressEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "button_press_event", typeof (Gtk.ButtonPressEventArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "button_press_event", typeof (Gtk.ButtonPressEventArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool ButtonReleaseEventVMDelegate (IntPtr widget, IntPtr evnt);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_button_release_event (IntPtr gtype, ButtonReleaseEventVMDelegate cb);

		static ButtonReleaseEventVMDelegate ButtonReleaseEventVMCallback;

		static bool buttonreleaseevent_cb (IntPtr widget, IntPtr evnt)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnButtonReleaseEvent (new Gdk.EventButton(evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideButtonReleaseEvent (GLib.GType gtype)
		{
			if (ButtonReleaseEventVMCallback == null)
				ButtonReleaseEventVMCallback = new ButtonReleaseEventVMDelegate (buttonreleaseevent_cb);
			gtksharp_widget_override_button_release_event (gtype.Val, ButtonReleaseEventVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_button_release_event (IntPtr widget, IntPtr evnt);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideButtonReleaseEvent")]
		protected virtual bool OnButtonReleaseEvent (Gdk.EventButton evnt)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_button_release_event (Handle, evnt == null ? IntPtr.Zero : evnt.Handle);
			return __ret;
		}

		[GLib.Signal("button_release_event")]
		public event Gtk.ButtonReleaseEventHandler ButtonReleaseEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "button_release_event", typeof (Gtk.ButtonReleaseEventArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "button_release_event", typeof (Gtk.ButtonReleaseEventArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool ScrollEventVMDelegate (IntPtr widget, IntPtr evnt);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_scroll_event (IntPtr gtype, ScrollEventVMDelegate cb);

		static ScrollEventVMDelegate ScrollEventVMCallback;

		static bool scrollevent_cb (IntPtr widget, IntPtr evnt)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnScrollEvent (new Gdk.EventScroll(evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideScrollEvent (GLib.GType gtype)
		{
			if (ScrollEventVMCallback == null)
				ScrollEventVMCallback = new ScrollEventVMDelegate (scrollevent_cb);
			gtksharp_widget_override_scroll_event (gtype.Val, ScrollEventVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_scroll_event (IntPtr widget, IntPtr evnt);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideScrollEvent")]
		protected virtual bool OnScrollEvent (Gdk.EventScroll evnt)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_scroll_event (Handle, evnt == null ? IntPtr.Zero : evnt.Handle);
			return __ret;
		}

		[GLib.Signal("scroll_event")]
		public event Gtk.ScrollEventHandler ScrollEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "scroll_event", typeof (Gtk.ScrollEventArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "scroll_event", typeof (Gtk.ScrollEventArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool MotionNotifyEventVMDelegate (IntPtr widget, IntPtr evnt);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_motion_notify_event (IntPtr gtype, MotionNotifyEventVMDelegate cb);

		static MotionNotifyEventVMDelegate MotionNotifyEventVMCallback;

		static bool motionnotifyevent_cb (IntPtr widget, IntPtr evnt)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnMotionNotifyEvent (new Gdk.EventMotion(evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideMotionNotifyEvent (GLib.GType gtype)
		{
			if (MotionNotifyEventVMCallback == null)
				MotionNotifyEventVMCallback = new MotionNotifyEventVMDelegate (motionnotifyevent_cb);
			gtksharp_widget_override_motion_notify_event (gtype.Val, MotionNotifyEventVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_motion_notify_event (IntPtr widget, IntPtr evnt);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideMotionNotifyEvent")]
		protected virtual bool OnMotionNotifyEvent (Gdk.EventMotion evnt)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_motion_notify_event (Handle, evnt == null ? IntPtr.Zero : evnt.Handle);
			return __ret;
		}

		[GLib.Signal("motion_notify_event")]
		public event Gtk.MotionNotifyEventHandler MotionNotifyEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "motion_notify_event", typeof (Gtk.MotionNotifyEventArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "motion_notify_event", typeof (Gtk.MotionNotifyEventArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void CompositedChangedVMDelegate (IntPtr widget);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_composited_changed (IntPtr gtype, CompositedChangedVMDelegate cb);

		static CompositedChangedVMDelegate CompositedChangedVMCallback;

		static void compositedchanged_cb (IntPtr widget)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				widget_managed.OnCompositedChanged ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideCompositedChanged (GLib.GType gtype)
		{
			if (CompositedChangedVMCallback == null)
				CompositedChangedVMCallback = new CompositedChangedVMDelegate (compositedchanged_cb);
			gtksharp_widget_override_composited_changed (gtype.Val, CompositedChangedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_base_composited_changed (IntPtr widget);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideCompositedChanged")]
		protected virtual void OnCompositedChanged ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_widget_base_composited_changed (Handle);
		}

		[GLib.Signal("composited_changed")]
		public event System.EventHandler CompositedChanged {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "composited_changed");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "composited_changed");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool KeynavFailVMDelegate (IntPtr inst, int p0);

		static KeynavFailVMDelegate KeynavFailVMCallback;

		static bool keynavfail_cb (IntPtr inst, int p0)
		{
			try {
				Widget inst_managed = GLib.Object.GetObject (inst, false) as Widget;
				return inst_managed.OnKeynavFail ((Gtk.DirectionType) p0);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideKeynavFail (GLib.GType gtype)
		{
			if (KeynavFailVMCallback == null)
				KeynavFailVMCallback = new KeynavFailVMDelegate (keynavfail_cb);
			OverrideVirtualMethod (gtype, "keynav-failed", KeynavFailVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideKeynavFail")]
		protected virtual bool OnKeynavFail (Gtk.DirectionType p0)
		{
			GLib.Value ret = new GLib		.Value (GLib.GType.Boolean);
			unsafe {
				GLib.Value* inst_and_params = stackalloc GLib.Value [2];
				using (inst_and_params[0] = new GLib.Value (this)) {
					using (inst_and_params [1] = new GLib.Value (p0)) {
						g_signal_chain_from_overridden (inst_and_params, ref ret);
					}
				}
			}
			bool result = (bool) ret;
			ret.Dispose ();
			return result;
		}

		[GLib.Signal("keynav-failed")]
		public event Gtk.KeynavFailHandler KeynavFail {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "keynav-failed", typeof (Gtk.KeynavFailArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "keynav-failed", typeof (Gtk.KeynavFailArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool DeleteEventVMDelegate (IntPtr widget, IntPtr evnt);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_delete_event (IntPtr gtype, DeleteEventVMDelegate cb);

		static DeleteEventVMDelegate DeleteEventVMCallback;

		static bool deleteevent_cb (IntPtr widget, IntPtr evnt)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnDeleteEvent (Gdk.Event.GetEvent (evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideDeleteEvent (GLib.GType gtype)
		{
			if (DeleteEventVMCallback == null)
				DeleteEventVMCallback = new DeleteEventVMDelegate (deleteevent_cb);
			gtksharp_widget_override_delete_event (gtype.Val, DeleteEventVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_delete_event (IntPtr widget, IntPtr evnt);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideDeleteEvent")]
		protected virtual bool OnDeleteEvent (Gdk.Event evnt)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_delete_event (Handle, evnt.Handle);
			return __ret;
		}

		[GLib.Signal("delete_event")]
		public event Gtk.DeleteEventHandler DeleteEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "delete_event", typeof (Gtk.DeleteEventArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "delete_event", typeof (Gtk.DeleteEventArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool DestroyEventVMDelegate (IntPtr widget, IntPtr evnt);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_destroy_event (IntPtr gtype, DestroyEventVMDelegate cb);

		static DestroyEventVMDelegate DestroyEventVMCallback;

		static bool destroyevent_cb (IntPtr widget, IntPtr evnt)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnDestroyEvent (Gdk.Event.GetEvent (evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideDestroyEvent (GLib.GType gtype)
		{
			if (DestroyEventVMCallback == null)
				DestroyEventVMCallback = new DestroyEventVMDelegate (destroyevent_cb);
			gtksharp_widget_override_destroy_event (gtype.Val, DestroyEventVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_destroy_event (IntPtr widget, IntPtr evnt);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideDestroyEvent")]
		protected virtual bool OnDestroyEvent (Gdk.Event evnt)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_destroy_event (Handle, evnt.Handle);
			return __ret;
		}

		[GLib.Signal("destroy_event")]
		public event Gtk.DestroyEventHandler DestroyEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "destroy_event", typeof (Gtk.DestroyEventArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "destroy_event", typeof (Gtk.DestroyEventArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool ExposeEventVMDelegate (IntPtr widget, IntPtr evnt);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_expose_event (IntPtr gtype, ExposeEventVMDelegate cb);

		static ExposeEventVMDelegate ExposeEventVMCallback;

		static bool exposeevent_cb (IntPtr widget, IntPtr evnt)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnExposeEvent (new Gdk.EventExpose(evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideExposeEvent (GLib.GType gtype)
		{
			if (ExposeEventVMCallback == null)
				ExposeEventVMCallback = new ExposeEventVMDelegate (exposeevent_cb);
			gtksharp_widget_override_expose_event (gtype.Val, ExposeEventVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_expose_event (IntPtr widget, IntPtr evnt);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideExposeEvent")]
		protected virtual bool OnExposeEvent (Gdk.EventExpose evnt)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_expose_event (Handle, evnt == null ? IntPtr.Zero : evnt.Handle);
			return __ret;
		}

		[GLib.Signal("expose_event")]
		public event Gtk.ExposeEventHandler ExposeEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "expose_event", typeof (Gtk.ExposeEventArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "expose_event", typeof (Gtk.ExposeEventArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool KeyPressEventVMDelegate (IntPtr widget, IntPtr evnt);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_key_press_event (IntPtr gtype, KeyPressEventVMDelegate cb);

		static KeyPressEventVMDelegate KeyPressEventVMCallback;

		static bool keypressevent_cb (IntPtr widget, IntPtr evnt)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnKeyPressEvent (new Gdk.EventKey(evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideKeyPressEvent (GLib.GType gtype)
		{
			if (KeyPressEventVMCallback == null)
				KeyPressEventVMCallback = new KeyPressEventVMDelegate (keypressevent_cb);
			gtksharp_widget_override_key_press_event (gtype.Val, KeyPressEventVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_key_press_event (IntPtr widget, IntPtr evnt);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideKeyPressEvent")]
		protected virtual bool OnKeyPressEvent (Gdk.EventKey evnt)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_key_press_event (Handle, evnt == null ? IntPtr.Zero : evnt.Handle);
			return __ret;
		}

		[GLib.Signal("key_press_event")]
		public event Gtk.KeyPressEventHandler KeyPressEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "key_press_event", typeof (Gtk.KeyPressEventArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "key_press_event", typeof (Gtk.KeyPressEventArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool KeyReleaseEventVMDelegate (IntPtr widget, IntPtr evnt);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_key_release_event (IntPtr gtype, KeyReleaseEventVMDelegate cb);

		static KeyReleaseEventVMDelegate KeyReleaseEventVMCallback;

		static bool keyreleaseevent_cb (IntPtr widget, IntPtr evnt)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnKeyReleaseEvent (new Gdk.EventKey(evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideKeyReleaseEvent (GLib.GType gtype)
		{
			if (KeyReleaseEventVMCallback == null)
				KeyReleaseEventVMCallback = new KeyReleaseEventVMDelegate (keyreleaseevent_cb);
			gtksharp_widget_override_key_release_event (gtype.Val, KeyReleaseEventVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_key_release_event (IntPtr widget, IntPtr evnt);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideKeyReleaseEvent")]
		protected virtual bool OnKeyReleaseEvent (Gdk.EventKey evnt)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_key_release_event (Handle, evnt == null ? IntPtr.Zero : evnt.Handle);
			return __ret;
		}

		[GLib.Signal("key_release_event")]
		public event Gtk.KeyReleaseEventHandler KeyReleaseEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "key_release_event", typeof (Gtk.KeyReleaseEventArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "key_release_event", typeof (Gtk.KeyReleaseEventArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool EnterNotifyEventVMDelegate (IntPtr widget, IntPtr evnt);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_enter_notify_event (IntPtr gtype, EnterNotifyEventVMDelegate cb);

		static EnterNotifyEventVMDelegate EnterNotifyEventVMCallback;

		static bool enternotifyevent_cb (IntPtr widget, IntPtr evnt)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnEnterNotifyEvent (new Gdk.EventCrossing(evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideEnterNotifyEvent (GLib.GType gtype)
		{
			if (EnterNotifyEventVMCallback == null)
				EnterNotifyEventVMCallback = new EnterNotifyEventVMDelegate (enternotifyevent_cb);
			gtksharp_widget_override_enter_notify_event (gtype.Val, EnterNotifyEventVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_enter_notify_event (IntPtr widget, IntPtr evnt);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideEnterNotifyEvent")]
		protected virtual bool OnEnterNotifyEvent (Gdk.EventCrossing evnt)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_enter_notify_event (Handle, evnt == null ? IntPtr.Zero : evnt.Handle);
			return __ret;
		}

		[GLib.Signal("enter_notify_event")]
		public event Gtk.EnterNotifyEventHandler EnterNotifyEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "enter_notify_event", typeof (Gtk.EnterNotifyEventArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "enter_notify_event", typeof (Gtk.EnterNotifyEventArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool LeaveNotifyEventVMDelegate (IntPtr widget, IntPtr evnt);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_leave_notify_event (IntPtr gtype, LeaveNotifyEventVMDelegate cb);

		static LeaveNotifyEventVMDelegate LeaveNotifyEventVMCallback;

		static bool leavenotifyevent_cb (IntPtr widget, IntPtr evnt)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnLeaveNotifyEvent (new Gdk.EventCrossing(evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideLeaveNotifyEvent (GLib.GType gtype)
		{
			if (LeaveNotifyEventVMCallback == null)
				LeaveNotifyEventVMCallback = new LeaveNotifyEventVMDelegate (leavenotifyevent_cb);
			gtksharp_widget_override_leave_notify_event (gtype.Val, LeaveNotifyEventVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_leave_notify_event (IntPtr widget, IntPtr evnt);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideLeaveNotifyEvent")]
		protected virtual bool OnLeaveNotifyEvent (Gdk.EventCrossing evnt)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_leave_notify_event (Handle, evnt == null ? IntPtr.Zero : evnt.Handle);
			return __ret;
		}

		[GLib.Signal("leave_notify_event")]
		public event Gtk.LeaveNotifyEventHandler LeaveNotifyEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "leave_notify_event", typeof (Gtk.LeaveNotifyEventArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "leave_notify_event", typeof (Gtk.LeaveNotifyEventArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool ConfigureEventVMDelegate (IntPtr widget, IntPtr evnt);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_configure_event (IntPtr gtype, ConfigureEventVMDelegate cb);

		static ConfigureEventVMDelegate ConfigureEventVMCallback;

		static bool configureevent_cb (IntPtr widget, IntPtr evnt)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnConfigureEvent (new Gdk.EventConfigure(evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideConfigureEvent (GLib.GType gtype)
		{
			if (ConfigureEventVMCallback == null)
				ConfigureEventVMCallback = new ConfigureEventVMDelegate (configureevent_cb);
			gtksharp_widget_override_configure_event (gtype.Val, ConfigureEventVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_configure_event (IntPtr widget, IntPtr evnt);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideConfigureEvent")]
		protected virtual bool OnConfigureEvent (Gdk.EventConfigure evnt)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_configure_event (Handle, evnt == null ? IntPtr.Zero : evnt.Handle);
			return __ret;
		}

		[GLib.Signal("configure_event")]
		public event Gtk.ConfigureEventHandler ConfigureEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "configure_event", typeof (Gtk.ConfigureEventArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "configure_event", typeof (Gtk.ConfigureEventArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool FocusInEventVMDelegate (IntPtr widget, IntPtr evnt);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_focus_in_event (IntPtr gtype, FocusInEventVMDelegate cb);

		static FocusInEventVMDelegate FocusInEventVMCallback;

		static bool focusinevent_cb (IntPtr widget, IntPtr evnt)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnFocusInEvent (new Gdk.EventFocus(evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideFocusInEvent (GLib.GType gtype)
		{
			if (FocusInEventVMCallback == null)
				FocusInEventVMCallback = new FocusInEventVMDelegate (focusinevent_cb);
			gtksharp_widget_override_focus_in_event (gtype.Val, FocusInEventVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_focus_in_event (IntPtr widget, IntPtr evnt);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideFocusInEvent")]
		protected virtual bool OnFocusInEvent (Gdk.EventFocus evnt)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_focus_in_event (Handle, evnt == null ? IntPtr.Zero : evnt.Handle);
			return __ret;
		}

		[GLib.Signal("focus_in_event")]
		public event Gtk.FocusInEventHandler FocusInEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "focus_in_event", typeof (Gtk.FocusInEventArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "focus_in_event", typeof (Gtk.FocusInEventArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool FocusOutEventVMDelegate (IntPtr widget, IntPtr evnt);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_focus_out_event (IntPtr gtype, FocusOutEventVMDelegate cb);

		static FocusOutEventVMDelegate FocusOutEventVMCallback;

		static bool focusoutevent_cb (IntPtr widget, IntPtr evnt)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnFocusOutEvent (new Gdk.EventFocus(evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideFocusOutEvent (GLib.GType gtype)
		{
			if (FocusOutEventVMCallback == null)
				FocusOutEventVMCallback = new FocusOutEventVMDelegate (focusoutevent_cb);
			gtksharp_widget_override_focus_out_event (gtype.Val, FocusOutEventVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_focus_out_event (IntPtr widget, IntPtr evnt);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideFocusOutEvent")]
		protected virtual bool OnFocusOutEvent (Gdk.EventFocus evnt)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_focus_out_event (Handle, evnt == null ? IntPtr.Zero : evnt.Handle);
			return __ret;
		}

		[GLib.Signal("focus_out_event")]
		public event Gtk.FocusOutEventHandler FocusOutEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "focus_out_event", typeof (Gtk.FocusOutEventArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "focus_out_event", typeof (Gtk.FocusOutEventArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool MapEventVMDelegate (IntPtr widget, IntPtr evnt);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_map_event (IntPtr gtype, MapEventVMDelegate cb);

		static MapEventVMDelegate MapEventVMCallback;

		static bool mapevent_cb (IntPtr widget, IntPtr evnt)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnMapEvent (Gdk.Event.GetEvent (evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideMapEvent (GLib.GType gtype)
		{
			if (MapEventVMCallback == null)
				MapEventVMCallback = new MapEventVMDelegate (mapevent_cb);
			gtksharp_widget_override_map_event (gtype.Val, MapEventVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_map_event (IntPtr widget, IntPtr evnt);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideMapEvent")]
		protected virtual bool OnMapEvent (Gdk.Event evnt)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_map_event (Handle, evnt.Handle);
			return __ret;
		}

		[GLib.Signal("map_event")]
		public event Gtk.MapEventHandler MapEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "map_event", typeof (Gtk.MapEventArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "map_event", typeof (Gtk.MapEventArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool UnmapEventVMDelegate (IntPtr widget, IntPtr evnt);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_unmap_event (IntPtr gtype, UnmapEventVMDelegate cb);

		static UnmapEventVMDelegate UnmapEventVMCallback;

		static bool unmapevent_cb (IntPtr widget, IntPtr evnt)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnUnmapEvent (Gdk.Event.GetEvent (evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideUnmapEvent (GLib.GType gtype)
		{
			if (UnmapEventVMCallback == null)
				UnmapEventVMCallback = new UnmapEventVMDelegate (unmapevent_cb);
			gtksharp_widget_override_unmap_event (gtype.Val, UnmapEventVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_unmap_event (IntPtr widget, IntPtr evnt);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideUnmapEvent")]
		protected virtual bool OnUnmapEvent (Gdk.Event evnt)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_unmap_event (Handle, evnt.Handle);
			return __ret;
		}

		[GLib.Signal("unmap_event")]
		public event Gtk.UnmapEventHandler UnmapEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "unmap_event", typeof (Gtk.UnmapEventArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "unmap_event", typeof (Gtk.UnmapEventArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool PropertyNotifyEventVMDelegate (IntPtr widget, IntPtr evnt);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_property_notify_event (IntPtr gtype, PropertyNotifyEventVMDelegate cb);

		static PropertyNotifyEventVMDelegate PropertyNotifyEventVMCallback;

		static bool propertynotifyevent_cb (IntPtr widget, IntPtr evnt)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnPropertyNotifyEvent (new Gdk.EventProperty(evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverridePropertyNotifyEvent (GLib.GType gtype)
		{
			if (PropertyNotifyEventVMCallback == null)
				PropertyNotifyEventVMCallback = new PropertyNotifyEventVMDelegate (propertynotifyevent_cb);
			gtksharp_widget_override_property_notify_event (gtype.Val, PropertyNotifyEventVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_property_notify_event (IntPtr widget, IntPtr evnt);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverridePropertyNotifyEvent")]
		protected virtual bool OnPropertyNotifyEvent (Gdk.EventProperty evnt)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_property_notify_event (Handle, evnt == null ? IntPtr.Zero : evnt.Handle);
			return __ret;
		}

		[GLib.Signal("property_notify_event")]
		public event Gtk.PropertyNotifyEventHandler PropertyNotifyEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "property_notify_event", typeof (Gtk.PropertyNotifyEventArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "property_notify_event", typeof (Gtk.PropertyNotifyEventArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool SelectionClearEventVMDelegate (IntPtr widget, IntPtr evnt);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_selection_clear_event (IntPtr gtype, SelectionClearEventVMDelegate cb);

		static SelectionClearEventVMDelegate SelectionClearEventVMCallback;

		static bool selectionclearevent_cb (IntPtr widget, IntPtr evnt)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnSelectionClearEvent (new Gdk.EventSelection(evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideSelectionClearEvent (GLib.GType gtype)
		{
			if (SelectionClearEventVMCallback == null)
				SelectionClearEventVMCallback = new SelectionClearEventVMDelegate (selectionclearevent_cb);
			gtksharp_widget_override_selection_clear_event (gtype.Val, SelectionClearEventVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_selection_clear_event (IntPtr widget, IntPtr evnt);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideSelectionClearEvent")]
		protected virtual bool OnSelectionClearEvent (Gdk.EventSelection evnt)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_selection_clear_event (Handle, evnt == null ? IntPtr.Zero : evnt.Handle);
			return __ret;
		}

		[GLib.Signal("selection_clear_event")]
		public event Gtk.SelectionClearEventHandler SelectionClearEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "selection_clear_event", typeof (Gtk.SelectionClearEventArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "selection_clear_event", typeof (Gtk.SelectionClearEventArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool SelectionRequestEventVMDelegate (IntPtr widget, IntPtr evnt);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_selection_request_event (IntPtr gtype, SelectionRequestEventVMDelegate cb);

		static SelectionRequestEventVMDelegate SelectionRequestEventVMCallback;

		static bool selectionrequestevent_cb (IntPtr widget, IntPtr evnt)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnSelectionRequestEvent (new Gdk.EventSelection(evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideSelectionRequestEvent (GLib.GType gtype)
		{
			if (SelectionRequestEventVMCallback == null)
				SelectionRequestEventVMCallback = new SelectionRequestEventVMDelegate (selectionrequestevent_cb);
			gtksharp_widget_override_selection_request_event (gtype.Val, SelectionRequestEventVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_selection_request_event (IntPtr widget, IntPtr evnt);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideSelectionRequestEvent")]
		protected virtual bool OnSelectionRequestEvent (Gdk.EventSelection evnt)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_selection_request_event (Handle, evnt == null ? IntPtr.Zero : evnt.Handle);
			return __ret;
		}

		[GLib.Signal("selection_request_event")]
		public event Gtk.SelectionRequestEventHandler SelectionRequestEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "selection_request_event", typeof (Gtk.SelectionRequestEventArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "selection_request_event", typeof (Gtk.SelectionRequestEventArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool SelectionNotifyEventVMDelegate (IntPtr widget, IntPtr evnt);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_selection_notify_event (IntPtr gtype, SelectionNotifyEventVMDelegate cb);

		static SelectionNotifyEventVMDelegate SelectionNotifyEventVMCallback;

		static bool selectionnotifyevent_cb (IntPtr widget, IntPtr evnt)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnSelectionNotifyEvent (new Gdk.EventSelection(evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideSelectionNotifyEvent (GLib.GType gtype)
		{
			if (SelectionNotifyEventVMCallback == null)
				SelectionNotifyEventVMCallback = new SelectionNotifyEventVMDelegate (selectionnotifyevent_cb);
			gtksharp_widget_override_selection_notify_event (gtype.Val, SelectionNotifyEventVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_selection_notify_event (IntPtr widget, IntPtr evnt);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideSelectionNotifyEvent")]
		protected virtual bool OnSelectionNotifyEvent (Gdk.EventSelection evnt)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_selection_notify_event (Handle, evnt == null ? IntPtr.Zero : evnt.Handle);
			return __ret;
		}

		[GLib.Signal("selection_notify_event")]
		public event Gtk.SelectionNotifyEventHandler SelectionNotifyEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "selection_notify_event", typeof (Gtk.SelectionNotifyEventArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "selection_notify_event", typeof (Gtk.SelectionNotifyEventArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void SelectionReceivedVMDelegate (IntPtr widget, IntPtr selection_data, uint time_);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_selection_received (IntPtr gtype, SelectionReceivedVMDelegate cb);

		static SelectionReceivedVMDelegate SelectionReceivedVMCallback;

		static void selectionreceived_cb (IntPtr widget, IntPtr selection_data, uint time_)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				widget_managed.OnSelectionReceived (selection_data == IntPtr.Zero ? null : (Gtk.SelectionData) GLib.Opaque.GetOpaque (selection_data, typeof (Gtk.SelectionData), false), time_);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideSelectionReceived (GLib.GType gtype)
		{
			if (SelectionReceivedVMCallback == null)
				SelectionReceivedVMCallback = new SelectionReceivedVMDelegate (selectionreceived_cb);
			gtksharp_widget_override_selection_received (gtype.Val, SelectionReceivedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_base_selection_received (IntPtr widget, IntPtr selection_data, uint time_);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideSelectionReceived")]
		protected virtual void OnSelectionReceived (Gtk.SelectionData selection_data, uint time_)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_widget_base_selection_received (Handle, selection_data == null ? IntPtr.Zero : selection_data.Handle, time_);
		}

		[GLib.Signal("selection_received")]
		public event Gtk.SelectionReceivedHandler SelectionReceived {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "selection_received", typeof (Gtk.SelectionReceivedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "selection_received", typeof (Gtk.SelectionReceivedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void SelectionGetVMDelegate (IntPtr widget, IntPtr selection_data, uint info, uint time_);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_selection_get (IntPtr gtype, SelectionGetVMDelegate cb);

		static SelectionGetVMDelegate SelectionGetVMCallback;

		static void selectionget_cb (IntPtr widget, IntPtr selection_data, uint info, uint time_)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				widget_managed.OnSelectionGet (selection_data == IntPtr.Zero ? null : (Gtk.SelectionData) GLib.Opaque.GetOpaque (selection_data, typeof (Gtk.SelectionData), false), info, time_);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideSelectionGet (GLib.GType gtype)
		{
			if (SelectionGetVMCallback == null)
				SelectionGetVMCallback = new SelectionGetVMDelegate (selectionget_cb);
			gtksharp_widget_override_selection_get (gtype.Val, SelectionGetVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_base_selection_get (IntPtr widget, IntPtr selection_data, uint info, uint time_);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideSelectionGet")]
		protected virtual void OnSelectionGet (Gtk.SelectionData selection_data, uint info, uint time_)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_widget_base_selection_get (Handle, selection_data == null ? IntPtr.Zero : selection_data.Handle, info, time_);
		}

		[GLib.Signal("selection_get")]
		public event Gtk.SelectionGetHandler SelectionGet {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "selection_get", typeof (Gtk.SelectionGetArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "selection_get", typeof (Gtk.SelectionGetArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool ProximityInEventVMDelegate (IntPtr widget, IntPtr evnt);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_proximity_in_event (IntPtr gtype, ProximityInEventVMDelegate cb);

		static ProximityInEventVMDelegate ProximityInEventVMCallback;

		static bool proximityinevent_cb (IntPtr widget, IntPtr evnt)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnProximityInEvent (new Gdk.EventProximity(evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideProximityInEvent (GLib.GType gtype)
		{
			if (ProximityInEventVMCallback == null)
				ProximityInEventVMCallback = new ProximityInEventVMDelegate (proximityinevent_cb);
			gtksharp_widget_override_proximity_in_event (gtype.Val, ProximityInEventVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_proximity_in_event (IntPtr widget, IntPtr evnt);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideProximityInEvent")]
		protected virtual bool OnProximityInEvent (Gdk.EventProximity evnt)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_proximity_in_event (Handle, evnt == null ? IntPtr.Zero : evnt.Handle);
			return __ret;
		}

		[GLib.Signal("proximity_in_event")]
		public event Gtk.ProximityInEventHandler ProximityInEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "proximity_in_event", typeof (Gtk.ProximityInEventArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "proximity_in_event", typeof (Gtk.ProximityInEventArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool ProximityOutEventVMDelegate (IntPtr widget, IntPtr evnt);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_proximity_out_event (IntPtr gtype, ProximityOutEventVMDelegate cb);

		static ProximityOutEventVMDelegate ProximityOutEventVMCallback;

		static bool proximityoutevent_cb (IntPtr widget, IntPtr evnt)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnProximityOutEvent (new Gdk.EventProximity(evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideProximityOutEvent (GLib.GType gtype)
		{
			if (ProximityOutEventVMCallback == null)
				ProximityOutEventVMCallback = new ProximityOutEventVMDelegate (proximityoutevent_cb);
			gtksharp_widget_override_proximity_out_event (gtype.Val, ProximityOutEventVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_proximity_out_event (IntPtr widget, IntPtr evnt);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideProximityOutEvent")]
		protected virtual bool OnProximityOutEvent (Gdk.EventProximity evnt)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_proximity_out_event (Handle, evnt == null ? IntPtr.Zero : evnt.Handle);
			return __ret;
		}

		[GLib.Signal("proximity_out_event")]
		public event Gtk.ProximityOutEventHandler ProximityOutEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "proximity_out_event", typeof (Gtk.ProximityOutEventArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "proximity_out_event", typeof (Gtk.ProximityOutEventArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DragLeaveVMDelegate (IntPtr widget, IntPtr context, uint time_);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_drag_leave (IntPtr gtype, DragLeaveVMDelegate cb);

		static DragLeaveVMDelegate DragLeaveVMCallback;

		static void dragleave_cb (IntPtr widget, IntPtr context, uint time_)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				widget_managed.OnDragLeave (GLib.Object.GetObject(context) as Gdk.DragContext, time_);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideDragLeave (GLib.GType gtype)
		{
			if (DragLeaveVMCallback == null)
				DragLeaveVMCallback = new DragLeaveVMDelegate (dragleave_cb);
			gtksharp_widget_override_drag_leave (gtype.Val, DragLeaveVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_base_drag_leave (IntPtr widget, IntPtr context, uint time_);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideDragLeave")]
		protected virtual void OnDragLeave (Gdk.DragContext context, uint time_)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_widget_base_drag_leave (Handle, context == null ? IntPtr.Zero : context.Handle, time_);
		}

		[GLib.Signal("drag_leave")]
		public event Gtk.DragLeaveHandler DragLeave {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "drag_leave", typeof (Gtk.DragLeaveArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "drag_leave", typeof (Gtk.DragLeaveArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DragBeginVMDelegate (IntPtr widget, IntPtr context);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_drag_begin (IntPtr gtype, DragBeginVMDelegate cb);

		static DragBeginVMDelegate DragBeginVMCallback;

		static void dragbegin_cb (IntPtr widget, IntPtr context)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				widget_managed.OnDragBegin (GLib.Object.GetObject(context) as Gdk.DragContext);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideDragBegin (GLib.GType gtype)
		{
			if (DragBeginVMCallback == null)
				DragBeginVMCallback = new DragBeginVMDelegate (dragbegin_cb);
			gtksharp_widget_override_drag_begin (gtype.Val, DragBeginVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_base_drag_begin (IntPtr widget, IntPtr context);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideDragBegin")]
		protected virtual void OnDragBegin (Gdk.DragContext context)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_widget_base_drag_begin (Handle, context == null ? IntPtr.Zero : context.Handle);
		}

		[GLib.Signal("drag_begin")]
		public event Gtk.DragBeginHandler DragBegin {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "drag_begin", typeof (Gtk.DragBeginArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "drag_begin", typeof (Gtk.DragBeginArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DragEndVMDelegate (IntPtr widget, IntPtr context);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_drag_end (IntPtr gtype, DragEndVMDelegate cb);

		static DragEndVMDelegate DragEndVMCallback;

		static void dragend_cb (IntPtr widget, IntPtr context)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				widget_managed.OnDragEnd (GLib.Object.GetObject(context) as Gdk.DragContext);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideDragEnd (GLib.GType gtype)
		{
			if (DragEndVMCallback == null)
				DragEndVMCallback = new DragEndVMDelegate (dragend_cb);
			gtksharp_widget_override_drag_end (gtype.Val, DragEndVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_base_drag_end (IntPtr widget, IntPtr context);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideDragEnd")]
		protected virtual void OnDragEnd (Gdk.DragContext context)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_widget_base_drag_end (Handle, context == null ? IntPtr.Zero : context.Handle);
		}

		[GLib.Signal("drag_end")]
		public event Gtk.DragEndHandler DragEnd {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "drag_end", typeof (Gtk.DragEndArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "drag_end", typeof (Gtk.DragEndArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DragDataDeleteVMDelegate (IntPtr widget, IntPtr context);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_drag_data_delete (IntPtr gtype, DragDataDeleteVMDelegate cb);

		static DragDataDeleteVMDelegate DragDataDeleteVMCallback;

		static void dragdatadelete_cb (IntPtr widget, IntPtr context)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				widget_managed.OnDragDataDelete (GLib.Object.GetObject(context) as Gdk.DragContext);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideDragDataDelete (GLib.GType gtype)
		{
			if (DragDataDeleteVMCallback == null)
				DragDataDeleteVMCallback = new DragDataDeleteVMDelegate (dragdatadelete_cb);
			gtksharp_widget_override_drag_data_delete (gtype.Val, DragDataDeleteVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_base_drag_data_delete (IntPtr widget, IntPtr context);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideDragDataDelete")]
		protected virtual void OnDragDataDelete (Gdk.DragContext context)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_widget_base_drag_data_delete (Handle, context == null ? IntPtr.Zero : context.Handle);
		}

		[GLib.Signal("drag_data_delete")]
		public event Gtk.DragDataDeleteHandler DragDataDelete {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "drag_data_delete", typeof (Gtk.DragDataDeleteArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "drag_data_delete", typeof (Gtk.DragDataDeleteArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool DragFailedVMDelegate (IntPtr inst, IntPtr drag_context, int drag_result);

		static DragFailedVMDelegate DragFailedVMCallback;

		static bool dragfailed_cb (IntPtr inst, IntPtr drag_context, int drag_result)
		{
			try {
				Widget inst_managed = GLib.Object.GetObject (inst, false) as Widget;
				return inst_managed.OnDragFailed (GLib.Object.GetObject(drag_context) as Gdk.DragContext, (Gtk.DragResult) drag_result);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideDragFailed (GLib.GType gtype)
		{
			if (DragFailedVMCallback == null)
				DragFailedVMCallback = new DragFailedVMDelegate (dragfailed_cb);
			OverrideVirtualMethod (gtype, "drag_failed", DragFailedVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideDragFailed")]
		protected virtual bool OnDragFailed (Gdk.DragContext drag_context, Gtk.DragResult drag_result)
		{
			GLib.Value ret = new GLib		.Value (GLib.GType.Boolean);
			unsafe {
				GLib.Value* inst_and_params = stackalloc GLib.Value [3];
				using (inst_and_params[0] = new GLib.Value (this)) {
					using (inst_and_params [1] = new GLib.Value (drag_context)) {
						using (inst_and_params [2] = new GLib.Value (drag_result)) {
							g_signal_chain_from_overridden (inst_and_params, ref ret);
						}
					}
				}
			}
			bool result = (bool) ret;
			ret.Dispose ();
			return result;
		}

		[GLib.Signal("drag_failed")]
		public event Gtk.DragFailedHandler DragFailed {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "drag_failed", typeof (Gtk.DragFailedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "drag_failed", typeof (Gtk.DragFailedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool DragMotionVMDelegate (IntPtr widget, IntPtr context, int x, int y, uint time_);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_drag_motion (IntPtr gtype, DragMotionVMDelegate cb);

		static DragMotionVMDelegate DragMotionVMCallback;

		static bool dragmotion_cb (IntPtr widget, IntPtr context, int x, int y, uint time_)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnDragMotion (GLib.Object.GetObject(context) as Gdk.DragContext, x, y, time_);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideDragMotion (GLib.GType gtype)
		{
			if (DragMotionVMCallback == null)
				DragMotionVMCallback = new DragMotionVMDelegate (dragmotion_cb);
			gtksharp_widget_override_drag_motion (gtype.Val, DragMotionVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_drag_motion (IntPtr widget, IntPtr context, int x, int y, uint time_);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideDragMotion")]
		protected virtual bool OnDragMotion (Gdk.DragContext context, int x, int y, uint time_)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_drag_motion (Handle, context == null ? IntPtr.Zero : context.Handle, x, y, time_);
			return __ret;
		}

		[GLib.Signal("drag_motion")]
		public event Gtk.DragMotionHandler DragMotion {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "drag_motion", typeof (Gtk.DragMotionArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "drag_motion", typeof (Gtk.DragMotionArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool DragDropVMDelegate (IntPtr widget, IntPtr context, int x, int y, uint time_);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_drag_drop (IntPtr gtype, DragDropVMDelegate cb);

		static DragDropVMDelegate DragDropVMCallback;

		static bool dragdrop_cb (IntPtr widget, IntPtr context, int x, int y, uint time_)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnDragDrop (GLib.Object.GetObject(context) as Gdk.DragContext, x, y, time_);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideDragDrop (GLib.GType gtype)
		{
			if (DragDropVMCallback == null)
				DragDropVMCallback = new DragDropVMDelegate (dragdrop_cb);
			gtksharp_widget_override_drag_drop (gtype.Val, DragDropVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_drag_drop (IntPtr widget, IntPtr context, int x, int y, uint time_);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideDragDrop")]
		protected virtual bool OnDragDrop (Gdk.DragContext context, int x, int y, uint time_)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_drag_drop (Handle, context == null ? IntPtr.Zero : context.Handle, x, y, time_);
			return __ret;
		}

		[GLib.Signal("drag_drop")]
		public event Gtk.DragDropHandler DragDrop {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "drag_drop", typeof (Gtk.DragDropArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "drag_drop", typeof (Gtk.DragDropArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DragDataGetVMDelegate (IntPtr widget, IntPtr context, IntPtr selection_data, uint info, uint time_);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_drag_data_get (IntPtr gtype, DragDataGetVMDelegate cb);

		static DragDataGetVMDelegate DragDataGetVMCallback;

		static void dragdataget_cb (IntPtr widget, IntPtr context, IntPtr selection_data, uint info, uint time_)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				widget_managed.OnDragDataGet (GLib.Object.GetObject(context) as Gdk.DragContext, selection_data == IntPtr.Zero ? null : (Gtk.SelectionData) GLib.Opaque.GetOpaque (selection_data, typeof (Gtk.SelectionData), false), info, time_);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideDragDataGet (GLib.GType gtype)
		{
			if (DragDataGetVMCallback == null)
				DragDataGetVMCallback = new DragDataGetVMDelegate (dragdataget_cb);
			gtksharp_widget_override_drag_data_get (gtype.Val, DragDataGetVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_base_drag_data_get (IntPtr widget, IntPtr context, IntPtr selection_data, uint info, uint time_);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideDragDataGet")]
		protected virtual void OnDragDataGet (Gdk.DragContext context, Gtk.SelectionData selection_data, uint info, uint time_)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_widget_base_drag_data_get (Handle, context == null ? IntPtr.Zero : context.Handle, selection_data == null ? IntPtr.Zero : selection_data.Handle, info, time_);
		}

		[GLib.Signal("drag_data_get")]
		public event Gtk.DragDataGetHandler DragDataGet {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "drag_data_get", typeof (Gtk.DragDataGetArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "drag_data_get", typeof (Gtk.DragDataGetArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DragDataReceivedVMDelegate (IntPtr widget, IntPtr context, int x, int y, IntPtr selection_data, uint info, uint time_);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_drag_data_received (IntPtr gtype, DragDataReceivedVMDelegate cb);

		static DragDataReceivedVMDelegate DragDataReceivedVMCallback;

		static void dragdatareceived_cb (IntPtr widget, IntPtr context, int x, int y, IntPtr selection_data, uint info, uint time_)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				widget_managed.OnDragDataReceived (GLib.Object.GetObject(context) as Gdk.DragContext, x, y, selection_data == IntPtr.Zero ? null : (Gtk.SelectionData) GLib.Opaque.GetOpaque (selection_data, typeof (Gtk.SelectionData), false), info, time_);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideDragDataReceived (GLib.GType gtype)
		{
			if (DragDataReceivedVMCallback == null)
				DragDataReceivedVMCallback = new DragDataReceivedVMDelegate (dragdatareceived_cb);
			gtksharp_widget_override_drag_data_received (gtype.Val, DragDataReceivedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_base_drag_data_received (IntPtr widget, IntPtr context, int x, int y, IntPtr selection_data, uint info, uint time_);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideDragDataReceived")]
		protected virtual void OnDragDataReceived (Gdk.DragContext context, int x, int y, Gtk.SelectionData selection_data, uint info, uint time_)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_widget_base_drag_data_received (Handle, context == null ? IntPtr.Zero : context.Handle, x, y, selection_data == null ? IntPtr.Zero : selection_data.Handle, info, time_);
		}

		[GLib.Signal("drag_data_received")]
		public event Gtk.DragDataReceivedHandler DragDataReceived {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "drag_data_received", typeof (Gtk.DragDataReceivedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "drag_data_received", typeof (Gtk.DragDataReceivedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool VisibilityNotifyEventVMDelegate (IntPtr widget, IntPtr evnt);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_visibility_notify_event (IntPtr gtype, VisibilityNotifyEventVMDelegate cb);

		static VisibilityNotifyEventVMDelegate VisibilityNotifyEventVMCallback;

		static bool visibilitynotifyevent_cb (IntPtr widget, IntPtr evnt)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnVisibilityNotifyEvent (new Gdk.EventVisibility(evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideVisibilityNotifyEvent (GLib.GType gtype)
		{
			if (VisibilityNotifyEventVMCallback == null)
				VisibilityNotifyEventVMCallback = new VisibilityNotifyEventVMDelegate (visibilitynotifyevent_cb);
			gtksharp_widget_override_visibility_notify_event (gtype.Val, VisibilityNotifyEventVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_visibility_notify_event (IntPtr widget, IntPtr evnt);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideVisibilityNotifyEvent")]
		protected virtual bool OnVisibilityNotifyEvent (Gdk.EventVisibility evnt)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_visibility_notify_event (Handle, evnt == null ? IntPtr.Zero : evnt.Handle);
			return __ret;
		}

		[GLib.Signal("visibility_notify_event")]
		public event Gtk.VisibilityNotifyEventHandler VisibilityNotifyEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "visibility_notify_event", typeof (Gtk.VisibilityNotifyEventArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "visibility_notify_event", typeof (Gtk.VisibilityNotifyEventArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool ClientEventVMDelegate (IntPtr widget, IntPtr evnt);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_client_event (IntPtr gtype, ClientEventVMDelegate cb);

		static ClientEventVMDelegate ClientEventVMCallback;

		static bool clientevent_cb (IntPtr widget, IntPtr evnt)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnClientEvent (new Gdk.EventClient(evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideClientEvent (GLib.GType gtype)
		{
			if (ClientEventVMCallback == null)
				ClientEventVMCallback = new ClientEventVMDelegate (clientevent_cb);
			gtksharp_widget_override_client_event (gtype.Val, ClientEventVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_client_event (IntPtr widget, IntPtr evnt);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideClientEvent")]
		protected virtual bool OnClientEvent (Gdk.EventClient evnt)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_client_event (Handle, evnt == null ? IntPtr.Zero : evnt.Handle);
			return __ret;
		}

		[GLib.Signal("client_event")]
		public event Gtk.ClientEventHandler ClientEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "client_event", typeof (Gtk.ClientEventArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "client_event", typeof (Gtk.ClientEventArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool NoExposeEventVMDelegate (IntPtr widget, IntPtr evnt);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_no_expose_event (IntPtr gtype, NoExposeEventVMDelegate cb);

		static NoExposeEventVMDelegate NoExposeEventVMCallback;

		static bool noexposeevent_cb (IntPtr widget, IntPtr evnt)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnNoExposeEvent (Gdk.Event.GetEvent (evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideNoExposeEvent (GLib.GType gtype)
		{
			if (NoExposeEventVMCallback == null)
				NoExposeEventVMCallback = new NoExposeEventVMDelegate (noexposeevent_cb);
			gtksharp_widget_override_no_expose_event (gtype.Val, NoExposeEventVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_no_expose_event (IntPtr widget, IntPtr evnt);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideNoExposeEvent")]
		protected virtual bool OnNoExposeEvent (Gdk.Event evnt)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_no_expose_event (Handle, evnt.Handle);
			return __ret;
		}

		[GLib.Signal("no_expose_event")]
		public event Gtk.NoExposeEventHandler NoExposeEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "no_expose_event", typeof (Gtk.NoExposeEventArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "no_expose_event", typeof (Gtk.NoExposeEventArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool WindowStateEventVMDelegate (IntPtr widget, IntPtr evnt);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_window_state_event (IntPtr gtype, WindowStateEventVMDelegate cb);

		static WindowStateEventVMDelegate WindowStateEventVMCallback;

		static bool windowstateevent_cb (IntPtr widget, IntPtr evnt)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnWindowStateEvent (new Gdk.EventWindowState(evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideWindowStateEvent (GLib.GType gtype)
		{
			if (WindowStateEventVMCallback == null)
				WindowStateEventVMCallback = new WindowStateEventVMDelegate (windowstateevent_cb);
			gtksharp_widget_override_window_state_event (gtype.Val, WindowStateEventVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_window_state_event (IntPtr widget, IntPtr evnt);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideWindowStateEvent")]
		protected virtual bool OnWindowStateEvent (Gdk.EventWindowState evnt)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_window_state_event (Handle, evnt == null ? IntPtr.Zero : evnt.Handle);
			return __ret;
		}

		[GLib.Signal("window_state_event")]
		public event Gtk.WindowStateEventHandler WindowStateEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "window_state_event", typeof (Gtk.WindowStateEventArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "window_state_event", typeof (Gtk.WindowStateEventArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool GrabBrokenEventVMDelegate (IntPtr widget, IntPtr evnt);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_grab_broken_event (IntPtr gtype, GrabBrokenEventVMDelegate cb);

		static GrabBrokenEventVMDelegate GrabBrokenEventVMCallback;

		static bool grabbrokenevent_cb (IntPtr widget, IntPtr evnt)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnGrabBrokenEvent (new Gdk.EventGrabBroken(evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideGrabBrokenEvent (GLib.GType gtype)
		{
			if (GrabBrokenEventVMCallback == null)
				GrabBrokenEventVMCallback = new GrabBrokenEventVMDelegate (grabbrokenevent_cb);
			gtksharp_widget_override_grab_broken_event (gtype.Val, GrabBrokenEventVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_grab_broken_event (IntPtr widget, IntPtr evnt);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideGrabBrokenEvent")]
		protected virtual bool OnGrabBrokenEvent (Gdk.EventGrabBroken evnt)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_grab_broken_event (Handle, evnt == null ? IntPtr.Zero : evnt.Handle);
			return __ret;
		}

		[GLib.Signal("grab_broken_event")]
		public event Gtk.GrabBrokenEventHandler GrabBrokenEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "grab_broken_event", typeof (Gtk.GrabBrokenEventArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "grab_broken_event", typeof (Gtk.GrabBrokenEventArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool QueryTooltipVMDelegate (IntPtr widget, int x, int y, bool keyboard_tooltip, IntPtr tooltip);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_query_tooltip (IntPtr gtype, QueryTooltipVMDelegate cb);

		static QueryTooltipVMDelegate QueryTooltipVMCallback;

		static bool querytooltip_cb (IntPtr widget, int x, int y, bool keyboard_tooltip, IntPtr tooltip)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnQueryTooltip (x, y, keyboard_tooltip, GLib.Object.GetObject(tooltip) as Gtk.Tooltip);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideQueryTooltip (GLib.GType gtype)
		{
			if (QueryTooltipVMCallback == null)
				QueryTooltipVMCallback = new QueryTooltipVMDelegate (querytooltip_cb);
			gtksharp_widget_override_query_tooltip (gtype.Val, QueryTooltipVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_query_tooltip (IntPtr widget, int x, int y, bool keyboard_tooltip, IntPtr tooltip);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideQueryTooltip")]
		protected virtual bool OnQueryTooltip (int x, int y, bool keyboard_tooltip, Gtk.Tooltip tooltip)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_query_tooltip (Handle, x, y, keyboard_tooltip, tooltip == null ? IntPtr.Zero : tooltip.Handle);
			return __ret;
		}

		[GLib.Signal("query-tooltip")]
		public event Gtk.QueryTooltipHandler QueryTooltip {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "query-tooltip", typeof (Gtk.QueryTooltipArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "query-tooltip", typeof (Gtk.QueryTooltipArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool PopupMenuVMDelegate (IntPtr widget);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_popup_menu (IntPtr gtype, PopupMenuVMDelegate cb);

		static PopupMenuVMDelegate PopupMenuVMCallback;

		static bool popupmenu_cb (IntPtr widget)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnPopupMenu ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverridePopupMenu (GLib.GType gtype)
		{
			if (PopupMenuVMCallback == null)
				PopupMenuVMCallback = new PopupMenuVMDelegate (popupmenu_cb);
			gtksharp_widget_override_popup_menu (gtype.Val, PopupMenuVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_popup_menu (IntPtr widget);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverridePopupMenu")]
		protected virtual bool OnPopupMenu ()
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_popup_menu (Handle);
			return __ret;
		}

		[GLib.Signal("popup_menu")]
		public event Gtk.PopupMenuHandler PopupMenu {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "popup_menu", typeof (Gtk.PopupMenuArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "popup_menu", typeof (Gtk.PopupMenuArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool HelpShownVMDelegate (IntPtr widget, int help_type);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_show_help (IntPtr gtype, HelpShownVMDelegate cb);

		static HelpShownVMDelegate HelpShownVMCallback;

		static bool helpshown_cb (IntPtr widget, int help_type)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnHelpShown ((Gtk.WidgetHelpType) help_type);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideHelpShown (GLib.GType gtype)
		{
			if (HelpShownVMCallback == null)
				HelpShownVMCallback = new HelpShownVMDelegate (helpshown_cb);
			gtksharp_widget_override_show_help (gtype.Val, HelpShownVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_show_help (IntPtr widget, int help_type);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideHelpShown")]
		protected virtual bool OnHelpShown (Gtk.WidgetHelpType help_type)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_show_help (Handle, (int) help_type);
			return __ret;
		}

		[GLib.Signal("show_help")]
		public event Gtk.HelpShownHandler HelpShown {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "show_help", typeof (Gtk.HelpShownArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "show_help", typeof (Gtk.HelpShownArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void AccelClosuresChangedVMDelegate (IntPtr inst);

		static AccelClosuresChangedVMDelegate AccelClosuresChangedVMCallback;

		static void accelclosureschanged_cb (IntPtr inst)
		{
			try {
				Widget inst_managed = GLib.Object.GetObject (inst, false) as Widget;
				inst_managed.OnAccelClosuresChanged ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideAccelClosuresChanged (GLib.GType gtype)
		{
			if (AccelClosuresChangedVMCallback == null)
				AccelClosuresChangedVMCallback = new AccelClosuresChangedVMDelegate (accelclosureschanged_cb);
			OverrideVirtualMethod (gtype, "accel_closures_changed", AccelClosuresChangedVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideAccelClosuresChanged")]
		protected virtual void OnAccelClosuresChanged ()
		{
			GLib.Value ret = GLib.Value.Empty;
			unsafe {
				GLib.Value* inst_and_params = stackalloc GLib.Value [1];
				using (inst_and_params[0] = new GLib.Value (this)) {
					g_signal_chain_from_overridden (inst_and_params, ref ret);
				}
			}
		}

		[GLib.Signal("accel_closures_changed")]
		public event System.EventHandler AccelClosuresChanged {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "accel_closures_changed");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "accel_closures_changed");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ScreenChangedVMDelegate (IntPtr widget, IntPtr previous_screen);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_screen_changed (IntPtr gtype, ScreenChangedVMDelegate cb);

		static ScreenChangedVMDelegate ScreenChangedVMCallback;

		static void screenchanged_cb (IntPtr widget, IntPtr previous_screen)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				widget_managed.OnScreenChanged (GLib.Object.GetObject(previous_screen) as Gdk.Screen);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideScreenChanged (GLib.GType gtype)
		{
			if (ScreenChangedVMCallback == null)
				ScreenChangedVMCallback = new ScreenChangedVMDelegate (screenchanged_cb);
			gtksharp_widget_override_screen_changed (gtype.Val, ScreenChangedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_base_screen_changed (IntPtr widget, IntPtr previous_screen);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideScreenChanged")]
		protected virtual void OnScreenChanged (Gdk.Screen previous_screen)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_widget_base_screen_changed (Handle, previous_screen == null ? IntPtr.Zero : previous_screen.Handle);
		}

		[GLib.Signal("screen_changed")]
		public event Gtk.ScreenChangedHandler ScreenChanged {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "screen_changed", typeof (Gtk.ScreenChangedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "screen_changed", typeof (Gtk.ScreenChangedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool AccelCanActivateVMDelegate (IntPtr widget, uint signal_id);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_widget_override_can_activate_accel (IntPtr gtype, AccelCanActivateVMDelegate cb);

		static AccelCanActivateVMDelegate AccelCanActivateVMCallback;

		static bool accelcanactivate_cb (IntPtr widget, uint signal_id)
		{
			try {
				Widget widget_managed = GLib.Object.GetObject (widget, false) as Widget;
				return widget_managed.OnAccelCanActivate (signal_id);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideAccelCanActivate (GLib.GType gtype)
		{
			if (AccelCanActivateVMCallback == null)
				AccelCanActivateVMCallback = new AccelCanActivateVMDelegate (accelcanactivate_cb);
			gtksharp_widget_override_can_activate_accel (gtype.Val, AccelCanActivateVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtksharp_widget_base_can_activate_accel (IntPtr widget, uint signal_id);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Widget), ConnectionMethod="OverrideAccelCanActivate")]
		protected virtual bool OnAccelCanActivate (uint signal_id)
		{
			Gtk.Application.AssertMainThread();
			bool __ret = gtksharp_widget_base_can_activate_accel (Handle, signal_id);
			return __ret;
		}

		[GLib.Signal("can_activate_accel")]
		public event Gtk.AccelCanActivateHandler AccelCanActivate {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "can_activate_accel", typeof (Gtk.AccelCanActivateArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "can_activate_accel", typeof (Gtk.AccelCanActivateArgs));
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_widget_activate(IntPtr raw);

		public bool Activate() {
			bool raw_ret = gtk_widget_activate(Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_add_accelerator(IntPtr raw, IntPtr accel_signal, IntPtr accel_group, uint accel_key, int accel_mods, int accel_flags);

		public void AddAccelerator(string accel_signal, Gtk.AccelGroup accel_group, uint accel_key, Gdk.ModifierType accel_mods, Gtk.AccelFlags accel_flags) {
			Gtk.Application.AssertMainThread();
			IntPtr native_accel_signal = GLib.Marshaller.StringToPtrGStrdup (accel_signal);
			gtk_widget_add_accelerator(Handle, native_accel_signal, accel_group == null ? IntPtr.Zero : accel_group.Handle, accel_key, (int) accel_mods, (int) accel_flags);
			GLib.Marshaller.Free (native_accel_signal);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_add_events(IntPtr raw, int events);

		public void AddEvents(int events) {
			Gtk.Application.AssertMainThread();
			gtk_widget_add_events(Handle, events);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_add_mnemonic_label(IntPtr raw, IntPtr label);

		public void AddMnemonicLabel(Gtk.Widget label) {
			Gtk.Application.AssertMainThread();
			gtk_widget_add_mnemonic_label(Handle, label == null ? IntPtr.Zero : label.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_widget_can_activate_accel(IntPtr raw, uint signal_id);

		public bool CanActivateAccel(uint signal_id) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_widget_can_activate_accel(Handle, signal_id);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_widget_child_focus(IntPtr raw, int direction);

		public bool ChildFocus(Gtk.DirectionType direction) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_widget_child_focus(Handle, (int) direction);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_child_notify(IntPtr raw, IntPtr child_property);

		public void ChildNotify(string child_property) {
			Gtk.Application.AssertMainThread();
			IntPtr native_child_property = GLib.Marshaller.StringToPtrGStrdup (child_property);
			gtk_widget_child_notify(Handle, native_child_property);
			GLib.Marshaller.Free (native_child_property);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_class_path(IntPtr raw, out uint path_length, out IntPtr path, out IntPtr path_reversed);

		public void ClassPath(out uint path_length, out string path, out string path_reversed) {
			Gtk.Application.AssertMainThread();
			IntPtr native_path;
			IntPtr native_path_reversed;
			gtk_widget_class_path(Handle, out path_length, out native_path, out native_path_reversed);
			path = GLib.Marshaller.PtrToStringGFree(native_path);
			path_reversed = GLib.Marshaller.PtrToStringGFree(native_path_reversed);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_create_pango_context(IntPtr raw);

		public Pango.Context CreatePangoContext() {
			IntPtr raw_ret = gtk_widget_create_pango_context(Handle);
			Pango.Context ret = GLib.Object.GetObject(raw_ret, true) as Pango.Context;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_create_pango_layout(IntPtr raw, IntPtr text);

		public Pango.Layout CreatePangoLayout(string text) {
			Gtk.Application.AssertMainThread();
			IntPtr native_text = GLib.Marshaller.StringToPtrGStrdup (text);
			IntPtr raw_ret = gtk_widget_create_pango_layout(Handle, native_text);
			Pango.Layout ret = GLib.Object.GetObject(raw_ret, true) as Pango.Layout;
			GLib.Marshaller.Free (native_text);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_draw(IntPtr raw, ref Gdk.Rectangle area);

		[Obsolete]
		public void Draw(Gdk.Rectangle area) {
			Gtk.Application.AssertMainThread();
			gtk_widget_draw(Handle, ref area);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_ensure_style(IntPtr raw);

		public void EnsureStyle() {
			gtk_widget_ensure_style(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_error_bell(IntPtr raw);

		public void ErrorBell() {
			gtk_widget_error_bell(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_widget_event(IntPtr raw, IntPtr evnt);

		public bool ProcessEvent(Gdk.Event evnt) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_widget_event(Handle, evnt == null ? IntPtr.Zero : evnt.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_freeze_child_notify(IntPtr raw);

		public void FreezeChildNotify() {
			gtk_widget_freeze_child_notify(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_get_accessible(IntPtr raw);

		public Atk.Object Accessible { 
			get {
				IntPtr raw_ret = gtk_widget_get_accessible(Handle);
				Atk.Object ret = GLib.Object.GetObject(raw_ret) as Atk.Object;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_get_action(IntPtr raw);

		public Gtk.Action Action { 
			get {
				IntPtr raw_ret = gtk_widget_get_action(Handle);
				Gtk.Action ret = GLib.Object.GetObject(raw_ret) as Gtk.Action;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_get_ancestor(IntPtr raw, IntPtr widget_type);

		public Gtk.Widget GetAncestor(GLib.GType widget_type) {
			Gtk.Application.AssertMainThread();
			IntPtr raw_ret = gtk_widget_get_ancestor(Handle, widget_type.Val);
			Gtk.Widget ret = GLib.Object.GetObject(raw_ret) as Gtk.Widget;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_get_child_requisition(IntPtr raw, ref Gtk.Requisition requisition);

		public Gtk.Requisition ChildRequisition { 
			get {
				Gtk.Requisition requisition;
				Gtk.Application.AssertMainThread();
				requisition = new Gtk.Requisition();
				gtk_widget_get_child_requisition(Handle, ref requisition);
				return requisition;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_widget_get_child_visible(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_set_child_visible(IntPtr raw, bool is_visible);

		public bool ChildVisible { 
			get {
				bool raw_ret = gtk_widget_get_child_visible(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set {
				Gtk.Application.AssertMainThread();
				gtk_widget_set_child_visible(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_get_clipboard(IntPtr raw, IntPtr selection);

		public Gtk.Clipboard GetClipboard(Gdk.Atom selection) {
			Gtk.Application.AssertMainThread();
			IntPtr raw_ret = gtk_widget_get_clipboard(Handle, selection == null ? IntPtr.Zero : selection.Handle);
			Gtk.Clipboard ret = GLib.Object.GetObject(raw_ret) as Gtk.Clipboard;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_get_colormap(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_set_colormap(IntPtr raw, IntPtr colormap);

		public Gdk.Colormap Colormap { 
			get {
				IntPtr raw_ret = gtk_widget_get_colormap(Handle);
				Gdk.Colormap ret = GLib.Object.GetObject(raw_ret) as Gdk.Colormap;
				return ret;
			}
			set {
				Gtk.Application.AssertMainThread();
				gtk_widget_set_colormap(Handle, value == null ? IntPtr.Zero : value.Handle);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_get_composite_name(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_set_composite_name(IntPtr raw, IntPtr name);

		public string CompositeName { 
			get {
				IntPtr raw_ret = gtk_widget_get_composite_name(Handle);
				string ret = GLib.Marshaller.PtrToStringGFree(raw_ret);
				return ret;
			}
			set {
				Gtk.Application.AssertMainThread();
				IntPtr native_value = GLib.Marshaller.StringToPtrGStrdup (value);
				gtk_widget_set_composite_name(Handle, native_value);
				GLib.Marshaller.Free (native_value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_get_default_colormap();

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_set_default_colormap(IntPtr colormap);

		public static Gdk.Colormap DefaultColormap { 
			get {
				IntPtr raw_ret = gtk_widget_get_default_colormap();
				Gdk.Colormap ret = GLib.Object.GetObject(raw_ret) as Gdk.Colormap;
				return ret;
			}
			set {
				Gtk.Application.AssertMainThread();
				gtk_widget_set_default_colormap(value == null ? IntPtr.Zero : value.Handle);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_widget_get_default_direction();

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_set_default_direction(int dir);

		public static Gtk.TextDirection DefaultDirection { 
			get {
				int raw_ret = gtk_widget_get_default_direction();
				Gtk.TextDirection ret = (Gtk.TextDirection) raw_ret;
				return ret;
			}
			set {
				Gtk.Application.AssertMainThread();
				gtk_widget_set_default_direction((int) value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_get_default_style();

		public static Gtk.Style DefaultStyle { 
			get {
				IntPtr raw_ret = gtk_widget_get_default_style();
				Gtk.Style ret = GLib.Object.GetObject(raw_ret) as Gtk.Style;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_get_default_visual();

		public static Gdk.Visual DefaultVisual { 
			get {
				IntPtr raw_ret = gtk_widget_get_default_visual();
				Gdk.Visual ret = GLib.Object.GetObject(raw_ret) as Gdk.Visual;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_widget_get_direction(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_set_direction(IntPtr raw, int dir);

		public Gtk.TextDirection Direction { 
			get {
				int raw_ret = gtk_widget_get_direction(Handle);
				Gtk.TextDirection ret = (Gtk.TextDirection) raw_ret;
				return ret;
			}
			set {
				Gtk.Application.AssertMainThread();
				gtk_widget_set_direction(Handle, (int) value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_get_display(IntPtr raw);

		public Gdk.Display Display { 
			get {
				IntPtr raw_ret = gtk_widget_get_display(Handle);
				Gdk.Display ret = GLib.Object.GetObject(raw_ret) as Gdk.Display;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_get_modifier_style(IntPtr raw);

		public Gtk.RcStyle ModifierStyle { 
			get {
				IntPtr raw_ret = gtk_widget_get_modifier_style(Handle);
				Gtk.RcStyle ret = GLib.Object.GetObject(raw_ret) as Gtk.RcStyle;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_get_pango_context(IntPtr raw);

		public Pango.Context PangoContext { 
			get {
				IntPtr raw_ret = gtk_widget_get_pango_context(Handle);
				Pango.Context ret = GLib.Object.GetObject(raw_ret) as Pango.Context;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_get_parent_window(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_set_parent_window(IntPtr raw, IntPtr parent_window);

		public Gdk.Window ParentWindow { 
			get {
				IntPtr raw_ret = gtk_widget_get_parent_window(Handle);
				Gdk.Window ret = GLib.Object.GetObject(raw_ret) as Gdk.Window;
				return ret;
			}
			set {
				Gtk.Application.AssertMainThread();
				gtk_widget_set_parent_window(Handle, value == null ? IntPtr.Zero : value.Handle);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_get_pointer(IntPtr raw, out int x, out int y);

		public void GetPointer(out int x, out int y) {
			Gtk.Application.AssertMainThread();
			gtk_widget_get_pointer(Handle, out x, out y);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_get_root_window(IntPtr raw);

		public Gdk.Window RootWindow { 
			get {
				IntPtr raw_ret = gtk_widget_get_root_window(Handle);
				Gdk.Window ret = GLib.Object.GetObject(raw_ret) as Gdk.Window;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_get_screen(IntPtr raw);

		public Gdk.Screen Screen { 
			get {
				IntPtr raw_ret = gtk_widget_get_screen(Handle);
				Gdk.Screen ret = GLib.Object.GetObject(raw_ret) as Gdk.Screen;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_get_settings(IntPtr raw);

		public Gtk.Settings Settings { 
			get {
				IntPtr raw_ret = gtk_widget_get_settings(Handle);
				Gtk.Settings ret = GLib.Object.GetObject(raw_ret) as Gtk.Settings;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_get_size_request(IntPtr raw, out int width, out int height);

		public void GetSizeRequest(out int width, out int height) {
			Gtk.Application.AssertMainThread();
			gtk_widget_get_size_request(Handle, out width, out height);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_get_tooltip_window(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_set_tooltip_window(IntPtr raw, IntPtr custom_window);

		public Gtk.Window TooltipWindow { 
			get {
				IntPtr raw_ret = gtk_widget_get_tooltip_window(Handle);
				Gtk.Window ret = GLib.Object.GetObject(raw_ret) as Gtk.Window;
				return ret;
			}
			set {
				Gtk.Application.AssertMainThread();
				gtk_widget_set_tooltip_window(Handle, value == null ? IntPtr.Zero : value.Handle);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_get_toplevel(IntPtr raw);

		public Gtk.Widget Toplevel { 
			get {
				IntPtr raw_ret = gtk_widget_get_toplevel(Handle);
				Gtk.Widget ret = GLib.Object.GetObject(raw_ret) as Gtk.Widget;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_get_type();

		static GLib.GType _gtype = new GLib.GType (gtk_widget_get_type());
		public static new GLib.GType GType { 
			get {
								return _gtype;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_get_visual(IntPtr raw);

		public Gdk.Visual Visual { 
			get {
				IntPtr raw_ret = gtk_widget_get_visual(Handle);
				Gdk.Visual ret = GLib.Object.GetObject(raw_ret) as Gdk.Visual;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_grab_default(IntPtr raw);

		public void GrabDefault() {
			gtk_widget_grab_default(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_grab_focus(IntPtr raw);

		public void GrabFocus() {
			gtk_widget_grab_focus(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_widget_has_screen(IntPtr raw);

		public bool HasScreen { 
			get {
				bool raw_ret = gtk_widget_has_screen(Handle);
				bool ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_hide(IntPtr raw);

		public void Hide() {
			gtk_widget_hide(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_hide_all(IntPtr raw);

		public void HideAll() {
			gtk_widget_hide_all(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_widget_hide_on_delete(IntPtr raw);

		public bool HideOnDelete() {
			bool raw_ret = gtk_widget_hide_on_delete(Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_input_shape_combine_mask(IntPtr raw, IntPtr shape_mask, int offset_x, int offset_y);

		public void InputShapeCombineMask(Gdk.Pixmap shape_mask, int offset_x, int offset_y) {
			Gtk.Application.AssertMainThread();
			gtk_widget_input_shape_combine_mask(Handle, shape_mask == null ? IntPtr.Zero : shape_mask.Handle, offset_x, offset_y);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_widget_intersect(IntPtr raw, ref Gdk.Rectangle area, ref Gdk.Rectangle intersection);

		public bool Intersect(Gdk.Rectangle area, out Gdk.Rectangle intersection) {
			Gtk.Application.AssertMainThread();
			intersection = new Gdk.Rectangle();
			bool raw_ret = gtk_widget_intersect(Handle, ref area, ref intersection);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_widget_is_ancestor(IntPtr raw, IntPtr ancestor);

		public bool IsAncestor(Gtk.Widget ancestor) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_widget_is_ancestor(Handle, ancestor == null ? IntPtr.Zero : ancestor.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_widget_is_composited(IntPtr raw);

		public bool IsComposited { 
			get {
				bool raw_ret = gtk_widget_is_composited(Handle);
				bool ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_widget_keynav_failed(IntPtr raw, int direction);

		public bool KeynavFailed(Gtk.DirectionType direction) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_widget_keynav_failed(Handle, (int) direction);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_map(IntPtr raw);

		public void Map() {
			gtk_widget_map(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_widget_mnemonic_activate(IntPtr raw, bool group_cycling);

		public bool MnemonicActivate(bool group_cycling) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_widget_mnemonic_activate(Handle, group_cycling);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_modify_base(IntPtr raw, int state, ref Gdk.Color color);

		public void ModifyBase(Gtk.StateType state, Gdk.Color color) {
			Gtk.Application.AssertMainThread();
			gtk_widget_modify_base(Handle, (int) state, ref color);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_modify_bg(IntPtr raw, int state, ref Gdk.Color color);

		public void ModifyBg(Gtk.StateType state, Gdk.Color color) {
			Gtk.Application.AssertMainThread();
			gtk_widget_modify_bg(Handle, (int) state, ref color);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_modify_cursor(IntPtr raw, ref Gdk.Color primary, ref Gdk.Color secondary);

		public void ModifyCursor(Gdk.Color primary, Gdk.Color secondary) {
			Gtk.Application.AssertMainThread();
			gtk_widget_modify_cursor(Handle, ref primary, ref secondary);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_modify_fg(IntPtr raw, int state, ref Gdk.Color color);

		public void ModifyFg(Gtk.StateType state, Gdk.Color color) {
			Gtk.Application.AssertMainThread();
			gtk_widget_modify_fg(Handle, (int) state, ref color);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_modify_font(IntPtr raw, IntPtr font_desc);

		public void ModifyFont(Pango.FontDescription font_desc) {
			Gtk.Application.AssertMainThread();
			gtk_widget_modify_font(Handle, font_desc == null ? IntPtr.Zero : font_desc.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_modify_style(IntPtr raw, IntPtr style);

		public void ModifyStyle(Gtk.RcStyle style) {
			Gtk.Application.AssertMainThread();
			gtk_widget_modify_style(Handle, style == null ? IntPtr.Zero : style.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_modify_text(IntPtr raw, int state, ref Gdk.Color color);

		public void ModifyText(Gtk.StateType state, Gdk.Color color) {
			Gtk.Application.AssertMainThread();
			gtk_widget_modify_text(Handle, (int) state, ref color);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_path(IntPtr raw, out uint path_length, out IntPtr path, out IntPtr path_reversed);

		public void Path(out uint path_length, out string path, out string path_reversed) {
			Gtk.Application.AssertMainThread();
			IntPtr native_path;
			IntPtr native_path_reversed;
			gtk_widget_path(Handle, out path_length, out native_path, out native_path_reversed);
			path = GLib.Marshaller.PtrToStringGFree(native_path);
			path_reversed = GLib.Marshaller.PtrToStringGFree(native_path_reversed);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_pop_colormap();

		public static void PopColormap() {
			gtk_widget_pop_colormap();
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_pop_composite_child();

		public static void PopCompositeChild() {
			gtk_widget_pop_composite_child();
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_push_colormap(IntPtr cmap);

		public static void PushColormap(Gdk.Colormap cmap) {
			Gtk.Application.AssertMainThread();
			gtk_widget_push_colormap(cmap == null ? IntPtr.Zero : cmap.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_push_composite_child();

		public static void PushCompositeChild() {
			gtk_widget_push_composite_child();
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_queue_clear(IntPtr raw);

		[Obsolete]
		public void QueueClear() {
			gtk_widget_queue_clear(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_queue_clear_area(IntPtr raw, int x, int y, int width, int height);

		[Obsolete]
		public void QueueClearArea(int x, int y, int width, int height) {
			Gtk.Application.AssertMainThread();
			gtk_widget_queue_clear_area(Handle, x, y, width, height);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_queue_draw(IntPtr raw);

		public void QueueDraw() {
			gtk_widget_queue_draw(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_queue_draw_area(IntPtr raw, int x, int y, int width, int height);

		public void QueueDrawArea(int x, int y, int width, int height) {
			Gtk.Application.AssertMainThread();
			gtk_widget_queue_draw_area(Handle, x, y, width, height);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_queue_resize(IntPtr raw);

		public void QueueResize() {
			gtk_widget_queue_resize(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_queue_resize_no_redraw(IntPtr raw);

		public void QueueResizeNoRedraw() {
			gtk_widget_queue_resize_no_redraw(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_realize(IntPtr raw);

		public void Realize() {
			gtk_widget_realize(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_region_intersect(IntPtr raw, IntPtr region);

		public Gdk.Region RegionIntersect(Gdk.Region region) {
			Gtk.Application.AssertMainThread();
			IntPtr raw_ret = gtk_widget_region_intersect(Handle, region == null ? IntPtr.Zero : region.Handle);
			Gdk.Region ret = raw_ret == IntPtr.Zero ? null : (Gdk.Region) GLib.Opaque.GetOpaque (raw_ret, typeof (Gdk.Region), false);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_widget_remove_accelerator(IntPtr raw, IntPtr accel_group, uint accel_key, int accel_mods);

		public bool RemoveAccelerator(Gtk.AccelGroup accel_group, uint accel_key, Gdk.ModifierType accel_mods) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_widget_remove_accelerator(Handle, accel_group == null ? IntPtr.Zero : accel_group.Handle, accel_key, (int) accel_mods);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_remove_mnemonic_label(IntPtr raw, IntPtr label);

		public void RemoveMnemonicLabel(Gtk.Widget label) {
			Gtk.Application.AssertMainThread();
			gtk_widget_remove_mnemonic_label(Handle, label == null ? IntPtr.Zero : label.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_render_icon(IntPtr raw, IntPtr stock_id, int size, IntPtr detail);

		public Gdk.Pixbuf RenderIcon(string stock_id, Gtk.IconSize size, string detail) {
			Gtk.Application.AssertMainThread();
			IntPtr native_stock_id = GLib.Marshaller.StringToPtrGStrdup (stock_id);
			IntPtr native_detail = GLib.Marshaller.StringToPtrGStrdup (detail);
			IntPtr raw_ret = gtk_widget_render_icon(Handle, native_stock_id, (int) size, native_detail);
			Gdk.Pixbuf ret = GLib.Object.GetObject(raw_ret, true) as Gdk.Pixbuf;
			GLib.Marshaller.Free (native_stock_id);
			GLib.Marshaller.Free (native_detail);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_reparent(IntPtr raw, IntPtr new_parent);

		public void Reparent(Gtk.Widget new_parent) {
			Gtk.Application.AssertMainThread();
			gtk_widget_reparent(Handle, new_parent == null ? IntPtr.Zero : new_parent.Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_reset_rc_styles(IntPtr raw);

		public void ResetRcStyles() {
			gtk_widget_reset_rc_styles(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_reset_shapes(IntPtr raw);

		public void ResetShapes() {
			gtk_widget_reset_shapes(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_widget_send_expose(IntPtr raw, IntPtr evnt);

		public int SendExpose(Gdk.Event evnt) {
			Gtk.Application.AssertMainThread();
			int raw_ret = gtk_widget_send_expose(Handle, evnt == null ? IntPtr.Zero : evnt.Handle);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_set_accel_path(IntPtr raw, IntPtr accel_path, IntPtr accel_group);

		public void SetAccelPath(string accel_path, Gtk.AccelGroup accel_group) {
			Gtk.Application.AssertMainThread();
			IntPtr native_accel_path = GLib.Marshaller.StringToPtrGStrdup (accel_path);
			gtk_widget_set_accel_path(Handle, native_accel_path, accel_group == null ? IntPtr.Zero : accel_group.Handle);
			GLib.Marshaller.Free (native_accel_path);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_set_double_buffered(IntPtr raw, bool double_buffered);

		public bool DoubleBuffered { 
			set {
				Gtk.Application.AssertMainThread();
				gtk_widget_set_double_buffered(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_set_redraw_on_allocate(IntPtr raw, bool redraw_on_allocate);

		public bool RedrawOnAllocate { 
			set {
				Gtk.Application.AssertMainThread();
				gtk_widget_set_redraw_on_allocate(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_widget_set_scroll_adjustments(IntPtr raw, IntPtr hadjustment, IntPtr vadjustment);

		public bool SetScrollAdjustments(Gtk.Adjustment hadjustment, Gtk.Adjustment vadjustment) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_widget_set_scroll_adjustments(Handle, hadjustment == null ? IntPtr.Zero : hadjustment.Handle, vadjustment == null ? IntPtr.Zero : vadjustment.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_set_size_request(IntPtr raw, int width, int height);

		public void SetSizeRequest(int width, int height) {
			Gtk.Application.AssertMainThread();
			gtk_widget_set_size_request(Handle, width, height);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_set_uposition(IntPtr raw, int x, int y);

		[Obsolete]
		public void SetUposition(int x, int y) {
			Gtk.Application.AssertMainThread();
			gtk_widget_set_uposition(Handle, x, y);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_set_usize(IntPtr raw, int width, int height);

		[Obsolete]
		public void SetUsize(int width, int height) {
			Gtk.Application.AssertMainThread();
			gtk_widget_set_usize(Handle, width, height);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_shape_combine_mask(IntPtr raw, IntPtr shape_mask, int offset_x, int offset_y);

		public void ShapeCombineMask(Gdk.Pixmap shape_mask, int offset_x, int offset_y) {
			Gtk.Application.AssertMainThread();
			gtk_widget_shape_combine_mask(Handle, shape_mask == null ? IntPtr.Zero : shape_mask.Handle, offset_x, offset_y);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_show(IntPtr raw);

		public void Show() {
			gtk_widget_show(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_show_all(IntPtr raw);

		public void ShowAll() {
			gtk_widget_show_all(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_show_now(IntPtr raw);

		public void ShowNow() {
			gtk_widget_show_now(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_size_allocate(IntPtr raw, ref Gdk.Rectangle allocation);

		public void SizeAllocate(Gdk.Rectangle allocation) {
			Gtk.Application.AssertMainThread();
			gtk_widget_size_allocate(Handle, ref allocation);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_size_request(IntPtr raw, ref Gtk.Requisition requisition);

		public Gtk.Requisition SizeRequest() {
			Gtk.Requisition requisition;
			Gtk.Application.AssertMainThread();
			requisition = new Gtk.Requisition();
			gtk_widget_size_request(Handle, ref requisition);
			return requisition;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_thaw_child_notify(IntPtr raw);

		public void ThawChildNotify() {
			gtk_widget_thaw_child_notify(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_widget_translate_coordinates(IntPtr raw, IntPtr dest_widget, int src_x, int src_y, out int dest_x, out int dest_y);

		public bool TranslateCoordinates(Gtk.Widget dest_widget, int src_x, int src_y, out int dest_x, out int dest_y) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_widget_translate_coordinates(Handle, dest_widget == null ? IntPtr.Zero : dest_widget.Handle, src_x, src_y, out dest_x, out dest_y);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_trigger_tooltip_query(IntPtr raw);

		public void TriggerTooltipQuery() {
			gtk_widget_trigger_tooltip_query(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_unmap(IntPtr raw);

		public void Unmap() {
			gtk_widget_unmap(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_unparent(IntPtr raw);

		public void Unparent() {
			gtk_widget_unparent(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_widget_unrealize(IntPtr raw);

		public void Unrealize() {
			gtk_widget_unrealize(Handle);
		}

		[DllImport("libatk-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr atk_implementor_ref_accessible(IntPtr raw);

		public Atk.Object RefAccessible() {
			IntPtr raw_ret = atk_implementor_ref_accessible(Handle);
			Atk.Object ret = GLib.Object.GetObject(raw_ret, true) as Atk.Object;
			return ret;
		}

#endregion
#region Customized extensions
#line 1 "Widget.custom"
//
// Gtk.Widget.custom - Gtk Widget class customizations
//
// Authors: Rachel Hestilow <hestilow@ximian.com>,
//          Brad Taylor <brad@getcoded.net>
//
// Copyright (C) 2007 Brad Taylor
// Copyright (C) 2002 Rachel Hestilow
//
// This code is inserted after the automatically generated code.
//
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of version 2 of the Lesser GNU General
// Public License as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this program; if not, write to the
// Free Software Foundation, Inc., 59 Temple Place - Suite 330,
// Boston, MA 02111-1307, USA.

[Obsolete]
protected Widget (GLib.GType gtype) : base(gtype)
{
}

public override void Destroy ()
{
	base.Destroy ();
}

[DllImport("gtksharpglue-2", CallingConvention=CallingConvention.Cdecl)]
static extern IntPtr gtksharp_gtk_widget_get_allocation (IntPtr style);

public Gdk.Rectangle Allocation {
	get { return Gdk.Rectangle.New (gtksharp_gtk_widget_get_allocation (Handle)); }
	set { SizeAllocate (value); }
}

[DllImport("gtksharpglue-2", CallingConvention=CallingConvention.Cdecl)]
static extern IntPtr gtksharp_gtk_widget_get_window (IntPtr widget);
[DllImport("gtksharpglue-2", CallingConvention=CallingConvention.Cdecl)]
static extern void gtksharp_gtk_widget_set_window (IntPtr widget, IntPtr window);
public Gdk.Window GdkWindow {
	get {
		IntPtr raw_ret = gtksharp_gtk_widget_get_window (Handle);

		if (raw_ret != (IntPtr) 0){
	 		Gdk.Window ret = (Gdk.Window) GLib.Object.GetObject(raw_ret, false);
			return ret;
		}
		return null;
	}
	set {
		Gdk.Window window = value as Gdk.Window;
		gtksharp_gtk_widget_set_window (Handle, window.Handle);
	}
}

public void AddAccelerator (string accel_signal, AccelGroup accel_group, AccelKey accel_key)
{
	this.AddAccelerator (accel_signal, accel_group, (uint) accel_key.Key, accel_key.AccelMods, accel_key.AccelFlags);

}

[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
static extern void gtk_widget_set_state (IntPtr raw, int state);

[DllImport("gtksharpglue-2", CallingConvention=CallingConvention.Cdecl)]
static extern int gtksharp_gtk_widget_get_state (IntPtr raw);

public Gtk.StateType State {
	set {
		gtk_widget_set_state (Handle, (int) value);
	}
	get {
		return (Gtk.StateType) gtksharp_gtk_widget_get_state (Handle);
	}
}

[DllImport("gtksharpglue-2", CallingConvention=CallingConvention.Cdecl)]
static extern int gtksharp_gtk_widget_get_flags (IntPtr raw);

[DllImport("gtksharpglue-2", CallingConvention=CallingConvention.Cdecl)]
static extern void gtksharp_gtk_widget_set_flags (IntPtr raw, int flags);

[Obsolete]
public int Flags {
	get {
		return gtksharp_gtk_widget_get_flags (Handle);
	}
	set {
		gtksharp_gtk_widget_set_flags (Handle, (int) value);
	}
}

public WidgetFlags WidgetFlags {
	get {
		return (WidgetFlags) gtksharp_gtk_widget_get_flags (Handle);
	}
	set {
		gtksharp_gtk_widget_set_flags (Handle, (int) value);
	}
}

public void SetFlag (WidgetFlags flag)
{
	Flags |= (int)flag;
}

public void ClearFlag (WidgetFlags flag)
{
	Flags &= ~((int)flag);
}

public bool IsMapped {
	get {
		return ((Flags & (int)Gtk.WidgetFlags.Mapped) != 0);
	}
}

public bool IsRealized {
	get {
		return ((Flags & (int)Gtk.WidgetFlags.Realized) != 0);
	}
}

public bool IsNoWindow {
	get {
		return ((Flags & (int)Gtk.WidgetFlags.NoWindow) != 0);
	}
}

public bool IsTopLevel {
	get {
		return ((Flags & (int)Gtk.WidgetFlags.Toplevel) != 0);
	}
}

public bool HasGrab {
	get {
		return ((Flags & (int)Gtk.WidgetFlags.HasGrab) != 0);
	}
}

public bool IsCompositeChild {
	get {
		return ((Flags & (int)Gtk.WidgetFlags.CompositeChild) != 0);
	}
}

public bool IsAppPaintable {
	get {
		return ((Flags & (int)Gtk.WidgetFlags.AppPaintable) != 0);
	}
}

public bool IsDoubleBuffered {
	get {
		return ((Flags & (int)Gtk.WidgetFlags.DoubleBuffered) != 0);
	}
}


public bool IsDrawable {
	get {
		return (Visible && IsMapped);
	}
}

[DllImport("gtksharpglue-2", CallingConvention=CallingConvention.Cdecl)]
static extern int gtksharp_gtk_widget_style_get_int (IntPtr raw, IntPtr name);

public int FocusLineWidth {
	get {
		IntPtr name = GLib.Marshaller.StringToPtrGStrdup ("focus-line-width");
		int result = gtksharp_gtk_widget_style_get_int (Handle, name);
		GLib.Marshaller.Free (name);
		return result;
	}
}

[DllImport("gtksharpglue-2", CallingConvention=CallingConvention.Cdecl)]
static extern int gtksharp_widget_connect_set_scroll_adjustments_signal (IntPtr gtype, SetScrollAdjustmentsDelegate cb);

[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
delegate void SetScrollAdjustmentsDelegate (IntPtr widget, IntPtr hadj, IntPtr vadj);

static SetScrollAdjustmentsDelegate SetScrollAdjustmentsCallback;

static void SetScrollAdjustments_cb (IntPtr widget, IntPtr hadj, IntPtr vadj)
{
	try {
		Widget obj;
		try {
			obj = GLib.Object.GetObject (widget, false) as Widget;
		} catch (GLib.MissingIntPtrCtorException) {
			return;
		}
		Gtk.Adjustment h = GLib.Object.GetObject (hadj, false) as Gtk.Adjustment;
		Gtk.Adjustment v = GLib.Object.GetObject (vadj, false) as Gtk.Adjustment;
		obj.OnSetScrollAdjustments (h, v);
	} catch (Exception e) {
		GLib.ExceptionManager.RaiseUnhandledException (e, false);
	}
}

static void ConnectSetScrollAdjustments (GLib.GType gtype)
{
	if (SetScrollAdjustmentsCallback == null)
		SetScrollAdjustmentsCallback = new SetScrollAdjustmentsDelegate (SetScrollAdjustments_cb);
	gtksharp_widget_connect_set_scroll_adjustments_signal (gtype.Val, SetScrollAdjustmentsCallback);
}

[GLib.DefaultSignalHandler (Type=typeof (Gtk.Widget), ConnectionMethod="ConnectSetScrollAdjustments")]
protected virtual void OnSetScrollAdjustments (Gtk.Adjustment hadj, Gtk.Adjustment vadj)
{
}

[DllImport("gtksharpglue-2", CallingConvention=CallingConvention.Cdecl)]
static extern int gtksharp_widget_connect_activate_signal (IntPtr gtype, ActivateDelegate cb);

[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
delegate void ActivateDelegate (IntPtr widget);

static ActivateDelegate ActivateCallback;

static void Activate_cb (IntPtr widget)
{
	try {
		Widget obj;
		try {
			obj = GLib.Object.GetObject (widget, false) as Widget;
		} catch (GLib.MissingIntPtrCtorException) {
			return;
		}
		obj.OnActivate ();
	} catch (Exception e) {
		GLib.ExceptionManager.RaiseUnhandledException (e, false);
	}
}

static void ConnectActivate (GLib.GType gtype)
{
	if (ActivateCallback == null)
		ActivateCallback = new ActivateDelegate (Activate_cb);
	gtksharp_widget_connect_activate_signal (gtype.Val, ActivateCallback);
}

[GLib.DefaultSignalHandler (Type=typeof (Gtk.Widget), ConnectionMethod="ConnectActivate")]
protected virtual void OnActivate ()
{
}

private class BindingInvoker {
	System.Reflection.MethodInfo mi;
	object[] parms;

	public BindingInvoker (System.Reflection.MethodInfo mi, object[] parms)
	{
		this.mi = mi;
		this.parms = parms;
	}

	public void Invoke (Widget w)
	{
		mi.Invoke (w, parms);
	}
}

[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
private delegate void BindingHandler (IntPtr handle, IntPtr user_data);

private static void BindingCallback (IntPtr handle, IntPtr user_data)
{
	try {
		Widget w = GLib.Object.GetObject (handle, false) as Widget;
		BindingInvoker invoker = ((GCHandle) user_data).Target as BindingInvoker;
		invoker.Invoke (w);
	} catch (Exception e) {
		GLib.ExceptionManager.RaiseUnhandledException (e, false);
	}
}

static BindingHandler binding_delegate;
static BindingHandler BindingDelegate {
	get {
		if (binding_delegate == null)
			binding_delegate = new BindingHandler (BindingCallback);
		return binding_delegate;
	}
}

[DllImport("gtksharpglue-2", CallingConvention=CallingConvention.Cdecl)]
static extern void gtksharp_widget_add_binding_signal (IntPtr gvalue, IntPtr name, BindingHandler handler);

[DllImport("gtksharpglue-2", CallingConvention=CallingConvention.Cdecl)]
static extern void gtksharp_widget_register_binding (IntPtr gvalue, IntPtr name, uint key, int mod, IntPtr data);

static void ClassInit (GLib.GType gtype, Type t)
{
	object[] attrs = t.GetCustomAttributes (typeof (BindingAttribute), true);

	if (attrs.Length == 0)
		return;

	IntPtr signame = GLib.Marshaller.StringToPtrGStrdup (t.Name.Replace (".", "_") + "_bindings");

	gtksharp_widget_add_binding_signal (gtype.Val, signame, BindingDelegate);

	foreach (BindingAttribute attr in attrs) {
		System.Reflection.MethodInfo mi = t.GetMethod (attr.Handler, System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Public);
		if (mi == null)
			throw new Exception ("Instance method " + attr.Handler + " not found in " + t);

		BindingInvoker inv = new BindingInvoker (mi, attr.Parms);
		gtksharp_widget_register_binding (gtype.Val, signame, (uint) attr.Key, (int) attr.Mod, (IntPtr) GCHandle.Alloc (inv));
	}
	GLib.Marshaller.Free (signame);
}

[DllImport("gtksharpglue-2", CallingConvention=CallingConvention.Cdecl)]
static extern bool gtksharp_widget_style_get_property (IntPtr widget, IntPtr property, ref GLib.Value value);

public object StyleGetProperty (string property_name) {
	GLib.Value value = new GLib.Value ();
	IntPtr name = GLib.Marshaller.StringToPtrGStrdup (property_name);
	bool success = gtksharp_widget_style_get_property (Handle, name, ref value);
	GLib.Marshaller.Free (name);

	if(success) {
		object ret = value.Val;
		value.Dispose ();
		return ret;
	}

	return null;
}

internal GLib.Value StyleGetPropertyValue (string property_name) {
	GLib.Value value = new GLib.Value ();

	IntPtr name = GLib.Marshaller.StringToPtrGStrdup (property_name);
	gtksharp_widget_style_get_property (Handle, name, ref value);
	GLib.Marshaller.Free (name);
	return value;
}

[DllImport("libgtk-win32-2.0-0.dll", CallingConvention=CallingConvention.Cdecl)]
static extern IntPtr gtk_widget_list_mnemonic_labels (IntPtr raw);

public Widget[] ListMnemonicLabels ()
{
	IntPtr raw_ret = gtk_widget_list_mnemonic_labels (Handle);
	if (raw_ret == IntPtr.Zero)
		return new Widget [0];
	return GLib.Marshaller.ListPtrToArray<Widget> (raw_ret, typeof (GLib.List), true, false);
}

[DllImport("libgtk-win32-2.0-0.dll", EntryPoint="gtk_widget_modify_base", CallingConvention = CallingConvention.Cdecl)]
static extern void gtk_widget_modify_base_ptr(IntPtr raw, int state, IntPtr color);

public void ModifyBase (Gtk.StateType state)
{
	gtk_widget_modify_base_ptr (Handle, (int) state, IntPtr.Zero);
}

[DllImport("libgtk-win32-2.0-0.dll", EntryPoint="gtk_widget_modify_bg", CallingConvention = CallingConvention.Cdecl)]
static extern void gtk_widget_modify_bg_ptr(IntPtr raw, int state, IntPtr color);

public void ModifyBg (Gtk.StateType state)
{
	gtk_widget_modify_bg_ptr (Handle, (int) state, IntPtr.Zero);
}

[DllImport("libgtk-win32-2.0-0.dll", EntryPoint="gtk_widget_modify_fg", CallingConvention = CallingConvention.Cdecl)]
static extern void gtk_widget_modify_fg_ptr(IntPtr raw, int state, IntPtr color);

public void ModifyFg (Gtk.StateType state)
{
	gtk_widget_modify_fg_ptr (Handle, (int) state, IntPtr.Zero);
}

[DllImport("libgtk-win32-2.0-0.dll", EntryPoint="gtk_widget_modify_text", CallingConvention = CallingConvention.Cdecl)]
static extern void gtk_widget_modify_text_ptr(IntPtr raw, int state, IntPtr color);

public void ModifyText (Gtk.StateType state)
{
	gtk_widget_modify_text_ptr (Handle, (int) state, IntPtr.Zero);
}

#endregion
	}

	internal class WidgetAttribute : GLib.GTypeTypeAttribute {
		[DllImport ("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_widget_get_type ();

		private static GLib.GType _gtype = new GLib.GType (gtk_widget_get_type ());
		public static GLib.GType GType { get { return _gtype; } }
		public override GLib.GType Type { get { return _gtype; } }

	}
}
