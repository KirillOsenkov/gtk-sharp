// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gtk {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	[Entry]
	public class Entry : Gtk.Widget, Gtk.Editable, Gtk.CellEditable {

		[Obsolete]
		protected Entry(GLib.GType gtype) : base(gtype) {}
		public Entry(IntPtr raw) : base(raw) {}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_entry_new();

		public Entry () : base (IntPtr.Zero)
		{
			if (GetType () != typeof (Entry)) {
				Gtk.Application.AssertMainThread();
				CreateNativeObject (Array.Empty<IntPtr> (), Array.Empty<GLib.Value> (), 0);
				return;
			}
			owned = true;
			Raw = gtk_entry_new();
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_entry_new_with_max_length(int max);

		public Entry (int max) : base (IntPtr.Zero)
		{
			if (GetType () != typeof (Entry)) {
				Gtk.Application.AssertMainThread();
				throw new InvalidOperationException ("Can't override this constructor.");
			}
			Gtk.Application.AssertMainThread();
			owned = true;
			Raw = gtk_entry_new_with_max_length(max);
		}

		[GLib.Property ("cursor-position")]
		public int CursorPosition {
			get {
				using (GLib.Value val = GetProperty ("cursor-position")) {
					int ret = (int) val;
					return ret;
				}
			}
		}

		[GLib.Property ("selection-bound")]
		public int SelectionBound {
			get {
				using (GLib.Value val = GetProperty ("selection-bound")) {
					int ret = (int) val;
					return ret;
				}
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_entry_get_max_length(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_entry_set_max_length(IntPtr raw, int max);

		[GLib.Property ("max-length")]
		public int MaxLength {
			get  {
				int raw_ret = gtk_entry_get_max_length(Handle);
				int ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_entry_set_max_length(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_entry_get_visibility(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_entry_set_visibility(IntPtr raw, bool visible);

		[GLib.Property ("visibility")]
		public bool Visibility {
			get  {
				bool raw_ret = gtk_entry_get_visibility(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_entry_set_visibility(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_entry_get_has_frame(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_entry_set_has_frame(IntPtr raw, bool setting);

		[GLib.Property ("has-frame")]
		public bool HasFrame {
			get  {
				bool raw_ret = gtk_entry_get_has_frame(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_entry_set_has_frame(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern uint gtk_entry_get_invisible_char(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_entry_set_invisible_char(IntPtr raw, uint ch);

		[GLib.Property ("invisible-char")]
		public char InvisibleChar {
			get  {
				uint raw_ret = gtk_entry_get_invisible_char(Handle);
				char ret = GLib.Marshaller.GUnicharToChar (raw_ret);
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_entry_set_invisible_char(Handle, GLib.Marshaller.CharToGUnichar (value));
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_entry_get_activates_default(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_entry_set_activates_default(IntPtr raw, bool setting);

		[GLib.Property ("activates-default")]
		public bool ActivatesDefault {
			get  {
				bool raw_ret = gtk_entry_get_activates_default(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_entry_set_activates_default(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_entry_get_width_chars(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_entry_set_width_chars(IntPtr raw, int n_chars);

		[GLib.Property ("width-chars")]
		public int WidthChars {
			get  {
				int raw_ret = gtk_entry_get_width_chars(Handle);
				int ret = raw_ret;
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				gtk_entry_set_width_chars(Handle, value);
			}
		}

		[GLib.Property ("scroll-offset")]
		public int ScrollOffset {
			get {
				using (GLib.Value val = GetProperty ("scroll-offset")) {
					int ret = (int) val;
					return ret;
				}
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_entry_get_text(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_entry_set_text(IntPtr raw, IntPtr text);

		[GLib.Property ("text")]
		public string Text {
			get  {
				IntPtr raw_ret = gtk_entry_get_text(Handle);
				string ret = GLib.Marshaller.Utf8PtrToString (raw_ret);
				return ret;
			}
			set  {
				Gtk.Application.AssertMainThread();
				IntPtr native_value = GLib.Marshaller.StringToPtrGStrdup (value);
				gtk_entry_set_text(Handle, native_value);
				GLib.Marshaller.Free (native_value);
			}
		}

		[GLib.Property ("xalign")]
		public float Xalign {
			get {
				using (GLib.Value val = GetProperty ("xalign")) {
					float ret = (float) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("xalign", val);
				}
			}
		}

		[GLib.Property ("truncate-multiline")]
		public bool TruncateMultiline {
			get {
				using (GLib.Value val = GetProperty ("truncate-multiline")) {
					bool ret = (bool) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value(value)) {
					SetProperty("truncate-multiline", val);
				}
			}
		}

		[GLib.Property ("shadow-type")]
		public Gtk.ShadowType ShadowType {
			get {
				using (GLib.Value val = GetProperty ("shadow-type")) {
					Gtk.ShadowType ret = (Gtk.ShadowType) (Enum) val;
					return ret;
				}
			}
			set {
				using (GLib.Value val = new GLib.Value((Enum) value)) {
					SetProperty("shadow-type", val);
				}
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void PopulatePopupVMDelegate (IntPtr entry, IntPtr menu);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_entry_override_populate_popup (IntPtr gtype, PopulatePopupVMDelegate cb);

		static PopulatePopupVMDelegate PopulatePopupVMCallback;

		static void populatepopup_cb (IntPtr entry, IntPtr menu)
		{
			try {
				Entry entry_managed = GLib.Object.GetObject (entry, false) as Entry;
				entry_managed.OnPopulatePopup (GLib.Object.GetObject(menu) as Gtk.Menu);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverridePopulatePopup (GLib.GType gtype)
		{
			if (PopulatePopupVMCallback == null)
				PopulatePopupVMCallback = new PopulatePopupVMDelegate (populatepopup_cb);
			gtksharp_entry_override_populate_popup (gtype.Val, PopulatePopupVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_entry_base_populate_popup (IntPtr entry, IntPtr menu);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Entry), ConnectionMethod="OverridePopulatePopup")]
		protected virtual void OnPopulatePopup (Gtk.Menu menu)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_entry_base_populate_popup (Handle, menu == null ? IntPtr.Zero : menu.Handle);
		}

		[GLib.Signal("populate_popup")]
		public event Gtk.PopulatePopupHandler PopulatePopup {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "populate_popup", typeof (Gtk.PopulatePopupArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "populate_popup", typeof (Gtk.PopulatePopupArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ActivatedVMDelegate (IntPtr entry);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_entry_override_activate (IntPtr gtype, ActivatedVMDelegate cb);

		static ActivatedVMDelegate ActivatedVMCallback;

		static void activated_cb (IntPtr entry)
		{
			try {
				Entry entry_managed = GLib.Object.GetObject (entry, false) as Entry;
				entry_managed.OnActivated ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideActivated (GLib.GType gtype)
		{
			if (ActivatedVMCallback == null)
				ActivatedVMCallback = new ActivatedVMDelegate (activated_cb);
			gtksharp_entry_override_activate (gtype.Val, ActivatedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_entry_base_activate (IntPtr entry);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Entry), ConnectionMethod="OverrideActivated")]
		protected virtual void OnActivated ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_entry_base_activate (Handle);
		}

		[GLib.Signal("activate")]
		public event System.EventHandler Activated {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "activate");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "activate");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void MoveCursorVMDelegate (IntPtr entry, int step, int count, bool extend_selection);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_entry_override_move_cursor (IntPtr gtype, MoveCursorVMDelegate cb);

		static MoveCursorVMDelegate MoveCursorVMCallback;

		static void movecursor_cb (IntPtr entry, int step, int count, bool extend_selection)
		{
			try {
				Entry entry_managed = GLib.Object.GetObject (entry, false) as Entry;
				entry_managed.OnMoveCursor ((Gtk.MovementStep) step, count, extend_selection);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideMoveCursor (GLib.GType gtype)
		{
			if (MoveCursorVMCallback == null)
				MoveCursorVMCallback = new MoveCursorVMDelegate (movecursor_cb);
			gtksharp_entry_override_move_cursor (gtype.Val, MoveCursorVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_entry_base_move_cursor (IntPtr entry, int step, int count, bool extend_selection);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Entry), ConnectionMethod="OverrideMoveCursor")]
		protected virtual void OnMoveCursor (Gtk.MovementStep step, int count, bool extend_selection)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_entry_base_move_cursor (Handle, (int) step, count, extend_selection);
		}

		[GLib.Signal("move_cursor")]
		public event Gtk.MoveCursorHandler MoveCursor {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "move_cursor", typeof (Gtk.MoveCursorArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "move_cursor", typeof (Gtk.MoveCursorArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void InsertAtCursorVMDelegate (IntPtr entry, IntPtr str);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_entry_override_insert_at_cursor (IntPtr gtype, InsertAtCursorVMDelegate cb);

		static InsertAtCursorVMDelegate InsertAtCursorVMCallback;

		static void insertatcursor_cb (IntPtr entry, IntPtr str)
		{
			try {
				Entry entry_managed = GLib.Object.GetObject (entry, false) as Entry;
				entry_managed.OnInsertAtCursor (GLib.Marshaller.Utf8PtrToString (str));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideInsertAtCursor (GLib.GType gtype)
		{
			if (InsertAtCursorVMCallback == null)
				InsertAtCursorVMCallback = new InsertAtCursorVMDelegate (insertatcursor_cb);
			gtksharp_entry_override_insert_at_cursor (gtype.Val, InsertAtCursorVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_entry_base_insert_at_cursor (IntPtr entry, IntPtr str);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Entry), ConnectionMethod="OverrideInsertAtCursor")]
		protected virtual void OnInsertAtCursor (string str)
		{
			Gtk.Application.AssertMainThread();
			IntPtr native_str = GLib.Marshaller.StringToPtrGStrdup (str);
			gtksharp_entry_base_insert_at_cursor (Handle, native_str);
			GLib.Marshaller.Free (native_str);
		}

		[GLib.Signal("insert_at_cursor")]
		public event Gtk.InsertAtCursorHandler InsertAtCursor {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "insert_at_cursor", typeof (Gtk.InsertAtCursorArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "insert_at_cursor", typeof (Gtk.InsertAtCursorArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DeleteFromCursorVMDelegate (IntPtr entry, int type, int count);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_entry_override_delete_from_cursor (IntPtr gtype, DeleteFromCursorVMDelegate cb);

		static DeleteFromCursorVMDelegate DeleteFromCursorVMCallback;

		static void deletefromcursor_cb (IntPtr entry, int type, int count)
		{
			try {
				Entry entry_managed = GLib.Object.GetObject (entry, false) as Entry;
				entry_managed.OnDeleteFromCursor ((Gtk.DeleteType) type, count);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideDeleteFromCursor (GLib.GType gtype)
		{
			if (DeleteFromCursorVMCallback == null)
				DeleteFromCursorVMCallback = new DeleteFromCursorVMDelegate (deletefromcursor_cb);
			gtksharp_entry_override_delete_from_cursor (gtype.Val, DeleteFromCursorVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_entry_base_delete_from_cursor (IntPtr entry, int type, int count);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Entry), ConnectionMethod="OverrideDeleteFromCursor")]
		protected virtual void OnDeleteFromCursor (Gtk.DeleteType type, int count)
		{
			Gtk.Application.AssertMainThread();
			gtksharp_entry_base_delete_from_cursor (Handle, (int) type, count);
		}

		[GLib.Signal("delete_from_cursor")]
		public event Gtk.DeleteFromCursorHandler DeleteFromCursor {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "delete_from_cursor", typeof (Gtk.DeleteFromCursorArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "delete_from_cursor", typeof (Gtk.DeleteFromCursorArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void BackspaceVMDelegate (IntPtr entry);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_entry_override_backspace (IntPtr gtype, BackspaceVMDelegate cb);

		static BackspaceVMDelegate BackspaceVMCallback;

		static void backspace_cb (IntPtr entry)
		{
			try {
				Entry entry_managed = GLib.Object.GetObject (entry, false) as Entry;
				entry_managed.OnBackspace ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideBackspace (GLib.GType gtype)
		{
			if (BackspaceVMCallback == null)
				BackspaceVMCallback = new BackspaceVMDelegate (backspace_cb);
			gtksharp_entry_override_backspace (gtype.Val, BackspaceVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_entry_base_backspace (IntPtr entry);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Entry), ConnectionMethod="OverrideBackspace")]
		protected virtual void OnBackspace ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_entry_base_backspace (Handle);
		}

		[GLib.Signal("backspace")]
		public event System.EventHandler Backspace {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "backspace");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "backspace");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ClipboardCutVMDelegate (IntPtr entry);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_entry_override_cut_clipboard (IntPtr gtype, ClipboardCutVMDelegate cb);

		static ClipboardCutVMDelegate ClipboardCutVMCallback;

		static void clipboardcut_cb (IntPtr entry)
		{
			try {
				Entry entry_managed = GLib.Object.GetObject (entry, false) as Entry;
				entry_managed.OnClipboardCut ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideClipboardCut (GLib.GType gtype)
		{
			if (ClipboardCutVMCallback == null)
				ClipboardCutVMCallback = new ClipboardCutVMDelegate (clipboardcut_cb);
			gtksharp_entry_override_cut_clipboard (gtype.Val, ClipboardCutVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_entry_base_cut_clipboard (IntPtr entry);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Entry), ConnectionMethod="OverrideClipboardCut")]
		protected virtual void OnClipboardCut ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_entry_base_cut_clipboard (Handle);
		}

		[GLib.Signal("cut_clipboard")]
		public event System.EventHandler ClipboardCut {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "cut_clipboard");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "cut_clipboard");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ClipboardCopiedVMDelegate (IntPtr entry);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_entry_override_copy_clipboard (IntPtr gtype, ClipboardCopiedVMDelegate cb);

		static ClipboardCopiedVMDelegate ClipboardCopiedVMCallback;

		static void clipboardcopied_cb (IntPtr entry)
		{
			try {
				Entry entry_managed = GLib.Object.GetObject (entry, false) as Entry;
				entry_managed.OnClipboardCopied ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideClipboardCopied (GLib.GType gtype)
		{
			if (ClipboardCopiedVMCallback == null)
				ClipboardCopiedVMCallback = new ClipboardCopiedVMDelegate (clipboardcopied_cb);
			gtksharp_entry_override_copy_clipboard (gtype.Val, ClipboardCopiedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_entry_base_copy_clipboard (IntPtr entry);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Entry), ConnectionMethod="OverrideClipboardCopied")]
		protected virtual void OnClipboardCopied ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_entry_base_copy_clipboard (Handle);
		}

		[GLib.Signal("copy_clipboard")]
		public event System.EventHandler ClipboardCopied {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "copy_clipboard");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "copy_clipboard");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ClipboardPastedVMDelegate (IntPtr entry);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_entry_override_paste_clipboard (IntPtr gtype, ClipboardPastedVMDelegate cb);

		static ClipboardPastedVMDelegate ClipboardPastedVMCallback;

		static void clipboardpasted_cb (IntPtr entry)
		{
			try {
				Entry entry_managed = GLib.Object.GetObject (entry, false) as Entry;
				entry_managed.OnClipboardPasted ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideClipboardPasted (GLib.GType gtype)
		{
			if (ClipboardPastedVMCallback == null)
				ClipboardPastedVMCallback = new ClipboardPastedVMDelegate (clipboardpasted_cb);
			gtksharp_entry_override_paste_clipboard (gtype.Val, ClipboardPastedVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_entry_base_paste_clipboard (IntPtr entry);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Entry), ConnectionMethod="OverrideClipboardPasted")]
		protected virtual void OnClipboardPasted ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_entry_base_paste_clipboard (Handle);
		}

		[GLib.Signal("paste_clipboard")]
		public event System.EventHandler ClipboardPasted {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "paste_clipboard");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "paste_clipboard");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ToggleOverwriteVMDelegate (IntPtr entry);

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_entry_override_toggle_overwrite (IntPtr gtype, ToggleOverwriteVMDelegate cb);

		static ToggleOverwriteVMDelegate ToggleOverwriteVMCallback;

		static void toggleoverwrite_cb (IntPtr entry)
		{
			try {
				Entry entry_managed = GLib.Object.GetObject (entry, false) as Entry;
				entry_managed.OnToggleOverwrite ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideToggleOverwrite (GLib.GType gtype)
		{
			if (ToggleOverwriteVMCallback == null)
				ToggleOverwriteVMCallback = new ToggleOverwriteVMDelegate (toggleoverwrite_cb);
			gtksharp_entry_override_toggle_overwrite (gtype.Val, ToggleOverwriteVMCallback);
		}

		[DllImport ("gtksharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtksharp_entry_base_toggle_overwrite (IntPtr entry);

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Entry), ConnectionMethod="OverrideToggleOverwrite")]
		protected virtual void OnToggleOverwrite ()
		{
			Gtk.Application.AssertMainThread();
			gtksharp_entry_base_toggle_overwrite (Handle);
		}

		[GLib.Signal("toggle_overwrite")]
		public event System.EventHandler ToggleOverwrite {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "toggle_overwrite");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "toggle_overwrite");
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_entry_append_text(IntPtr raw, IntPtr text);

		[Obsolete]
		public void AppendText(string text) {
			Gtk.Application.AssertMainThread();
			IntPtr native_text = GLib.Marshaller.StringToPtrGStrdup (text);
			gtk_entry_append_text(Handle, native_text);
			GLib.Marshaller.Free (native_text);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern float gtk_entry_get_alignment(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_entry_set_alignment(IntPtr raw, float xalign);

		public float Alignment { 
			get {
				float raw_ret = gtk_entry_get_alignment(Handle);
				float ret = raw_ret;
				return ret;
			}
			set {
				Gtk.Application.AssertMainThread();
				gtk_entry_set_alignment(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_entry_get_completion(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_entry_set_completion(IntPtr raw, IntPtr completion);

		public Gtk.EntryCompletion Completion { 
			get {
				IntPtr raw_ret = gtk_entry_get_completion(Handle);
				Gtk.EntryCompletion ret = GLib.Object.GetObject(raw_ret) as Gtk.EntryCompletion;
				return ret;
			}
			set {
				Gtk.Application.AssertMainThread();
				gtk_entry_set_completion(Handle, value == null ? IntPtr.Zero : value.Handle);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_entry_get_cursor_hadjustment(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_entry_set_cursor_hadjustment(IntPtr raw, IntPtr adjustment);

		public Gtk.Adjustment CursorHadjustment { 
			get {
				IntPtr raw_ret = gtk_entry_get_cursor_hadjustment(Handle);
				Gtk.Adjustment ret = GLib.Object.GetObject(raw_ret) as Gtk.Adjustment;
				return ret;
			}
			set {
				Gtk.Application.AssertMainThread();
				gtk_entry_set_cursor_hadjustment(Handle, value == null ? IntPtr.Zero : value.Handle);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_entry_get_layout(IntPtr raw);

		public Pango.Layout Layout { 
			get {
				IntPtr raw_ret = gtk_entry_get_layout(Handle);
				Pango.Layout ret = GLib.Object.GetObject(raw_ret) as Pango.Layout;
				return ret;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_entry_get_layout_offsets(IntPtr raw, out int x, out int y);

		public void GetLayoutOffsets(out int x, out int y) {
			Gtk.Application.AssertMainThread();
			gtk_entry_get_layout_offsets(Handle, out x, out y);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_entry_get_type();

		static GLib.GType _gtype = new GLib.GType (gtk_entry_get_type());
		public static new GLib.GType GType { 
			get {
								return _gtype;
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_entry_layout_index_to_text_index(IntPtr raw, int layout_index);

		public int LayoutIndexToTextIndex(int layout_index) {
			Gtk.Application.AssertMainThread();
			int raw_ret = gtk_entry_layout_index_to_text_index(Handle, layout_index);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_entry_prepend_text(IntPtr raw, IntPtr text);

		[Obsolete]
		public void PrependText(string text) {
			Gtk.Application.AssertMainThread();
			IntPtr native_text = GLib.Marshaller.StringToPtrGStrdup (text);
			gtk_entry_prepend_text(Handle, native_text);
			GLib.Marshaller.Free (native_text);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_entry_text_index_to_layout_index(IntPtr raw, int text_index);

		public int TextIndexToLayoutIndex(int text_index) {
			Gtk.Application.AssertMainThread();
			int raw_ret = gtk_entry_text_index_to_layout_index(Handle, text_index);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_editable_copy_clipboard(IntPtr raw);

		public void CopyClipboard() {
			gtk_editable_copy_clipboard(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_editable_cut_clipboard(IntPtr raw);

		public void CutClipboard() {
			gtk_editable_cut_clipboard(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_editable_delete_selection(IntPtr raw);

		public void DeleteSelection() {
			gtk_editable_delete_selection(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_editable_delete_text(IntPtr raw, int start_pos, int end_pos);

		public void DeleteText(int start_pos, int end_pos) {
			Gtk.Application.AssertMainThread();
			gtk_editable_delete_text(Handle, start_pos, end_pos);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_editable_get_chars(IntPtr raw, int start_pos, int end_pos);

		public string GetChars(int start_pos, int end_pos) {
			Gtk.Application.AssertMainThread();
			IntPtr raw_ret = gtk_editable_get_chars(Handle, start_pos, end_pos);
			string ret = GLib.Marshaller.PtrToStringGFree(raw_ret);
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_editable_get_editable(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_editable_set_editable(IntPtr raw, bool is_editable);

		public bool IsEditable { 
			get {
				bool raw_ret = gtk_editable_get_editable(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set {
				Gtk.Application.AssertMainThread();
				gtk_editable_set_editable(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_editable_get_position(IntPtr raw);

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_editable_set_position(IntPtr raw, int position);

		public int Position { 
			get {
				int raw_ret = gtk_editable_get_position(Handle);
				int ret = raw_ret;
				return ret;
			}
			set {
				Gtk.Application.AssertMainThread();
				gtk_editable_set_position(Handle, value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_editable_get_selection_bounds(IntPtr raw, out int start, out int end);

		public bool GetSelectionBounds(out int start, out int end) {
			Gtk.Application.AssertMainThread();
			bool raw_ret = gtk_editable_get_selection_bounds(Handle, out start, out end);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_editable_insert_text(IntPtr raw, IntPtr new_text, int new_text_length, ref int position);

		public void InsertText(string new_text, ref int position) {
			Gtk.Application.AssertMainThread();
			IntPtr native_new_text = GLib.Marshaller.StringToPtrGStrdup (new_text);
			gtk_editable_insert_text(Handle, native_new_text, System.Text.Encoding.UTF8.GetByteCount (new_text), ref position);
			GLib.Marshaller.Free (native_new_text);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_editable_paste_clipboard(IntPtr raw);

		public void PasteClipboard() {
			gtk_editable_paste_clipboard(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_editable_select_region(IntPtr raw, int start, int end);

		public void SelectRegion(int start, int end) {
			Gtk.Application.AssertMainThread();
			gtk_editable_select_region(Handle, start, end);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void TextInsertedVMDelegate (IntPtr editable, IntPtr text, int length, ref int position);

		static TextInsertedVMDelegate TextInsertedVMCallback;

		static void textinserted_cb (IntPtr editable, IntPtr text, int length, ref int position)
		{
			try {
				Entry editable_managed = GLib.Object.GetObject (editable, false) as Entry;
				editable_managed.OnTextInserted (GLib.Marshaller.Utf8PtrToString (text), ref position);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideTextInserted (GLib.GType gtype)
		{
			if (TextInsertedVMCallback == null)
				TextInsertedVMCallback = new TextInsertedVMDelegate (textinserted_cb);
			OverrideVirtualMethod (gtype, "insert_text", TextInsertedVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Entry), ConnectionMethod="OverrideTextInserted")]
		protected virtual void OnTextInserted (string text, ref int position)
		{
			GLib.Value ret = GLib.Value.Empty;
			unsafe {
				GLib.Value* inst_and_params = stackalloc GLib.Value [4];
				using (inst_and_params[0] = new GLib.Value (this)) {
					using (inst_and_params [1] = new GLib.Value (text)) {
						using (inst_and_params [2] = new GLib.Value (System.Text.Encoding.UTF8.GetByteCount (text))) {
							IntPtr position_ptr = GLib.Marshaller.StructureToPtrAlloc<int> (position);
							using (inst_and_params [3] = new GLib.Value (position_ptr)) {
								g_signal_chain_from_overridden (inst_and_params, ref ret);
								position = Marshal.PtrToStructure<int> (position_ptr);
								Marshal.FreeHGlobal (position_ptr);

							}
						}
					}
				}
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void TextInsertedSignalDelegate (IntPtr arg0, IntPtr arg1, int arg2, ref int arg3, IntPtr gch);

		static void TextInsertedSignalCallback (IntPtr arg0, IntPtr arg1, int arg2, ref int arg3, IntPtr gch)
		{
			Gtk.TextInsertedArgs args = new Gtk.TextInsertedArgs ();
			try {
				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
				if (sig == null)
					throw new Exception("Unknown signal GC handle received " + gch);

				args.Args = new object[3];
				args.Args[0] = GLib.Marshaller.Utf8PtrToString (arg1);
				args.Args[1] = arg2;
				args.Args[2] = arg3;
				Gtk.TextInsertedHandler handler = (Gtk.TextInsertedHandler) sig.Handler;
				handler (GLib.Object.GetObject (arg0), args);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}

			try {
				arg3 = ((int)args.Args[2]);
			} catch (Exception) {
				Exception ex = new Exception ("args.RetVal or 'out' property unset or set to incorrect type in Gtk.TextInsertedHandler callback");
				GLib.ExceptionManager.RaiseUnhandledException (ex, true);
				// NOTREACHED: above call doesn't return.
				throw ex;
			}
		}

		[GLib.Signal("insert_text")]
		public event Gtk.TextInsertedHandler TextInserted {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "insert_text", new TextInsertedSignalDelegate(TextInsertedSignalCallback));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "insert_text", new TextInsertedSignalDelegate(TextInsertedSignalCallback));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void TextDeletedVMDelegate (IntPtr editable, int start_pos, int end_pos);

		static TextDeletedVMDelegate TextDeletedVMCallback;

		static void textdeleted_cb (IntPtr editable, int start_pos, int end_pos)
		{
			try {
				Entry editable_managed = GLib.Object.GetObject (editable, false) as Entry;
				editable_managed.OnTextDeleted (start_pos, end_pos);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideTextDeleted (GLib.GType gtype)
		{
			if (TextDeletedVMCallback == null)
				TextDeletedVMCallback = new TextDeletedVMDelegate (textdeleted_cb);
			OverrideVirtualMethod (gtype, "delete_text", TextDeletedVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Entry), ConnectionMethod="OverrideTextDeleted")]
		protected virtual void OnTextDeleted (int start_pos, int end_pos)
		{
			GLib.Value ret = GLib.Value.Empty;
			unsafe {
				GLib.Value* inst_and_params = stackalloc GLib.Value [3];
				using (inst_and_params[0] = new GLib.Value (this)) {
					using (inst_and_params [1] = new GLib.Value (start_pos)) {
						using (inst_and_params [2] = new GLib.Value (end_pos)) {
							g_signal_chain_from_overridden (inst_and_params, ref ret);
						}
					}
				}
			}
		}

		[GLib.Signal("delete_text")]
		public event Gtk.TextDeletedHandler TextDeleted {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "delete_text", typeof (Gtk.TextDeletedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "delete_text", typeof (Gtk.TextDeletedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ChangedVMDelegate (IntPtr editable);

		static ChangedVMDelegate ChangedVMCallback;

		static void changed_cb (IntPtr editable)
		{
			try {
				Entry editable_managed = GLib.Object.GetObject (editable, false) as Entry;
				editable_managed.OnChanged ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideChanged (GLib.GType gtype)
		{
			if (ChangedVMCallback == null)
				ChangedVMCallback = new ChangedVMDelegate (changed_cb);
			OverrideVirtualMethod (gtype, "changed", ChangedVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Entry), ConnectionMethod="OverrideChanged")]
		protected virtual void OnChanged ()
		{
			GLib.Value ret = GLib.Value.Empty;
			unsafe {
				GLib.Value* inst_and_params = stackalloc GLib.Value [1];
				using (inst_and_params[0] = new GLib.Value (this)) {
					g_signal_chain_from_overridden (inst_and_params, ref ret);
				}
			}
		}

		[GLib.Signal("changed")]
		public event System.EventHandler Changed {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "changed");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "changed");
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_cell_editable_editing_done(IntPtr raw);

		public void FinishEditing() {
			gtk_cell_editable_editing_done(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_cell_editable_remove_widget(IntPtr raw);

		public void RemoveWidget() {
			gtk_cell_editable_remove_widget(Handle);
		}

		[DllImport("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_cell_editable_start_editing(IntPtr raw, IntPtr evnt);

		public void StartEditing(Gdk.Event evnt) {
			Gtk.Application.AssertMainThread();
			gtk_cell_editable_start_editing(Handle, evnt == null ? IntPtr.Zero : evnt.Handle);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void EditingDoneVMDelegate (IntPtr cell_editable);

		static EditingDoneVMDelegate EditingDoneVMCallback;

		static void editingdone_cb (IntPtr cell_editable)
		{
			try {
				Entry cell_editable_managed = GLib.Object.GetObject (cell_editable, false) as Entry;
				cell_editable_managed.OnEditingDone ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideEditingDone (GLib.GType gtype)
		{
			if (EditingDoneVMCallback == null)
				EditingDoneVMCallback = new EditingDoneVMDelegate (editingdone_cb);
			OverrideVirtualMethod (gtype, "editing_done", EditingDoneVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Entry), ConnectionMethod="OverrideEditingDone")]
		protected virtual void OnEditingDone ()
		{
			GLib.Value ret = GLib.Value.Empty;
			unsafe {
				GLib.Value* inst_and_params = stackalloc GLib.Value [1];
				using (inst_and_params[0] = new GLib.Value (this)) {
					g_signal_chain_from_overridden (inst_and_params, ref ret);
				}
			}
		}

		[GLib.Signal("editing_done")]
		public event System.EventHandler EditingDone {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "editing_done");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "editing_done");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void WidgetRemovedVMDelegate (IntPtr cell_editable);

		static WidgetRemovedVMDelegate WidgetRemovedVMCallback;

		static void widgetremoved_cb (IntPtr cell_editable)
		{
			try {
				Entry cell_editable_managed = GLib.Object.GetObject (cell_editable, false) as Entry;
				cell_editable_managed.OnWidgetRemoved ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideWidgetRemoved (GLib.GType gtype)
		{
			if (WidgetRemovedVMCallback == null)
				WidgetRemovedVMCallback = new WidgetRemovedVMDelegate (widgetremoved_cb);
			OverrideVirtualMethod (gtype, "remove_widget", WidgetRemovedVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Entry), ConnectionMethod="OverrideWidgetRemoved")]
		protected virtual void OnWidgetRemoved ()
		{
			GLib.Value ret = GLib.Value.Empty;
			unsafe {
				GLib.Value* inst_and_params = stackalloc GLib.Value [1];
				using (inst_and_params[0] = new GLib.Value (this)) {
					g_signal_chain_from_overridden (inst_and_params, ref ret);
				}
			}
		}

		[GLib.Signal("remove_widget")]
		public event System.EventHandler WidgetRemoved {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "remove_widget");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "remove_widget");
				sig.RemoveDelegate (value);
			}
		}

#endregion
#region Customized extensions
#line 1 "Entry.custom"
//
// Gtk.Entry.custom - Allow customization of values in the GtkEntry
//
// This code is inserted after the automatically generated code.
//
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of version 2 of the Lesser GNU General 
// Public License as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this program; if not, write to the
// Free Software Foundation, Inc., 59 Temple Place - Suite 330,
// Boston, MA 02111-1307, USA.


public int InsertText (string new_text)
{
	int position = 0;

	InsertText (new_text, ref position);

	return position;
}

public Entry(string initialText): this()
{
	Text = initialText;
}

[Obsolete("Replaced by IsEditable property")]
public bool Editable {
	get { return IsEditable; }
	set { IsEditable = value; }
}

#endregion
	}

	internal class EntryAttribute : GLib.GTypeTypeAttribute {
		[DllImport ("libgtk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_entry_get_type ();

		private static GLib.GType _gtype = new GLib.GType (gtk_entry_get_type ());
		public static GLib.GType GType { get { return _gtype; } }
		public override GLib.GType Type { get { return _gtype; } }

	}
}
