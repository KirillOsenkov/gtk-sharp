// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gdk {

	using System;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public class Spawn {

		[DllImport("libgdk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern unsafe bool gdk_spawn_command_line_on_screen(IntPtr screen, IntPtr command_line, out IntPtr error);

		public static unsafe bool CommandLineOnScreen(Gdk.Screen screen, string command_line) {
			IntPtr native_command_line = GLib.Marshaller.StringToPtrGStrdup (command_line);
			IntPtr error = IntPtr.Zero;
			bool raw_ret = gdk_spawn_command_line_on_screen(screen == null ? IntPtr.Zero : screen.Handle, native_command_line, out error);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_command_line);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgdk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern unsafe bool gdk_spawn_on_screen(IntPtr screen, IntPtr working_directory, IntPtr[] argv, IntPtr[] envp, int flags, GLibSharp.SpawnChildSetupFuncNative child_setup, IntPtr user_data, out int child_pid, out IntPtr error);

		public static unsafe bool OnScreen(Gdk.Screen screen, string working_directory, string[] argv, string[] envp, GLib.SpawnFlags flags, GLib.SpawnChildSetupFunc child_setup, out int child_pid) {
			IntPtr native_working_directory = GLib.Marshaller.StringToPtrGStrdup (working_directory);
			int cnt_argv = argv == null ? 0 : argv.Length;
			IntPtr[] native_argv = new IntPtr [cnt_argv + 1];
			for (int i = 0; i < cnt_argv; i++) {
				native_argv [i] = GLib.Marshaller.StringToPtrGStrdup(argv[i]);
			}
			native_argv [cnt_argv] = IntPtr.Zero;
			int cnt_envp = envp == null ? 0 : envp.Length;
			IntPtr[] native_envp = new IntPtr [cnt_envp + 1];
			for (int i = 0; i < cnt_envp; i++) {
				native_envp [i] = GLib.Marshaller.StringToPtrGStrdup(envp[i]);
			}
			native_envp [cnt_envp] = IntPtr.Zero;
			IntPtr gch = IntPtr.Zero;
			if (child_setup != null) {
				gch = (IntPtr)GCHandle.Alloc (child_setup);
			}
			IntPtr error = IntPtr.Zero;
			bool raw_ret = gdk_spawn_on_screen(screen == null ? IntPtr.Zero : screen.Handle, native_working_directory, native_argv, native_envp, (int) flags, (child_setup == null) ? null : GLibSharp.SpawnChildSetupFuncWrapper.NativeDelegate, (IntPtr)gch, out child_pid, out error);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_working_directory);
			for (int i = 0; i < cnt_argv; i++) {
				GLib.Marshaller.Free (native_argv[i]);
			}
			for (int i = 0; i < cnt_envp; i++) {
				GLib.Marshaller.Free (native_envp[i]);
			}
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgdk-win32-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern unsafe bool gdk_spawn_on_screen_with_pipes(IntPtr screen, IntPtr working_directory, IntPtr[] argv, IntPtr[] envp, int flags, GLibSharp.SpawnChildSetupFuncNative child_setup, IntPtr user_data, out int child_pid, out int standard_input, out int standard_output, out int standard_error, out IntPtr error);

		public static unsafe bool OnScreenWithPipes(Gdk.Screen screen, string working_directory, string[] argv, string[] envp, GLib.SpawnFlags flags, GLib.SpawnChildSetupFunc child_setup, out int child_pid, out int standard_input, out int standard_output, out int standard_error) {
			IntPtr native_working_directory = GLib.Marshaller.StringToPtrGStrdup (working_directory);
			int cnt_argv = argv == null ? 0 : argv.Length;
			IntPtr[] native_argv = new IntPtr [cnt_argv + 1];
			for (int i = 0; i < cnt_argv; i++) {
				native_argv [i] = GLib.Marshaller.StringToPtrGStrdup(argv[i]);
			}
			native_argv [cnt_argv] = IntPtr.Zero;
			int cnt_envp = envp == null ? 0 : envp.Length;
			IntPtr[] native_envp = new IntPtr [cnt_envp + 1];
			for (int i = 0; i < cnt_envp; i++) {
				native_envp [i] = GLib.Marshaller.StringToPtrGStrdup(envp[i]);
			}
			native_envp [cnt_envp] = IntPtr.Zero;
			IntPtr gch = IntPtr.Zero;
			if (child_setup != null) {
				gch = (IntPtr)GCHandle.Alloc (child_setup);
			}
			IntPtr error = IntPtr.Zero;
			bool raw_ret = gdk_spawn_on_screen_with_pipes(screen == null ? IntPtr.Zero : screen.Handle, native_working_directory, native_argv, native_envp, (int) flags, (child_setup == null) ? null : GLibSharp.SpawnChildSetupFuncWrapper.NativeDelegate, (IntPtr)gch, out child_pid, out standard_input, out standard_output, out standard_error, out error);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_working_directory);
			for (int i = 0; i < cnt_argv; i++) {
				GLib.Marshaller.Free (native_argv[i]);
			}
			for (int i = 0; i < cnt_envp; i++) {
				GLib.Marshaller.Free (native_envp[i]);
			}
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

#endregion
	}
}
