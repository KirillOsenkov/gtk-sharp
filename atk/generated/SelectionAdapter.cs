// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Atk {

	using System;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public class SelectionAdapter : GLib.GInterfaceAdapter, Atk.Selection {

		static SelectionIface iface;

		struct SelectionIface {
			public IntPtr gtype;
			public IntPtr itype;

			public AddSelectionDelegate add_selection;
			public ClearSelectionDelegate clear_selection;
			public RefSelectionDelegate ref_selection;
			public GetSelectionCountDelegate get_selection_count;
			public IsChildSelectedDelegate is_child_selected;
			public RemoveSelectionDelegate remove_selection;
			public SelectAllSelectionDelegate select_all_selection;
			public IntPtr selection_changed;
		}

		static SelectionAdapter ()
		{
			GLib.GType.Register (_gtype, typeof(SelectionAdapter));
			iface.add_selection = new AddSelectionDelegate (AddSelectionCallback);
			iface.clear_selection = new ClearSelectionDelegate (ClearSelectionCallback);
			iface.ref_selection = new RefSelectionDelegate (RefSelectionCallback);
			iface.get_selection_count = new GetSelectionCountDelegate (GetSelectionCountCallback);
			iface.is_child_selected = new IsChildSelectedDelegate (IsChildSelectedCallback);
			iface.remove_selection = new RemoveSelectionDelegate (RemoveSelectionCallback);
			iface.select_all_selection = new SelectAllSelectionDelegate (SelectAllSelectionCallback);
		}


		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool AddSelectionDelegate (IntPtr selection, int i);

		static bool AddSelectionCallback (IntPtr selection, int i)
		{
			try {
				Atk.SelectionImplementor __obj = GLib.Object.GetObject (selection, false) as Atk.SelectionImplementor;
				bool __result = __obj.AddSelection (i);
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool ClearSelectionDelegate (IntPtr selection);

		static bool ClearSelectionCallback (IntPtr selection)
		{
			try {
				Atk.SelectionImplementor __obj = GLib.Object.GetObject (selection, false) as Atk.SelectionImplementor;
				bool __result = __obj.ClearSelection ();
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr RefSelectionDelegate (IntPtr selection, int i);

		static IntPtr RefSelectionCallback (IntPtr selection, int i)
		{
			try {
				Atk.SelectionImplementor __obj = GLib.Object.GetObject (selection, false) as Atk.SelectionImplementor;
				Atk.Object __result = __obj.RefSelection (i);
				return __result == null ? IntPtr.Zero : __result.OwnedHandle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate int GetSelectionCountDelegate (IntPtr selection);

		static int GetSelectionCountCallback (IntPtr selection)
		{
			try {
				Atk.SelectionImplementor __obj = GLib.Object.GetObject (selection, false) as Atk.SelectionImplementor;
				int __result = __obj.SelectionCount;
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool IsChildSelectedDelegate (IntPtr selection, int i);

		static bool IsChildSelectedCallback (IntPtr selection, int i)
		{
			try {
				Atk.SelectionImplementor __obj = GLib.Object.GetObject (selection, false) as Atk.SelectionImplementor;
				bool __result = __obj.IsChildSelected (i);
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool RemoveSelectionDelegate (IntPtr selection, int i);

		static bool RemoveSelectionCallback (IntPtr selection, int i)
		{
			try {
				Atk.SelectionImplementor __obj = GLib.Object.GetObject (selection, false) as Atk.SelectionImplementor;
				bool __result = __obj.RemoveSelection (i);
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool SelectAllSelectionDelegate (IntPtr selection);

		static bool SelectAllSelectionCallback (IntPtr selection)
		{
			try {
				Atk.SelectionImplementor __obj = GLib.Object.GetObject (selection, false) as Atk.SelectionImplementor;
				bool __result = __obj.SelectAllSelection ();
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}
		static void Initialize (IntPtr ifaceptr, IntPtr data)
		{
			SelectionIface native_iface = Marshal.PtrToStructure<SelectionIface> (ifaceptr);
			native_iface.add_selection = iface.add_selection;
			native_iface.clear_selection = iface.clear_selection;
			native_iface.ref_selection = iface.ref_selection;
			native_iface.get_selection_count = iface.get_selection_count;
			native_iface.is_child_selected = iface.is_child_selected;
			native_iface.remove_selection = iface.remove_selection;
			native_iface.select_all_selection = iface.select_all_selection;
			Marshal.StructureToPtr<SelectionIface> (native_iface, ifaceptr, false);
			GCHandle gch = (GCHandle) data;
			gch.Free ();
		}

		public SelectionAdapter ()
		{
			InitHandler = new GLib.GInterfaceInitHandler (Initialize);
		}

		SelectionImplementor implementor;

		public SelectionAdapter (SelectionImplementor implementor)
		{
			if (implementor == null)
				throw new ArgumentNullException ("implementor");
			this.implementor = implementor;
		}

		public SelectionAdapter (IntPtr handle)
		{
			this.handle = handle;
		}

		[DllImport("libatk-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr atk_selection_get_type();

		private static GLib.GType _gtype = new GLib.GType (atk_selection_get_type ());

		public override GLib.GType GType {
			get {
				return _gtype;
			}
		}

		IntPtr handle;
		public override IntPtr Handle {
			get {
				if (handle != IntPtr.Zero)
					return handle;
				return implementor == null ? IntPtr.Zero : implementor.Handle;
			}
		}

		public static Selection GetObject (IntPtr handle, bool owned)
		{
			GLib.Object obj = GLib.Object.GetObject (handle, owned);
			return GetObject (obj);
		}

		public static Selection GetObject (GLib.Object obj)
		{
			if (obj == null)
				return null;
			else if (obj is SelectionImplementor)
				return new SelectionAdapter (obj as SelectionImplementor);
			else if (obj as Selection == null)
				return new SelectionAdapter (obj.Handle);
			else
				return obj as Selection;
		}

		public SelectionImplementor Implementor {
			get {
				return implementor;
			}
		}

		[GLib.Signal("selection_changed")]
		public event System.EventHandler SelectionChanged {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (GLib.Object.GetObject (Handle), "selection_changed");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (GLib.Object.GetObject (Handle), "selection_changed");
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("libatk-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool atk_selection_add_selection(IntPtr raw, int i);

		public bool AddSelection(int i) {
			bool raw_ret = atk_selection_add_selection(Handle, i);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libatk-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool atk_selection_clear_selection(IntPtr raw);

		public bool ClearSelection() {
			bool raw_ret = atk_selection_clear_selection(Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libatk-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int atk_selection_get_selection_count(IntPtr raw);

		public int SelectionCount { 
			get {
				int raw_ret = atk_selection_get_selection_count(Handle);
				int ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libatk-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool atk_selection_is_child_selected(IntPtr raw, int i);

		public bool IsChildSelected(int i) {
			bool raw_ret = atk_selection_is_child_selected(Handle, i);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libatk-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr atk_selection_ref_selection(IntPtr raw, int i);

		public Atk.Object RefSelection(int i) {
			IntPtr raw_ret = atk_selection_ref_selection(Handle, i);
			Atk.Object ret = GLib.Object.GetObject(raw_ret, true) as Atk.Object;
			return ret;
		}

		[DllImport("libatk-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool atk_selection_remove_selection(IntPtr raw, int i);

		public bool RemoveSelection(int i) {
			bool raw_ret = atk_selection_remove_selection(Handle, i);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libatk-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool atk_selection_select_all_selection(IntPtr raw);

		public bool SelectAllSelection() {
			bool raw_ret = atk_selection_select_all_selection(Handle);
			bool ret = raw_ret;
			return ret;
		}

#endregion
#region Customized extensions
#line 1 "SelectionAdapter.custom"
// SelectionAdapter.custom - Atk SelectionAdapter class customizations
//
// Author: Andr√©s G. Aragoneses <aaragoneses@novell.com>
//
// Copyright (c) 2008 Novell, Inc.
//
// This code is inserted after the automatically generated code.
//
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of version 2 of the Lesser GNU General 
// Public License as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this program; if not, write to the
// Free Software Foundation, Inc., 59 Temple Place - Suite 330,
// Boston, MA 02111-1307, USA.
		
		public void EmitSelectionChanged ()
		{
			GLib.Signal.Emit (GLib.Object.GetObject (Handle), "selection_changed");
		}

#endregion
	}
}
